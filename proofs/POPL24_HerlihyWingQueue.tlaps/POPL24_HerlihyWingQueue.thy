(* automatically generated -- do not edit manually *)
theory POPL24_HerlihyWingQueue imports Constant Zenon begin
ML_command {* writeln ("*** TLAPS PARSED\n"); *}
consts
  "isReal" :: c
  "isa_slas_a" :: "[c,c] => c"
  "isa_bksl_diva" :: "[c,c] => c"
  "isa_perc_a" :: "[c,c] => c"
  "isa_peri_peri_a" :: "[c,c] => c"
  "isInfinity" :: c
  "isa_lbrk_rbrk_a" :: "[c] => c"
  "isa_less_more_a" :: "[c] => c"

lemma ob'21:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Spec suppressed *)
assumes v'184: "((((pc) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & (((X) \<in> (((Nat) \\ ({((0))}))))) & (((Q) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((i) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((j) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((l) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((x) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((v) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((M) \<in> ((SUBSET (subsetOf(([''sigma'' : ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))]))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %a_ca. (\<forall> p \<in> (ProcSet) : ((((((fapply ((pc), (p))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p))) = (BOT))))) & (((((fapply ((pc), (p))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p))) \<in> ({(ACK), (BOT)}))))) & (((((fapply ((pc), (p))) \<in> ({(''D4'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)}))))))))))))))))"
assumes v'185: "(((\<exists> p \<in> (ProcSet) : (((a_L0a ((p)))) | ((a_E1a ((p)))) | ((a_E2a ((p)))) | ((a_E3a ((p)))) | ((a_D1a ((p)))) | ((a_D2a ((p)))) | ((a_D3a ((p)))) | ((a_D4a ((p)))))) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))"
assumes v'198: "((\<And> p :: c. p \<in> (ProcSet) \<Longrightarrow> (((a_L0a ((p)))) \<Longrightarrow> (((((a_pchash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & ((((a_Xhash_primea :: c)) \<in> (((Nat) \\ ({((0))}))))) & ((((a_Qhash_primea :: c)) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & ((((a_ihash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_jhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_lhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_xhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & ((((a_vhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_Mhash_primea :: c)) \<in> ((SUBSET (subsetOf(([''sigma'' : ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))]))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %a_ca. (\<forall> p_1 \<in> (ProcSet) : ((((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''D4'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))))))))))))))))))"
assumes v'199: "((\<And> p :: c. p \<in> (ProcSet) \<Longrightarrow> (((a_E1a ((p)))) \<Longrightarrow> (((((a_pchash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & ((((a_Xhash_primea :: c)) \<in> (((Nat) \\ ({((0))}))))) & ((((a_Qhash_primea :: c)) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & ((((a_ihash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_jhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_lhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_xhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & ((((a_vhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_Mhash_primea :: c)) \<in> ((SUBSET (subsetOf(([''sigma'' : ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))]))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %a_ca. (\<forall> p_1 \<in> (ProcSet) : ((((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''D4'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))))))))))))))))))"
assumes v'200: "((\<And> p :: c. p \<in> (ProcSet) \<Longrightarrow> (((a_E2a ((p)))) \<Longrightarrow> (((((a_pchash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & ((((a_Xhash_primea :: c)) \<in> (((Nat) \\ ({((0))}))))) & ((((a_Qhash_primea :: c)) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & ((((a_ihash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_jhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_lhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_xhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & ((((a_vhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_Mhash_primea :: c)) \<in> ((SUBSET (subsetOf(([''sigma'' : ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))]))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %a_ca. (\<forall> p_1 \<in> (ProcSet) : ((((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''D4'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))))))))))))))))))"
assumes v'201: "((\<And> p :: c. p \<in> (ProcSet) \<Longrightarrow> (((a_E3a ((p)))) \<Longrightarrow> (((((a_pchash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & ((((a_Xhash_primea :: c)) \<in> (((Nat) \\ ({((0))}))))) & ((((a_Qhash_primea :: c)) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & ((((a_ihash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_jhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_lhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_xhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & ((((a_vhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_Mhash_primea :: c)) \<in> ((SUBSET (subsetOf(([''sigma'' : ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))]))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %a_ca. (\<forall> p_1 \<in> (ProcSet) : ((((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''D4'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))))))))))))))))))"
assumes v'202: "((\<And> p :: c. p \<in> (ProcSet) \<Longrightarrow> (((a_D1a ((p)))) \<Longrightarrow> (((((a_pchash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & ((((a_Xhash_primea :: c)) \<in> (((Nat) \\ ({((0))}))))) & ((((a_Qhash_primea :: c)) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & ((((a_ihash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_jhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_lhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_xhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & ((((a_vhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_Mhash_primea :: c)) \<in> ((SUBSET (subsetOf(([''sigma'' : ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))]))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %a_ca. (\<forall> p_1 \<in> (ProcSet) : ((((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''D4'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))))))))))))))))))"
assumes v'203: "((\<And> p :: c. p \<in> (ProcSet) \<Longrightarrow> (((a_D2a ((p)))) \<Longrightarrow> (((((a_pchash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & ((((a_Xhash_primea :: c)) \<in> (((Nat) \\ ({((0))}))))) & ((((a_Qhash_primea :: c)) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & ((((a_ihash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_jhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_lhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_xhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & ((((a_vhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_Mhash_primea :: c)) \<in> ((SUBSET (subsetOf(([''sigma'' : ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))]))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %a_ca. (\<forall> p_1 \<in> (ProcSet) : ((((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''D4'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))))))))))))))))))"
assumes v'204: "((\<And> p :: c. p \<in> (ProcSet) \<Longrightarrow> (((a_D3a ((p)))) \<Longrightarrow> (((((a_pchash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & ((((a_Xhash_primea :: c)) \<in> (((Nat) \\ ({((0))}))))) & ((((a_Qhash_primea :: c)) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & ((((a_ihash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_jhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_lhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_xhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & ((((a_vhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_Mhash_primea :: c)) \<in> ((SUBSET (subsetOf(([''sigma'' : ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))]))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %a_ca. (\<forall> p_1 \<in> (ProcSet) : ((((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''D4'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))))))))))))))))))"
assumes v'205: "((\<And> p :: c. p \<in> (ProcSet) \<Longrightarrow> (((a_D4a ((p)))) \<Longrightarrow> (((((a_pchash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & ((((a_Xhash_primea :: c)) \<in> (((Nat) \\ ({((0))}))))) & ((((a_Qhash_primea :: c)) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & ((((a_ihash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_jhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_lhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_xhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & ((((a_vhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_Mhash_primea :: c)) \<in> ((SUBSET (subsetOf(([''sigma'' : ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))]))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %a_ca. (\<forall> p_1 \<in> (ProcSet) : ((((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''D4'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))))))))))))))))))"
assumes v'206: "((((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars))) \<Longrightarrow> (((((a_pchash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & ((((a_Xhash_primea :: c)) \<in> (((Nat) \\ ({((0))}))))) & ((((a_Qhash_primea :: c)) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & ((((a_ihash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_jhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_lhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_xhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & ((((a_vhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_Mhash_primea :: c)) \<in> ((SUBSET (subsetOf(([''sigma'' : ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))]))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %a_ca. (\<forall> p \<in> (ProcSet) : ((((((fapply (((a_pchash_primea :: c)), (p))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (p))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (p))) \<in> ({(''D4'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)}))))))))))))))))))"
shows "(((((a_pchash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & ((((a_Xhash_primea :: c)) \<in> (((Nat) \\ ({((0))}))))) & ((((a_Qhash_primea :: c)) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & ((((a_ihash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_jhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_lhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_xhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & ((((a_vhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_Mhash_primea :: c)) \<in> ((SUBSET (subsetOf(([''sigma'' : ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))]))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %a_ca. (\<forall> p \<in> (ProcSet) : ((((((fapply (((a_pchash_primea :: c)), (p))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (p))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (p))) \<in> ({(''D4'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)}))))))))))))))))"(is "PROP ?ob'21")
proof -
ML_command {* writeln "*** TLAPS ENTER 21"; *}
show "PROP ?ob'21"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_8f2ccb.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_8f2ccb.znn.out
;; obligation #21
$hyp "v'184" (/\ (TLA.in pc
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in X (TLA.setminus arith.N (TLA.set 0))) (TLA.in Q
(TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in i (TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in j
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in l
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in x
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in v (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in M
(TLA.SUBSET (TLA.subsetOf (TLA.recordset "sigma" (TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))) ((a_ca) (TLA.bAll ProcSet ((p) (/\ (=> (TLA.in (TLA.fapply pc p)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply a_ca "fres") p) BOT))
(=> (TLA.in (TLA.fapply pc p) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p) (TLA.set ACK BOT)))
(=> (TLA.in (TLA.fapply pc p) (TLA.set "D4"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT))))))))))))
$hyp "v'185" (\/ (TLA.bEx ProcSet ((p) (\/ (a_L0a p) (a_E1a p) (a_E2a p)
(a_E3a p) (a_D1a p) (a_D2a p) (a_D3a p) (a_D4a p))))
(= a_h4fd5f73954dc53af536c1c75068837a
vars))
$hyp "v'198" (TLA.bAll ProcSet ((p) (=> (a_L0a p) (/\ (TLA.in a_pchash_primea
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in a_Xhash_primea (TLA.setminus arith.N (TLA.set 0)))
(TLA.in a_Qhash_primea (TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in a_ihash_primea (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in a_jhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0))))
(TLA.in a_lhash_primea (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in a_xhash_primea
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in a_vhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0))))
(TLA.in a_Mhash_primea
(TLA.SUBSET (TLA.subsetOf (TLA.recordset "sigma" (TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))) ((a_ca) (TLA.bAll ProcSet ((p_1) (/\ (=> (TLA.in (TLA.fapply a_pchash_primea p_1)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply a_ca "fres") p_1) BOT))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p_1) (TLA.set ACK BOT)))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "D4"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p_1)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))))))))))))))
$hyp "v'199" (TLA.bAll ProcSet ((p) (=> (a_E1a p) (/\ (TLA.in a_pchash_primea
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in a_Xhash_primea (TLA.setminus arith.N (TLA.set 0)))
(TLA.in a_Qhash_primea (TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in a_ihash_primea (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in a_jhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0))))
(TLA.in a_lhash_primea (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in a_xhash_primea
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in a_vhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0))))
(TLA.in a_Mhash_primea
(TLA.SUBSET (TLA.subsetOf (TLA.recordset "sigma" (TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))) ((a_ca) (TLA.bAll ProcSet ((p_1) (/\ (=> (TLA.in (TLA.fapply a_pchash_primea p_1)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply a_ca "fres") p_1) BOT))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p_1) (TLA.set ACK BOT)))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "D4"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p_1)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))))))))))))))
$hyp "v'200" (TLA.bAll ProcSet ((p) (=> (a_E2a p) (/\ (TLA.in a_pchash_primea
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in a_Xhash_primea (TLA.setminus arith.N (TLA.set 0)))
(TLA.in a_Qhash_primea (TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in a_ihash_primea (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in a_jhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0))))
(TLA.in a_lhash_primea (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in a_xhash_primea
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in a_vhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0))))
(TLA.in a_Mhash_primea
(TLA.SUBSET (TLA.subsetOf (TLA.recordset "sigma" (TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))) ((a_ca) (TLA.bAll ProcSet ((p_1) (/\ (=> (TLA.in (TLA.fapply a_pchash_primea p_1)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply a_ca "fres") p_1) BOT))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p_1) (TLA.set ACK BOT)))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "D4"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p_1)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))))))))))))))
$hyp "v'201" (TLA.bAll ProcSet ((p) (=> (a_E3a p) (/\ (TLA.in a_pchash_primea
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in a_Xhash_primea (TLA.setminus arith.N (TLA.set 0)))
(TLA.in a_Qhash_primea (TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in a_ihash_primea (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in a_jhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0))))
(TLA.in a_lhash_primea (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in a_xhash_primea
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in a_vhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0))))
(TLA.in a_Mhash_primea
(TLA.SUBSET (TLA.subsetOf (TLA.recordset "sigma" (TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))) ((a_ca) (TLA.bAll ProcSet ((p_1) (/\ (=> (TLA.in (TLA.fapply a_pchash_primea p_1)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply a_ca "fres") p_1) BOT))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p_1) (TLA.set ACK BOT)))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "D4"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p_1)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))))))))))))))
$hyp "v'202" (TLA.bAll ProcSet ((p) (=> (a_D1a p) (/\ (TLA.in a_pchash_primea
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in a_Xhash_primea (TLA.setminus arith.N (TLA.set 0)))
(TLA.in a_Qhash_primea (TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in a_ihash_primea (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in a_jhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0))))
(TLA.in a_lhash_primea (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in a_xhash_primea
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in a_vhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0))))
(TLA.in a_Mhash_primea
(TLA.SUBSET (TLA.subsetOf (TLA.recordset "sigma" (TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))) ((a_ca) (TLA.bAll ProcSet ((p_1) (/\ (=> (TLA.in (TLA.fapply a_pchash_primea p_1)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply a_ca "fres") p_1) BOT))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p_1) (TLA.set ACK BOT)))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "D4"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p_1)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))))))))))))))
$hyp "v'203" (TLA.bAll ProcSet ((p) (=> (a_D2a p) (/\ (TLA.in a_pchash_primea
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in a_Xhash_primea (TLA.setminus arith.N (TLA.set 0)))
(TLA.in a_Qhash_primea (TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in a_ihash_primea (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in a_jhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0))))
(TLA.in a_lhash_primea (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in a_xhash_primea
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in a_vhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0))))
(TLA.in a_Mhash_primea
(TLA.SUBSET (TLA.subsetOf (TLA.recordset "sigma" (TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))) ((a_ca) (TLA.bAll ProcSet ((p_1) (/\ (=> (TLA.in (TLA.fapply a_pchash_primea p_1)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply a_ca "fres") p_1) BOT))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p_1) (TLA.set ACK BOT)))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "D4"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p_1)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))))))))))))))
$hyp "v'204" (TLA.bAll ProcSet ((p) (=> (a_D3a p) (/\ (TLA.in a_pchash_primea
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in a_Xhash_primea (TLA.setminus arith.N (TLA.set 0)))
(TLA.in a_Qhash_primea (TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in a_ihash_primea (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in a_jhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0))))
(TLA.in a_lhash_primea (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in a_xhash_primea
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in a_vhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0))))
(TLA.in a_Mhash_primea
(TLA.SUBSET (TLA.subsetOf (TLA.recordset "sigma" (TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))) ((a_ca) (TLA.bAll ProcSet ((p_1) (/\ (=> (TLA.in (TLA.fapply a_pchash_primea p_1)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply a_ca "fres") p_1) BOT))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p_1) (TLA.set ACK BOT)))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "D4"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p_1)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))))))))))))))
$hyp "v'205" (TLA.bAll ProcSet ((p) (=> (a_D4a p) (/\ (TLA.in a_pchash_primea
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in a_Xhash_primea (TLA.setminus arith.N (TLA.set 0)))
(TLA.in a_Qhash_primea (TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in a_ihash_primea (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in a_jhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0))))
(TLA.in a_lhash_primea (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in a_xhash_primea
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in a_vhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0))))
(TLA.in a_Mhash_primea
(TLA.SUBSET (TLA.subsetOf (TLA.recordset "sigma" (TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))) ((a_ca) (TLA.bAll ProcSet ((p_1) (/\ (=> (TLA.in (TLA.fapply a_pchash_primea p_1)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply a_ca "fres") p_1) BOT))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p_1) (TLA.set ACK BOT)))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "D4"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p_1)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))))))))))))))
$hyp "v'206" (=> (= a_h4fd5f73954dc53af536c1c75068837a
vars) (/\ (TLA.in a_pchash_primea
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in a_Xhash_primea (TLA.setminus arith.N (TLA.set 0)))
(TLA.in a_Qhash_primea (TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in a_ihash_primea (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in a_jhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0))))
(TLA.in a_lhash_primea (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in a_xhash_primea
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in a_vhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0))))
(TLA.in a_Mhash_primea
(TLA.SUBSET (TLA.subsetOf (TLA.recordset "sigma" (TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))) ((a_ca) (TLA.bAll ProcSet ((p) (/\ (=> (TLA.in (TLA.fapply a_pchash_primea p)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply a_ca "fres") p) BOT))
(=> (TLA.in (TLA.fapply a_pchash_primea p) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p) (TLA.set ACK BOT)))
(=> (TLA.in (TLA.fapply a_pchash_primea p) (TLA.set "D4"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))))))))))))
$goal (/\ (TLA.in a_pchash_primea
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in a_Xhash_primea (TLA.setminus arith.N (TLA.set 0)))
(TLA.in a_Qhash_primea (TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in a_ihash_primea (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in a_jhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0))))
(TLA.in a_lhash_primea (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in a_xhash_primea
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in a_vhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0))))
(TLA.in a_Mhash_primea
(TLA.SUBSET (TLA.subsetOf (TLA.recordset "sigma" (TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))) ((a_ca) (TLA.bAll ProcSet ((p) (/\ (=> (TLA.in (TLA.fapply a_pchash_primea p)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply a_ca "fres") p) BOT))
(=> (TLA.in (TLA.fapply a_pchash_primea p) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p) (TLA.set ACK BOT)))
(=> (TLA.in (TLA.fapply a_pchash_primea p) (TLA.set "D4"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT))))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hc:"bAll(ProcSet, (\<lambda>p. (a_L0a(p)=>((a_pchash_primea \\in FuncSet(ProcSet, {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))&((a_Xhash_primea \\in (Nat \\ {0}))&((a_Qhash_primea \\in FuncSet((Nat \\ {0}), ((Nat \\ {0}) \\cup {BOT})))&((a_ihash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&((a_jhash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&((a_lhash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&((a_xhash_primea \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {BOT})))&((a_vhash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&(a_Mhash_primea \\in SUBSET(subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))))))))))))" (is "?z_hc")
 using v'198 by blast
 have z_He:"bAll(ProcSet, (\<lambda>p. (a_E2a(p)=>((a_pchash_primea \\in FuncSet(ProcSet, {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))&((a_Xhash_primea \\in (Nat \\ {0}))&((a_Qhash_primea \\in FuncSet((Nat \\ {0}), ((Nat \\ {0}) \\cup {BOT})))&((a_ihash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&((a_jhash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&((a_lhash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&((a_xhash_primea \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {BOT})))&((a_vhash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&(a_Mhash_primea \\in SUBSET(subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))))))))))))" (is "?z_he")
 using v'200 by blast
 have z_Hg:"bAll(ProcSet, (\<lambda>p. (a_D1a(p)=>((a_pchash_primea \\in FuncSet(ProcSet, {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))&((a_Xhash_primea \\in (Nat \\ {0}))&((a_Qhash_primea \\in FuncSet((Nat \\ {0}), ((Nat \\ {0}) \\cup {BOT})))&((a_ihash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&((a_jhash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&((a_lhash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&((a_xhash_primea \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {BOT})))&((a_vhash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&(a_Mhash_primea \\in SUBSET(subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))))))))))))" (is "?z_hg")
 using v'202 by blast
 have z_Hi:"bAll(ProcSet, (\<lambda>p. (a_D3a(p)=>((a_pchash_primea \\in FuncSet(ProcSet, {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))&((a_Xhash_primea \\in (Nat \\ {0}))&((a_Qhash_primea \\in FuncSet((Nat \\ {0}), ((Nat \\ {0}) \\cup {BOT})))&((a_ihash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&((a_jhash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&((a_lhash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&((a_xhash_primea \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {BOT})))&((a_vhash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&(a_Mhash_primea \\in SUBSET(subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))))))))))))" (is "?z_hi")
 using v'204 by blast
 have z_Hb:"(bEx(ProcSet, (\<lambda>p. (a_L0a(p)|(a_E1a(p)|(a_E2a(p)|(a_E3a(p)|(a_D1a(p)|(a_D2a(p)|(a_D3a(p)|a_D4a(p))))))))))|(a_h4fd5f73954dc53af536c1c75068837a=vars))" (is "?z_heg|?z_het")
 using v'185 by blast
 have z_Hk:"(?z_het=>((a_pchash_primea \\in FuncSet(ProcSet, {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))&((a_Xhash_primea \\in (Nat \\ {0}))&((a_Qhash_primea \\in FuncSet((Nat \\ {0}), ((Nat \\ {0}) \\cup {BOT})))&((a_ihash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&((a_jhash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&((a_lhash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&((a_xhash_primea \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {BOT})))&((a_vhash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&(a_Mhash_primea \\in SUBSET(subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))))))))))" (is "_=>?z_hr")
 using v'206 by blast
 have z_Hj:"bAll(ProcSet, (\<lambda>p. (a_D4a(p)=>?z_hr)))" (is "?z_hj")
 using v'205 by blast
 have z_Hh:"bAll(ProcSet, (\<lambda>p. (a_D2a(p)=>?z_hr)))" (is "?z_hh")
 using v'203 by blast
 have z_Hf:"bAll(ProcSet, (\<lambda>p. (a_E3a(p)=>?z_hr)))" (is "?z_hf")
 using v'201 by blast
 have z_Hd:"bAll(ProcSet, (\<lambda>p. (a_E1a(p)=>?z_hr)))" (is "?z_hd")
 using v'199 by blast
 assume z_Hl:"(~?z_hr)" (is "~(?z_hs&?z_hbe)")
 have z_Hfe_z_Hc: "(\\A x:((x \\in ProcSet)=>(a_L0a(x)=>?z_hr))) == ?z_hc" (is "?z_hfe == _")
 by (unfold bAll_def)
 have z_Hfe: "?z_hfe" (is "\\A x : ?z_hfk(x)")
 by (unfold z_Hfe_z_Hc, fact z_Hc)
 have z_Hfl_z_Hd: "(\\A x:((x \\in ProcSet)=>(a_E1a(x)=>?z_hr))) == ?z_hd" (is "?z_hfl == _")
 by (unfold bAll_def)
 have z_Hfl: "?z_hfl" (is "\\A x : ?z_hfp(x)")
 by (unfold z_Hfl_z_Hd, fact z_Hd)
 have z_Hfq_z_He: "(\\A x:((x \\in ProcSet)=>(a_E2a(x)=>?z_hr))) == ?z_he" (is "?z_hfq == _")
 by (unfold bAll_def)
 have z_Hfq: "?z_hfq" (is "\\A x : ?z_hfu(x)")
 by (unfold z_Hfq_z_He, fact z_He)
 have z_Hfv_z_Hf: "(\\A x:((x \\in ProcSet)=>(a_E3a(x)=>?z_hr))) == ?z_hf" (is "?z_hfv == _")
 by (unfold bAll_def)
 have z_Hfv: "?z_hfv" (is "\\A x : ?z_hfz(x)")
 by (unfold z_Hfv_z_Hf, fact z_Hf)
 have z_Hga_z_Hg: "(\\A x:((x \\in ProcSet)=>(a_D1a(x)=>?z_hr))) == ?z_hg" (is "?z_hga == _")
 by (unfold bAll_def)
 have z_Hga: "?z_hga" (is "\\A x : ?z_hge(x)")
 by (unfold z_Hga_z_Hg, fact z_Hg)
 have z_Hgf_z_Hh: "(\\A x:((x \\in ProcSet)=>(a_D2a(x)=>?z_hr))) == ?z_hh" (is "?z_hgf == _")
 by (unfold bAll_def)
 have z_Hgf: "?z_hgf" (is "\\A x : ?z_hgj(x)")
 by (unfold z_Hgf_z_Hh, fact z_Hh)
 have z_Hgk_z_Hi: "(\\A x:((x \\in ProcSet)=>(a_D3a(x)=>?z_hr))) == ?z_hi" (is "?z_hgk == _")
 by (unfold bAll_def)
 have z_Hgk: "?z_hgk" (is "\\A x : ?z_hgo(x)")
 by (unfold z_Hgk_z_Hi, fact z_Hi)
 have z_Hgp_z_Hj: "(\\A x:((x \\in ProcSet)=>(a_D4a(x)=>?z_hr))) == ?z_hj" (is "?z_hgp == _")
 by (unfold bAll_def)
 have z_Hgp: "?z_hgp" (is "\\A x : ?z_hgt(x)")
 by (unfold z_Hgp_z_Hj, fact z_Hj)
 show FALSE
 proof (rule zenon_or [OF z_Hb])
  assume z_Heg:"?z_heg"
  have z_Hgu_z_Heg: "(\\E x:((x \\in ProcSet)&(a_L0a(x)|(a_E1a(x)|(a_E2a(x)|(a_E3a(x)|(a_D1a(x)|(a_D2a(x)|(a_D3a(x)|a_D4a(x)))))))))) == ?z_heg" (is "?z_hgu == _")
  by (unfold bEx_def)
  have z_Hgu: "?z_hgu" (is "\\E x : ?z_hhd(x)")
  by (unfold z_Hgu_z_Heg, fact z_Heg)
  have z_Hhe: "?z_hhd((CHOOSE x:((x \\in ProcSet)&(a_L0a(x)|(a_E1a(x)|(a_E2a(x)|(a_E3a(x)|(a_D1a(x)|(a_D2a(x)|(a_D3a(x)|a_D4a(x)))))))))))" (is "?z_hhg&?z_hhh")
  by (rule zenon_ex_choose_0 [of "?z_hhd", OF z_Hgu])
  have z_Hhg: "?z_hhg"
  by (rule zenon_and_0 [OF z_Hhe])
  have z_Hhh: "?z_hhh" (is "?z_hhi|?z_hhj")
  by (rule zenon_and_1 [OF z_Hhe])
  show FALSE
  proof (rule zenon_or [OF z_Hhh])
   assume z_Hhi:"?z_hhi"
   have z_Hhk: "?z_hfk((CHOOSE x:((x \\in ProcSet)&(a_L0a(x)|(a_E1a(x)|(a_E2a(x)|(a_E3a(x)|(a_D1a(x)|(a_D2a(x)|(a_D3a(x)|a_D4a(x)))))))))))" (is "_=>?z_hhl")
   by (rule zenon_all_0 [of "?z_hfk" "(CHOOSE x:((x \\in ProcSet)&(a_L0a(x)|(a_E1a(x)|(a_E2a(x)|(a_E3a(x)|(a_D1a(x)|(a_D2a(x)|(a_D3a(x)|a_D4a(x))))))))))", OF z_Hfe])
   show FALSE
   proof (rule zenon_imply [OF z_Hhk])
    assume z_Hhm:"(~?z_hhg)"
    show FALSE
    by (rule notE [OF z_Hhm z_Hhg])
   next
    assume z_Hhl:"?z_hhl"
    show FALSE
    proof (rule zenon_imply [OF z_Hhl])
     assume z_Hhn:"(~?z_hhi)"
     show FALSE
     by (rule notE [OF z_Hhn z_Hhi])
    next
     assume z_Hr:"?z_hr"
     show FALSE
     by (rule notE [OF z_Hl z_Hr])
    qed
   qed
  next
   assume z_Hhj:"?z_hhj" (is "?z_hho|?z_hhp")
   show FALSE
   proof (rule zenon_or [OF z_Hhj])
    assume z_Hho:"?z_hho"
    have z_Hhq: "?z_hfp((CHOOSE x:((x \\in ProcSet)&(a_L0a(x)|(a_E1a(x)|(a_E2a(x)|(a_E3a(x)|(a_D1a(x)|(a_D2a(x)|(a_D3a(x)|a_D4a(x)))))))))))" (is "_=>?z_hhr")
    by (rule zenon_all_0 [of "?z_hfp" "(CHOOSE x:((x \\in ProcSet)&(a_L0a(x)|(a_E1a(x)|(a_E2a(x)|(a_E3a(x)|(a_D1a(x)|(a_D2a(x)|(a_D3a(x)|a_D4a(x))))))))))", OF z_Hfl])
    show FALSE
    proof (rule zenon_imply [OF z_Hhq])
     assume z_Hhm:"(~?z_hhg)"
     show FALSE
     by (rule notE [OF z_Hhm z_Hhg])
    next
     assume z_Hhr:"?z_hhr"
     show FALSE
     proof (rule zenon_imply [OF z_Hhr])
      assume z_Hhs:"(~?z_hho)"
      show FALSE
      by (rule notE [OF z_Hhs z_Hho])
     next
      assume z_Hr:"?z_hr"
      show FALSE
      by (rule notE [OF z_Hl z_Hr])
     qed
    qed
   next
    assume z_Hhp:"?z_hhp" (is "?z_hht|?z_hhu")
    show FALSE
    proof (rule zenon_or [OF z_Hhp])
     assume z_Hht:"?z_hht"
     have z_Hhv: "?z_hfu((CHOOSE x:((x \\in ProcSet)&(a_L0a(x)|(a_E1a(x)|(a_E2a(x)|(a_E3a(x)|(a_D1a(x)|(a_D2a(x)|(a_D3a(x)|a_D4a(x)))))))))))" (is "_=>?z_hhw")
     by (rule zenon_all_0 [of "?z_hfu" "(CHOOSE x:((x \\in ProcSet)&(a_L0a(x)|(a_E1a(x)|(a_E2a(x)|(a_E3a(x)|(a_D1a(x)|(a_D2a(x)|(a_D3a(x)|a_D4a(x))))))))))", OF z_Hfq])
     show FALSE
     proof (rule zenon_imply [OF z_Hhv])
      assume z_Hhm:"(~?z_hhg)"
      show FALSE
      by (rule notE [OF z_Hhm z_Hhg])
     next
      assume z_Hhw:"?z_hhw"
      show FALSE
      proof (rule zenon_imply [OF z_Hhw])
       assume z_Hhx:"(~?z_hht)"
       show FALSE
       by (rule notE [OF z_Hhx z_Hht])
      next
       assume z_Hr:"?z_hr"
       show FALSE
       by (rule notE [OF z_Hl z_Hr])
      qed
     qed
    next
     assume z_Hhu:"?z_hhu" (is "?z_hhy|?z_hhz")
     show FALSE
     proof (rule zenon_or [OF z_Hhu])
      assume z_Hhy:"?z_hhy"
      have z_Hia: "?z_hfz((CHOOSE x:((x \\in ProcSet)&(a_L0a(x)|(a_E1a(x)|(a_E2a(x)|(a_E3a(x)|(a_D1a(x)|(a_D2a(x)|(a_D3a(x)|a_D4a(x)))))))))))" (is "_=>?z_hib")
      by (rule zenon_all_0 [of "?z_hfz" "(CHOOSE x:((x \\in ProcSet)&(a_L0a(x)|(a_E1a(x)|(a_E2a(x)|(a_E3a(x)|(a_D1a(x)|(a_D2a(x)|(a_D3a(x)|a_D4a(x))))))))))", OF z_Hfv])
      show FALSE
      proof (rule zenon_imply [OF z_Hia])
       assume z_Hhm:"(~?z_hhg)"
       show FALSE
       by (rule notE [OF z_Hhm z_Hhg])
      next
       assume z_Hib:"?z_hib"
       show FALSE
       proof (rule zenon_imply [OF z_Hib])
        assume z_Hic:"(~?z_hhy)"
        show FALSE
        by (rule notE [OF z_Hic z_Hhy])
       next
        assume z_Hr:"?z_hr"
        show FALSE
        by (rule notE [OF z_Hl z_Hr])
       qed
      qed
     next
      assume z_Hhz:"?z_hhz" (is "?z_hid|?z_hie")
      show FALSE
      proof (rule zenon_or [OF z_Hhz])
       assume z_Hid:"?z_hid"
       have z_Hif: "?z_hge((CHOOSE x:((x \\in ProcSet)&(a_L0a(x)|(a_E1a(x)|(a_E2a(x)|(a_E3a(x)|(a_D1a(x)|(a_D2a(x)|(a_D3a(x)|a_D4a(x)))))))))))" (is "_=>?z_hig")
       by (rule zenon_all_0 [of "?z_hge" "(CHOOSE x:((x \\in ProcSet)&(a_L0a(x)|(a_E1a(x)|(a_E2a(x)|(a_E3a(x)|(a_D1a(x)|(a_D2a(x)|(a_D3a(x)|a_D4a(x))))))))))", OF z_Hga])
       show FALSE
       proof (rule zenon_imply [OF z_Hif])
        assume z_Hhm:"(~?z_hhg)"
        show FALSE
        by (rule notE [OF z_Hhm z_Hhg])
       next
        assume z_Hig:"?z_hig"
        show FALSE
        proof (rule zenon_imply [OF z_Hig])
         assume z_Hih:"(~?z_hid)"
         show FALSE
         by (rule notE [OF z_Hih z_Hid])
        next
         assume z_Hr:"?z_hr"
         show FALSE
         by (rule notE [OF z_Hl z_Hr])
        qed
       qed
      next
       assume z_Hie:"?z_hie" (is "?z_hii|?z_hij")
       show FALSE
       proof (rule zenon_or [OF z_Hie])
        assume z_Hii:"?z_hii"
        have z_Hik: "?z_hgj((CHOOSE x:((x \\in ProcSet)&(a_L0a(x)|(a_E1a(x)|(a_E2a(x)|(a_E3a(x)|(a_D1a(x)|(a_D2a(x)|(a_D3a(x)|a_D4a(x)))))))))))" (is "_=>?z_hil")
        by (rule zenon_all_0 [of "?z_hgj" "(CHOOSE x:((x \\in ProcSet)&(a_L0a(x)|(a_E1a(x)|(a_E2a(x)|(a_E3a(x)|(a_D1a(x)|(a_D2a(x)|(a_D3a(x)|a_D4a(x))))))))))", OF z_Hgf])
        show FALSE
        proof (rule zenon_imply [OF z_Hik])
         assume z_Hhm:"(~?z_hhg)"
         show FALSE
         by (rule notE [OF z_Hhm z_Hhg])
        next
         assume z_Hil:"?z_hil"
         show FALSE
         proof (rule zenon_imply [OF z_Hil])
          assume z_Him:"(~?z_hii)"
          show FALSE
          by (rule notE [OF z_Him z_Hii])
         next
          assume z_Hr:"?z_hr"
          show FALSE
          by (rule notE [OF z_Hl z_Hr])
         qed
        qed
       next
        assume z_Hij:"?z_hij" (is "?z_hin|?z_hio")
        show FALSE
        proof (rule zenon_or [OF z_Hij])
         assume z_Hin:"?z_hin"
         have z_Hip: "?z_hgo((CHOOSE x:((x \\in ProcSet)&(a_L0a(x)|(a_E1a(x)|(a_E2a(x)|(a_E3a(x)|(a_D1a(x)|(a_D2a(x)|(a_D3a(x)|a_D4a(x)))))))))))" (is "_=>?z_hiq")
         by (rule zenon_all_0 [of "?z_hgo" "(CHOOSE x:((x \\in ProcSet)&(a_L0a(x)|(a_E1a(x)|(a_E2a(x)|(a_E3a(x)|(a_D1a(x)|(a_D2a(x)|(a_D3a(x)|a_D4a(x))))))))))", OF z_Hgk])
         show FALSE
         proof (rule zenon_imply [OF z_Hip])
          assume z_Hhm:"(~?z_hhg)"
          show FALSE
          by (rule notE [OF z_Hhm z_Hhg])
         next
          assume z_Hiq:"?z_hiq"
          show FALSE
          proof (rule zenon_imply [OF z_Hiq])
           assume z_Hir:"(~?z_hin)"
           show FALSE
           by (rule notE [OF z_Hir z_Hin])
          next
           assume z_Hr:"?z_hr"
           show FALSE
           by (rule notE [OF z_Hl z_Hr])
          qed
         qed
        next
         assume z_Hio:"?z_hio"
         have z_His: "?z_hgt((CHOOSE x:((x \\in ProcSet)&(a_L0a(x)|(a_E1a(x)|(a_E2a(x)|(a_E3a(x)|(a_D1a(x)|(a_D2a(x)|(a_D3a(x)|a_D4a(x)))))))))))" (is "_=>?z_hit")
         by (rule zenon_all_0 [of "?z_hgt" "(CHOOSE x:((x \\in ProcSet)&(a_L0a(x)|(a_E1a(x)|(a_E2a(x)|(a_E3a(x)|(a_D1a(x)|(a_D2a(x)|(a_D3a(x)|a_D4a(x))))))))))", OF z_Hgp])
         show FALSE
         proof (rule zenon_imply [OF z_His])
          assume z_Hhm:"(~?z_hhg)"
          show FALSE
          by (rule notE [OF z_Hhm z_Hhg])
         next
          assume z_Hit:"?z_hit"
          show FALSE
          proof (rule zenon_imply [OF z_Hit])
           assume z_Hiu:"(~?z_hio)"
           show FALSE
           by (rule notE [OF z_Hiu z_Hio])
          next
           assume z_Hr:"?z_hr"
           show FALSE
           by (rule notE [OF z_Hl z_Hr])
          qed
         qed
        qed
       qed
      qed
     qed
    qed
   qed
  qed
 next
  assume z_Het:"?z_het"
  show FALSE
  proof (rule zenon_imply [OF z_Hk])
   assume z_Hiv:"(a_h4fd5f73954dc53af536c1c75068837a~=vars)"
   show FALSE
   by (rule notE [OF z_Hiv z_Het])
  next
   assume z_Hr:"?z_hr"
   show FALSE
   by (rule notE [OF z_Hl z_Hr])
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 21"; *} qed
lemma ob'18:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
assumes v'185: "((((i) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((j) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((l) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((x) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((v) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))))"
assumes v'186: "(((pc) = ([ p \<in> (ProcSet)  \<mapsto> (''L0'')])))"
assumes v'187: "(((X) = ((Succ[0]))))"
assumes v'188: "(((Q) = ([ a_indexa \<in> (((Nat) \\ ({((0))})))  \<mapsto> (BOT)])))"
assumes v'189: "(((M) = ({(((''sigma'' :> (<<>>)) @@ (''fres'' :> ([ p \<in> (ProcSet)  \<mapsto> (BOT)]))))})))"
assumes v'197: "(((fapply ((((''sigma'' :> (<<>>)) @@ (''fres'' :> ([ p \<in> (ProcSet)  \<mapsto> (BOT)])))), (''sigma''))) \<in> ([((isa_peri_peri_a (((Succ[0])), ((0))))) \<rightarrow> (((Nat) \\ ({((0))})))])))"
shows "(((fapply ((((''sigma'' :> (<<>>)) @@ (''fres'' :> ([ p \<in> (ProcSet)  \<mapsto> (BOT)])))), (''sigma''))) \<in> ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))])))))))"(is "PROP ?ob'18")
proof -
ML_command {* writeln "*** TLAPS ENTER 18"; *}
show "PROP ?ob'18"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_90507a.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_90507a.znn.out
;; obligation #18
$hyp "v'185" (/\ (TLA.in i (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in j (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in l (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in x (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0)) (TLA.set BOT)))) (TLA.in v
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))))
$hyp "v'186" (= pc (TLA.Fcn ProcSet ((p) "L0")))
$hyp "v'187" (= X (TLA.fapply TLA.Succ 0))
$hyp "v'188" (= Q (TLA.Fcn (TLA.setminus arith.N
(TLA.set 0)) ((a_indexa) BOT)))
$hyp "v'189" (= M
(TLA.set (TLA.record "sigma" (TLA.tuple ) "fres" (TLA.Fcn ProcSet ((p) BOT)))))
$hyp "v'197" (TLA.in (TLA.fapply (TLA.record "sigma" (TLA.tuple ) "fres" (TLA.Fcn ProcSet ((p) BOT))) "sigma")
(TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0) 0) (TLA.setminus arith.N
(TLA.set 0))))
$goal (TLA.in (TLA.fapply (TLA.record "sigma" (TLA.tuple ) "fres" (TLA.Fcn ProcSet ((p) BOT))) "sigma")
(TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hf:"(((''sigma'' :> (<<>>) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>a_indexa. BOT))))[''sigma'']) \\in FuncSet(isa'dotdot(1, 0), (Nat \\ {0})))" (is "?z_hf")
 using v'197 by blast
 assume z_Hg:"(~(((''sigma'' :> (<<>>) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>a_indexa. BOT))))[''sigma'']) \\in UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))))" (is "~?z_hx")
 have z_Hbe: "(~(\\E zenon_Vh:((zenon_Vh \\in setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))&(((''sigma'' :> (<<>>) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>a_indexa. BOT))))[''sigma'']) \\in zenon_Vh))))" (is "~(\\E x : ?z_hbk(x))")
 by (rule zenon_notin_UNION_0 [of "((''sigma'' :> (<<>>) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>a_indexa. BOT))))[''sigma''])" "setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0}))))", OF z_Hg])
 have z_Hbl: "~?z_hbk(FuncSet(isa'dotdot(1, 0), (Nat \\ {0})))" (is "~(?z_hbm&_)")
 by (rule zenon_notex_0 [of "?z_hbk" "FuncSet(isa'dotdot(1, 0), (Nat \\ {0}))", OF z_Hbe])
 show FALSE
 proof (rule zenon_notand [OF z_Hbl])
  assume z_Hbn:"(~?z_hbm)"
  have z_Hbo: "(~(\\E zenon_Voc:((zenon_Voc \\in Nat)&(FuncSet(isa'dotdot(1, 0), (Nat \\ {0}))=FuncSet(isa'dotdot(1, zenon_Voc), (Nat \\ {0}))))))" (is "~(\\E x : ?z_hbw(x))")
  by (rule zenon_notin_setofall_0 [of "FuncSet(isa'dotdot(1, 0), (Nat \\ {0}))" "Nat" "(\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))", OF z_Hbn])
  have z_Hbx: "~?z_hbw(0)" (is "~(?z_hby&?z_hbz)")
  by (rule zenon_notex_0 [of "?z_hbw" "0", OF z_Hbo])
  show FALSE
  proof (rule zenon_notand [OF z_Hbx])
   assume z_Hca:"(~?z_hby)"
   show FALSE
   by (rule zenon_in_nat_0 [of , OF z_Hca])
  next
   assume z_Hcb:"(FuncSet(isa'dotdot(1, 0), (Nat \\ {0}))~=FuncSet(isa'dotdot(1, 0), (Nat \\ {0})))" (is "?z_hq~=_")
   show FALSE
   by (rule zenon_noteq [OF z_Hcb])
  qed
 next
  assume z_Hcc:"(~?z_hf)"
  show FALSE
  by (rule notE [OF z_Hcc z_Hf])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 18"; *} qed
lemma ob'9:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition PosInts suppressed *)
assumes v'173: "(\<forall>S : (((((((S) \<in> ((SUBSET (Int))))) \<and> ((IsFiniteSet ((S)))))) \<Rightarrow> (\<exists> f \<in> ((Bijection (((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))), (S)))) : (\<forall> m \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))) : (\<forall> n \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))) : ((((less ((m), (n)))) \<Rightarrow> ((less ((fapply ((f), (m))), (fapply ((f), (n))))))))))))))"
shows "(\<forall>S : (((((((S) \<in> ((SUBSET (Int))))) \<and> ((IsFiniteSet ((S)))))) \<Rightarrow> (\<exists> f \<in> ((Bijection (((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))), (S)))) : (\<forall> m \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))) : (\<forall> n \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))) : ((((less ((m), (n)))) \<Rightarrow> ((less ((fapply ((f), (m))), (fapply ((f), (n))))))))))))))"(is "PROP ?ob'9")
proof -
ML_command {* writeln "*** TLAPS ENTER 9"; *}
show "PROP ?ob'9"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_434245.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_434245.znn.out
;; obligation #9
$hyp "v'173" (A. ((S) (=> (/\ (TLA.in S (TLA.SUBSET arith.Z))
(IsFiniteSet S)) (TLA.bEx (Bijection (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality S)) S) ((f) (TLA.bAll (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality S)) ((m) (TLA.bAll (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality S)) ((n) (=> (arith.lt m n) (arith.lt (TLA.fapply f m)
(TLA.fapply f n))))))))))))
$goal (A. ((S) (=> (/\ (TLA.in S (TLA.SUBSET arith.Z)) (IsFiniteSet S))
(TLA.bEx (Bijection (arith.intrange (TLA.fapply TLA.Succ 0) (Cardinality S))
S) ((f) (TLA.bAll (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality S)) ((m) (TLA.bAll (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality S)) ((n) (=> (arith.lt m n) (arith.lt (TLA.fapply f m)
(TLA.fapply f n))))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Ha:"(\\A S:(((S \\in SUBSET(Int))&IsFiniteSet(S))=>bEx(Bijection(isa'dotdot(1, Cardinality(S)), S), (\<lambda>f. bAll(isa'dotdot(1, Cardinality(S)), (\<lambda>m. bAll(isa'dotdot(1, Cardinality(S)), (\<lambda>n. ((m < n)=>((f[m]) < (f[n])))))))))))" (is "\\A x : ?z_hbb(x)")
 using v'173 by blast
 assume z_Hb:"(~(\\A S:(((S \\in SUBSET(Int))&IsFiniteSet(S))=>bEx(Bijection(isa'dotdot(1, Cardinality(S)), S), (\<lambda>f. bAll(isa'dotdot(1, Cardinality(S)), (\<lambda>m. bAll(isa'dotdot(1, Cardinality(S)), (\<lambda>n. ((m < n)=>((f[m]) < (f[n]))))))))))))"
 show FALSE
 by (rule notE [OF z_Hb z_Ha])
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 9"; *} qed
lemma ob'6:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition PosInts suppressed *)
assumes v'172: "(\<forall>S : (((((((((S) \<in> ((SUBSET (Int))))) \<and> (((S) \<noteq> ({}))))) \<and> ((IsFiniteSet ((S)))))) \<Rightarrow> (\<exists> s \<in> (S) : (\<forall> y \<in> (S) : ((leq ((y), (s)))))))))"
shows "(\<forall>S : (((((((((S) \<in> ((SUBSET (Int))))) \<and> (((S) \<noteq> ({}))))) \<and> ((IsFiniteSet ((S)))))) \<Rightarrow> (\<exists> s \<in> (S) : (\<forall> y \<in> (S) : ((leq ((y), (s)))))))))"(is "PROP ?ob'6")
proof -
ML_command {* writeln "*** TLAPS ENTER 6"; *}
show "PROP ?ob'6"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_c036b4.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_c036b4.znn.out
;; obligation #6
$hyp "v'172" (A. ((S) (=> (/\ (/\ (TLA.in S (TLA.SUBSET arith.Z)) (-. (= S
TLA.emptyset))) (IsFiniteSet S)) (TLA.bEx S ((s) (TLA.bAll S ((y) (arith.le y
s))))))))
$goal (A. ((S) (=> (/\ (/\ (TLA.in S (TLA.SUBSET arith.Z)) (-. (= S
TLA.emptyset))) (IsFiniteSet S)) (TLA.bEx S ((s) (TLA.bAll S ((y) (arith.le y
s))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Ha:"(\\A S:((((S \\in SUBSET(Int))&(S~={}))&IsFiniteSet(S))=>bEx(S, (\<lambda>s. bAll(S, (\<lambda>y. (y <= s)))))))" (is "\\A x : ?z_ht(x)")
 using v'172 by blast
 assume z_Hb:"(~(\\A S:((((S \\in SUBSET(Int))&(S~={}))&IsFiniteSet(S))=>bEx(S, (\<lambda>s. bAll(S, (\<lambda>y. (y <= s))))))))"
 show FALSE
 by (rule notE [OF z_Hb z_Ha])
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 6"; *} qed
lemma ob'45:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
assumes v'184: "((((pc) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & (((X) \<in> (((Nat) \\ ({((0))}))))) & (((Q) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((i) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((j) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((l) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((x) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((v) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((M) \<in> ((SUBSET (subsetOf(([''sigma'' : ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))]))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %a_ca. (\<forall> p \<in> (ProcSet) : ((((((fapply ((pc), (p))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p))) = (BOT))))) & (((((fapply ((pc), (p))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p))) \<in> ({(ACK), (BOT)}))))) & (((((fapply ((pc), (p))) \<in> ({(''D4'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)}))))))))))))))))"
assumes v'185: "(((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'198: "(cond((((fapply ((Q), (fapply ((j), (p))))) = (BOT))), (cond((((fapply ((j), (p))) = ((arith_add ((fapply ((l), (p))), ((minus (((Succ[0])))))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & (((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (M))))), (((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((arith_add ((fapply ((j), (p))), ((Succ[0])))))]))) & (((((a_pchash_primea :: c)) = (pc))) & ((((a_Mhash_primea :: c)) = (M))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D4'')]))) & ((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (subsetOf(([''sigma'' : ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))]))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %d. ((\<forall> p_1 \<in> (ProcSet) : ((((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (p_1))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (p_1))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''D4'')}))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (p_1))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)}))))))))) & (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((d), (''fres''))), (p))) = ((Head ((fapply ((a_ca), (''sigma'')))))))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = ((Tail ((fapply ((a_ca), (''sigma''))))))))))))))))))"
assumes v'199: "(((fapply ((pc), (p))) = (''D3'')))"
assumes v'200: "((((a_xhash_primea :: c)) = ([(x) EXCEPT ![(p)] = (fapply ((Q), (fapply ((j), (p)))))])))"
assumes v'201: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((j), (p)))] = (BOT)])))"
assumes v'202: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'203: "((((a_ihash_primea :: c)) = (i)))"
assumes v'204: "((((a_lhash_primea :: c)) = (l)))"
assumes v'205: "((((a_vhash_primea :: c)) = (v)))"
assumes v'210: "((((a_pchash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})])))"
assumes v'211: "((((a_jhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))])))"
assumes v'212: "((((a_Mhash_primea :: c)) \<in> ((SUBSET (subsetOf(([''sigma'' : ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))]))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %a_ca. (\<forall> p_1 \<in> (ProcSet) : ((((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''D4'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))))))))))))))"
shows "(((((a_pchash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & ((((a_Xhash_primea :: c)) \<in> (((Nat) \\ ({((0))}))))) & ((((a_Qhash_primea :: c)) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & ((((a_ihash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_jhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_lhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_xhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & ((((a_vhash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & ((((a_Mhash_primea :: c)) \<in> ((SUBSET (subsetOf(([''sigma'' : ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))]))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %a_ca. (\<forall> p_1 \<in> (ProcSet) : ((((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''D4'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)}))))))))))))))))"(is "PROP ?ob'45")
proof -
ML_command {* writeln "*** TLAPS ENTER 45"; *}
show "PROP ?ob'45"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_cce6c5.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_cce6c5.znn.out
;; obligation #45
$hyp "v'184" (/\ (TLA.in pc
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in X (TLA.setminus arith.N (TLA.set 0))) (TLA.in Q
(TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in i (TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in j
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in l
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in x
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in v (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in M
(TLA.SUBSET (TLA.subsetOf (TLA.recordset "sigma" (TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))) ((a_ca) (TLA.bAll ProcSet ((p) (/\ (=> (TLA.in (TLA.fapply pc p)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply a_ca "fres") p) BOT))
(=> (TLA.in (TLA.fapply pc p) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p) (TLA.set ACK BOT)))
(=> (TLA.in (TLA.fapply pc p) (TLA.set "D4"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT))))))))))))
$hyp "v'185" (\/ Next (= a_h4fd5f73954dc53af536c1c75068837a
vars))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'198" (TLA.cond (= (TLA.fapply Q (TLA.fapply j p))
BOT) (TLA.cond (= (TLA.fapply j p) (arith.add (TLA.fapply l p)
(arith.minus (TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea
(TLA.except pc p "D1")) (/\ (= a_jhash_primea j) (= a_Mhash_primea
M))) (/\ (= a_jhash_primea (TLA.except j p (arith.add (TLA.fapply j p)
(TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea pc) (= a_Mhash_primea
M)))) (/\ (= a_pchash_primea (TLA.except pc p "D4")) (= a_jhash_primea j)
(= a_Mhash_primea
(TLA.subsetOf (TLA.recordset "sigma" (TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))) ((d) (/\ (TLA.bAll ProcSet ((p_1) (/\ (=> (TLA.in (TLA.fapply a_pchash_primea p_1)
(TLA.set "L0" "E1" "D1" "D2" "D3")) (= (TLA.fapply (TLA.fapply d "fres") p_1)
BOT)) (=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply d "fres") p_1) (TLA.set ACK BOT)))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "D4"))
(TLA.in (TLA.fapply (TLA.fapply d "fres") p_1) (TLA.cup (TLA.setminus arith.N
(TLA.set 0)) (TLA.set BOT)))))))
(TLA.bEx M ((a_ca) (/\ (= (TLA.fapply (TLA.fapply d "fres") p)
(Head (TLA.fapply a_ca "sigma"))) (TLA.bAll ProcSet ((q) (=> (-. (= q p))
(= (TLA.fapply (TLA.fapply d "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))) (= (TLA.fapply d "sigma")
(Tail (TLA.fapply a_ca "sigma"))))))))))))
$hyp "v'199" (= (TLA.fapply pc p) "D3")
$hyp "v'200" (= a_xhash_primea
(TLA.except x p (TLA.fapply Q (TLA.fapply j p))))
$hyp "v'201" (= a_Qhash_primea
(TLA.except Q (TLA.fapply j p) BOT))
$hyp "v'202" (= a_Xhash_primea X)
$hyp "v'203" (= a_ihash_primea i)
$hyp "v'204" (= a_lhash_primea l)
$hyp "v'205" (= a_vhash_primea v)
$hyp "v'210" (TLA.in a_pchash_primea
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
$hyp "v'211" (TLA.in a_jhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0))))
$hyp "v'212" (TLA.in a_Mhash_primea
(TLA.SUBSET (TLA.subsetOf (TLA.recordset "sigma" (TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))) ((a_ca) (TLA.bAll ProcSet ((p_1) (/\ (=> (TLA.in (TLA.fapply a_pchash_primea p_1)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply a_ca "fres") p_1) BOT))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p_1) (TLA.set ACK BOT)))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "D4"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p_1)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))))))))))
$goal (/\ (TLA.in a_pchash_primea
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in a_Xhash_primea (TLA.setminus arith.N (TLA.set 0)))
(TLA.in a_Qhash_primea (TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in a_ihash_primea (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in a_jhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0))))
(TLA.in a_lhash_primea (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in a_xhash_primea
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in a_vhash_primea
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0))))
(TLA.in a_Mhash_primea
(TLA.SUBSET (TLA.subsetOf (TLA.recordset "sigma" (TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))) ((a_ca) (TLA.bAll ProcSet ((p_1) (/\ (=> (TLA.in (TLA.fapply a_pchash_primea p_1)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply a_ca "fres") p_1) BOT))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p_1) (TLA.set ACK BOT)))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "D4"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p_1)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT))))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Ha:"((pc \\in FuncSet(ProcSet, {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))&((X \\in (Nat \\ {0}))&((Q \\in FuncSet((Nat \\ {0}), ((Nat \\ {0}) \\cup {BOT})))&((i \\in FuncSet(ProcSet, (Nat \\ {0})))&((j \\in FuncSet(ProcSet, (Nat \\ {0})))&((l \\in FuncSet(ProcSet, (Nat \\ {0})))&((x \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {BOT})))&((v \\in FuncSet(ProcSet, (Nat \\ {0})))&(M \\in SUBSET(subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((a_ca[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>(((a_ca[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))))))))" (is "?z_hp&?z_hbc")
 using v'184 by blast
 have z_Hk:"(a_vhash_primea=v)"
 using v'205 by blast
 have z_Hf:"(a_xhash_primea=except(x, p, (Q[(j[p])])))" (is "_=?z_hdx")
 using v'200 by blast
 have z_Hj:"(a_lhash_primea=l)"
 using v'204 by blast
 have z_Hi:"(a_ihash_primea=i)"
 using v'203 by blast
 have z_Hg:"(a_Qhash_primea=except(Q, (j[p]), BOT))" (is "_=?z_hed")
 using v'201 by blast
 have z_Hh:"(a_Xhash_primea=X)"
 using v'202 by blast
 have z_Hn:"(a_Mhash_primea \\in SUBSET(subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))" (is "?z_hn")
 using v'212 by blast
 have z_Hd:"cond(((Q[(j[p])])=BOT), cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M)))), ((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma'']))))))))))))))" (is "?z_hd")
 using v'198 by blast
 have z_Hm:"(a_jhash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))" (is "?z_hm")
 using v'211 by blast
 have z_Hl:"(a_pchash_primea \\in FuncSet(ProcSet, {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))" (is "?z_hl")
 using v'210 by blast
 have zenon_L1_: "(~isAFcn(?z_hdx)) ==> FALSE" (is "?z_hhh ==> FALSE")
 proof -
  assume z_Hhh:"?z_hhh" (is "~?z_hhi")
  show FALSE
  by (rule zenon_notisafcn_except [of "x" "p" "(Q[(j[p])])", OF z_Hhh])
 qed
 have zenon_L2_: "(DOMAIN(?z_hdx)~=ProcSet) ==> (DOMAIN(x)=ProcSet) ==> FALSE" (is "?z_hhj ==> ?z_hhl ==> FALSE")
 proof -
  assume z_Hhj:"?z_hhj" (is "?z_hhk~=_")
  assume z_Hhl:"?z_hhl" (is "?z_hhm=_")
  have z_Hhn: "(?z_hhm~=ProcSet)"
  by (rule zenon_domain_except_0 [of "(\<lambda>zenon_Vgac. (zenon_Vgac~=ProcSet))" "x" "p" "(Q[(j[p])])", OF z_Hhj])
  show FALSE
  by (rule notE [OF z_Hhn z_Hhl])
 qed
 have zenon_L3_: "(~((j[p]) \\in Nat)) ==> ((a_jhash_primea[(CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT})))))]) \\in Nat) ==> (a_jhash_primea=j) ==> (p=(CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT})))))) ==> FALSE" (is "?z_hhr ==> ?z_hht ==> ?z_hfk ==> ?z_hic ==> FALSE")
 proof -
  assume z_Hhr:"?z_hhr" (is "~?z_hhs")
  assume z_Hht:"?z_hht"
  assume z_Hfk:"?z_hfk"
  assume z_Hic:"?z_hic" (is "_=?z_hhv")
  show FALSE
  proof (rule notE [OF z_Hhr])
   have z_Hid: "((a_jhash_primea[?z_hhv])=(j[p]))" (is "?z_hhu=?z_hdz")
   proof (rule zenon_nnpp [of "(?z_hhu=?z_hdz)"])
    assume z_Hie:"(?z_hhu~=?z_hdz)"
    show FALSE
    proof (rule zenon_noteq [of "?z_hdz"])
     have z_Hif: "(?z_hhv=p)"
     by (rule sym [OF z_Hic])
     have z_Hig: "((j[?z_hhv])~=?z_hdz)" (is "?z_hih~=_")
     by (rule subst [where P="(\<lambda>zenon_Vvhd. ((zenon_Vvhd[?z_hhv])~=?z_hdz))", OF z_Hfk], fact z_Hie)
     have z_Him: "(?z_hdz~=?z_hdz)"
     by (rule subst [where P="(\<lambda>zenon_Vwhd. ((j[zenon_Vwhd])~=?z_hdz))", OF z_Hif], fact z_Hig)
     thus "(?z_hdz~=?z_hdz)" .
    qed
   qed
   have z_Hhs: "?z_hhs"
   by (rule subst [where P="(\<lambda>zenon_Vxhd. (zenon_Vxhd \\in Nat))", OF z_Hid], fact z_Hht)
   thus "?z_hhs" .
  qed
 qed
 have zenon_L4_: "?z_hm ==> (Q \\in FuncSet((Nat \\ {0}), ((Nat \\ {0}) \\cup {BOT}))) ==> (~((Q[(j[p])]) \\in ((Nat \\ {0}) \\cup {BOT}))) ==> (a_jhash_primea=j) ==> (p=(CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT})))))) ==> ((CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT}))))) \\in ProcSet) ==> FALSE" (is "_ ==> ?z_hbk ==> ?z_hiu ==> ?z_hfk ==> ?z_hic ==> ?z_hiw ==> FALSE")
 proof -
  assume z_Hm:"?z_hm"
  assume z_Hbk:"?z_hbk"
  assume z_Hiu:"?z_hiu" (is "~?z_hiv")
  assume z_Hfk:"?z_hfk"
  assume z_Hic:"?z_hic" (is "_=?z_hhv")
  assume z_Hiw:"?z_hiw"
  have z_Hix: "(\\A zenon_Vk:((zenon_Vk \\in ProcSet)=>((a_jhash_primea[zenon_Vk]) \\in (Nat \\ {0}))))" (is "\\A x : ?z_hjd(x)")
  by (rule zenon_in_funcset_2 [of "a_jhash_primea" "ProcSet" "(Nat \\ {0})", OF z_Hm])
  have z_Hje: "?z_hjd(?z_hhv)" (is "_=>?z_hjf")
  by (rule zenon_all_0 [of "?z_hjd" "?z_hhv", OF z_Hix])
  show FALSE
  proof (rule zenon_imply [OF z_Hje])
   assume z_Hjg:"(~?z_hiw)"
   show FALSE
   by (rule notE [OF z_Hjg z_Hiw])
  next
   assume z_Hjf:"?z_hjf"
   have z_Hht: "((a_jhash_primea[?z_hhv]) \\in Nat)" (is "?z_hht")
   by (rule zenon_in_setminus_0 [of "(a_jhash_primea[?z_hhv])" "Nat" "{0}", OF z_Hjf])
   have z_Hjh: "(~((a_jhash_primea[?z_hhv]) \\in {0}))" (is "~?z_hji")
   by (rule zenon_in_setminus_1 [of "(a_jhash_primea[?z_hhv])" "Nat" "{0}", OF z_Hjf])
   have z_Hjj: "(\\A zenon_Vna:((zenon_Vna \\in (Nat \\ {0}))=>((Q[zenon_Vna]) \\in ((Nat \\ {0}) \\cup {BOT}))))" (is "\\A x : ?z_hjp(x)")
   by (rule zenon_in_funcset_2 [of "Q" "(Nat \\ {0})" "((Nat \\ {0}) \\cup {BOT})", OF z_Hbk])
   have z_Hjq: "?z_hjp((j[p]))" (is "?z_hjr=>_")
   by (rule zenon_all_0 [of "?z_hjp" "(j[p])", OF z_Hjj])
   show FALSE
   proof (rule zenon_imply [OF z_Hjq])
    assume z_Hjs:"(~?z_hjr)"
    show FALSE
    proof (rule zenon_notin_setminus [of "(j[p])" "Nat" "{0}", OF z_Hjs])
     assume z_Hhr:"(~((j[p]) \\in Nat))" (is "~?z_hhs")
     show FALSE
     by (rule zenon_L3_ [OF z_Hhr z_Hht z_Hfk z_Hic])
    next
     assume z_Hjt:"((j[p]) \\in {0})" (is "?z_hjt")
     show FALSE
     proof (rule notE [OF z_Hjh])
      have z_Hju: "((j[p])=(a_jhash_primea[?z_hhv]))" (is "?z_hdz=?z_hhu")
      proof (rule zenon_nnpp [of "(?z_hdz=?z_hhu)"])
       assume z_Hjv:"(?z_hdz~=?z_hhu)"
       show FALSE
       proof (rule zenon_noteq [of "?z_hhu"])
        have z_Hjw: "(j=a_jhash_primea)"
        by (rule sym [OF z_Hfk])
        have z_Hjx: "((a_jhash_primea[p])~=?z_hhu)" (is "?z_hjy~=_")
        by (rule subst [where P="(\<lambda>zenon_Vyhd. ((zenon_Vyhd[p])~=?z_hhu))", OF z_Hjw], fact z_Hjv)
        have z_Hkd: "(?z_hhu~=?z_hhu)"
        by (rule subst [where P="(\<lambda>zenon_Vzhd. ((a_jhash_primea[zenon_Vzhd])~=?z_hhu))", OF z_Hic], fact z_Hjx)
        thus "(?z_hhu~=?z_hhu)" .
       qed
      qed
      have z_Hji: "?z_hji"
      by (rule subst [where P="(\<lambda>zenon_Vhb. (zenon_Vhb \\in {0}))", OF z_Hju], fact z_Hjt)
      thus "?z_hji" .
     qed
    qed
   next
    assume z_Hiv:"?z_hiv"
    show FALSE
    by (rule notE [OF z_Hiu z_Hiv])
   qed
  qed
 qed
 have zenon_L5_: "(~((?z_hdx[(CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT})))))]) \\in ((Nat \\ {0}) \\cup {BOT}))) ==> ((CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT}))))) \\in DOMAIN(x)) ==> ((CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT}))))) \\in ProcSet) ==> (x \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {BOT}))) ==> (p~=(CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT})))))) ==> FALSE" (is "?z_hkl ==> ?z_hko ==> ?z_hiw ==> ?z_hcb ==> ?z_hkp ==> FALSE")
 proof -
  assume z_Hkl:"?z_hkl" (is "~?z_hkm")
  assume z_Hko:"?z_hko"
  assume z_Hiw:"?z_hiw"
  assume z_Hcb:"?z_hcb"
  assume z_Hkp:"?z_hkp" (is "_~=?z_hhv")
  show FALSE
  proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vif. (~(zenon_Vif \\in ((Nat \\ {0}) \\cup {BOT}))))" "x" "p" "(Q[(j[p])])" "?z_hhv", OF z_Hkl])
   assume z_Hko:"?z_hko"
   assume z_Hic:"(p=?z_hhv)"
   assume z_Hiu:"(~((Q[(j[p])]) \\in ((Nat \\ {0}) \\cup {BOT})))" (is "~?z_hiv")
   show FALSE
   by (rule notE [OF z_Hkp z_Hic])
  next
   assume z_Hko:"?z_hko"
   assume z_Hkp:"?z_hkp"
   assume z_Hku:"(~((x[?z_hhv]) \\in ((Nat \\ {0}) \\cup {BOT})))" (is "~?z_hkv")
   have z_Hkx: "(\\A zenon_Vba:((zenon_Vba \\in ProcSet)=>((x[zenon_Vba]) \\in ((Nat \\ {0}) \\cup {BOT}))))" (is "\\A x : ?z_hld(x)")
   by (rule zenon_in_funcset_2 [of "x" "ProcSet" "((Nat \\ {0}) \\cup {BOT})", OF z_Hcb])
   have z_Hle: "?z_hld(?z_hhv)"
   by (rule zenon_all_0 [of "?z_hld" "?z_hhv", OF z_Hkx])
   show FALSE
   proof (rule zenon_imply [OF z_Hle])
    assume z_Hjg:"(~?z_hiw)"
    show FALSE
    by (rule notE [OF z_Hjg z_Hiw])
   next
    assume z_Hkv:"?z_hkv"
    show FALSE
    by (rule notE [OF z_Hku z_Hkv])
   qed
  next
   assume z_Hlf:"(~?z_hko)"
   show FALSE
   by (rule notE [OF z_Hlf z_Hko])
  qed
 qed
 assume z_Ho:"(~(?z_hl&((a_Xhash_primea \\in (Nat \\ {0}))&((a_Qhash_primea \\in FuncSet((Nat \\ {0}), ((Nat \\ {0}) \\cup {BOT})))&((a_ihash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&(?z_hm&((a_lhash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&((a_xhash_primea \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {BOT})))&((a_vhash_primea \\in FuncSet(ProcSet, (Nat \\ {0})))&?z_hn)))))))))" (is "~(_&?z_hlh)")
 have z_Hbc: "?z_hbc" (is "?z_hbd&?z_hbj")
 by (rule zenon_and_1 [OF z_Ha])
 have z_Hbd: "?z_hbd"
 by (rule zenon_and_0 [OF z_Hbc])
 have z_Hbj: "?z_hbj" (is "?z_hbk&?z_hbq")
 by (rule zenon_and_1 [OF z_Hbc])
 have z_Hbk: "?z_hbk"
 by (rule zenon_and_0 [OF z_Hbj])
 have z_Hbq: "?z_hbq" (is "?z_hbr&?z_hbu")
 by (rule zenon_and_1 [OF z_Hbj])
 have z_Hbr: "?z_hbr"
 by (rule zenon_and_0 [OF z_Hbq])
 have z_Hbu: "?z_hbu" (is "?z_hbv&?z_hbx")
 by (rule zenon_and_1 [OF z_Hbq])
 have z_Hbx: "?z_hbx" (is "?z_hby&?z_hca")
 by (rule zenon_and_1 [OF z_Hbu])
 have z_Hby: "?z_hby"
 by (rule zenon_and_0 [OF z_Hbx])
 have z_Hca: "?z_hca" (is "?z_hcb&?z_hce")
 by (rule zenon_and_1 [OF z_Hbx])
 have z_Hcb: "?z_hcb"
 by (rule zenon_and_0 [OF z_Hca])
 have z_Hce: "?z_hce" (is "?z_hcf&?z_hch")
 by (rule zenon_and_1 [OF z_Hca])
 have z_Hcf: "?z_hcf"
 by (rule zenon_and_0 [OF z_Hce])
 have z_Hlu: "(X \\in Nat)" (is "?z_hlu")
 by (rule zenon_in_setminus_0 [of "X" "Nat" "{0}", OF z_Hbd])
 have z_Hlv: "(~(X \\in {0}))" (is "~?z_hlw")
 by (rule zenon_in_setminus_1 [of "X" "Nat" "{0}", OF z_Hbd])
 have z_Hlx: "(X~=0)"
 by (rule zenon_notin_addElt_0 [of "X" "0" "{}", OF z_Hlv])
 show FALSE
 proof (rule zenon_notand [OF z_Ho])
  assume z_Hlz:"(~?z_hl)"
  show FALSE
  by (rule notE [OF z_Hlz z_Hl])
 next
  assume z_Hma:"(~?z_hlh)" (is "~(?z_hli&?z_hlj)")
  show FALSE
  proof (rule zenon_notand [OF z_Hma])
   assume z_Hmb:"(~?z_hli)"
   show FALSE
   proof (rule zenon_notin_setminus [of "a_Xhash_primea" "Nat" "{0}", OF z_Hmb])
    assume z_Hmc:"(~(a_Xhash_primea \\in Nat))" (is "~?z_hmd")
    have z_Hme: "(~?z_hlu)"
    by (rule subst [where P="(\<lambda>zenon_Vjrc. (~(zenon_Vjrc \\in Nat)))", OF z_Hh z_Hmc])
    show FALSE
    by (rule notE [OF z_Hme z_Hlu])
   next
    assume z_Hmj:"(a_Xhash_primea \\in {0})" (is "?z_hmj")
    show FALSE
    proof (rule zenon_in_addElt [of "a_Xhash_primea" "0" "{}", OF z_Hmj])
     assume z_Hmk:"(a_Xhash_primea=0)"
     have z_Hml: "(X=0)"
     by (rule subst [where P="(\<lambda>zenon_Vjb. (zenon_Vjb=0))", OF z_Hh z_Hmk])
     show FALSE
     by (rule notE [OF z_Hlx z_Hml])
    next
     assume z_Hmp:"(a_Xhash_primea \\in {})" (is "?z_hmp")
     show FALSE
     by (rule zenon_in_emptyset [of "a_Xhash_primea", OF z_Hmp])
    qed
   qed
  next
   assume z_Hmq:"(~?z_hlj)" (is "~(?z_hlk&?z_hll)")
   show FALSE
   proof (rule zenon_notand [OF z_Hmq])
    assume z_Hmr:"(~?z_hlk)"
    have z_Hms: "(~(?z_hed \\in FuncSet((Nat \\ {0}), ((Nat \\ {0}) \\cup {BOT}))))" (is "~?z_hmt")
    by (rule subst [where P="(\<lambda>zenon_Vmhd. (~(zenon_Vmhd \\in FuncSet((Nat \\ {0}), ((Nat \\ {0}) \\cup {BOT})))))", OF z_Hg z_Hmr])
    show FALSE
    proof (rule zenon_except_notin_funcset [of "Q" "(j[p])" "BOT" "(Nat \\ {0})" "((Nat \\ {0}) \\cup {BOT})", OF z_Hms])
     assume z_Hmy:"(~?z_hbk)"
     show FALSE
     by (rule notE [OF z_Hmy z_Hbk])
    next
     assume z_Hmz:"(~(BOT \\in ((Nat \\ {0}) \\cup {BOT})))" (is "~?z_hna")
     have z_Hnb: "(~(BOT \\in {BOT}))" (is "~?z_hnc")
     by (rule zenon_notin_cup_1 [of "BOT" "(Nat \\ {0})" "{BOT}", OF z_Hmz])
     have z_Hnd: "(BOT~=BOT)"
     by (rule zenon_notin_addElt_0 [of "BOT" "BOT" "{}", OF z_Hnb])
     show FALSE
     by (rule zenon_noteq [OF z_Hnd])
    qed
   next
    assume z_Hne:"(~?z_hll)" (is "~(?z_hlm&?z_hln)")
    show FALSE
    proof (rule zenon_notand [OF z_Hne])
     assume z_Hnf:"(~?z_hlm)"
     have z_Hng: "(~?z_hbr)"
     by (rule subst [where P="(\<lambda>zenon_Vohd. (~(zenon_Vohd \\in FuncSet(ProcSet, (Nat \\ {0})))))", OF z_Hi z_Hnf])
     show FALSE
     by (rule notE [OF z_Hng z_Hbr])
    next
     assume z_Hnl:"(~?z_hln)" (is "~(_&?z_hlo)")
     show FALSE
     proof (rule zenon_notand [OF z_Hnl])
      assume z_Hnm:"(~?z_hm)"
      show FALSE
      by (rule notE [OF z_Hnm z_Hm])
     next
      assume z_Hnn:"(~?z_hlo)" (is "~(?z_hlp&?z_hlq)")
      show FALSE
      proof (rule zenon_notand [OF z_Hnn])
       assume z_Hno:"(~?z_hlp)"
       have z_Hnp: "(~?z_hby)"
       by (rule subst [where P="(\<lambda>zenon_Vohd. (~(zenon_Vohd \\in FuncSet(ProcSet, (Nat \\ {0})))))", OF z_Hj z_Hno])
       show FALSE
       by (rule notE [OF z_Hnp z_Hby])
      next
       assume z_Hnq:"(~?z_hlq)" (is "~(?z_hlr&?z_hls)")
       show FALSE
       proof (rule zenon_notand [OF z_Hnq])
        assume z_Hnr:"(~?z_hlr)"
        have z_Hns: "(~(?z_hdx \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {BOT}))))" (is "~?z_hnt")
        by (rule subst [where P="(\<lambda>zenon_Vshd. (~(zenon_Vshd \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {BOT})))))", OF z_Hf z_Hnr])
        have z_Hhl: "(DOMAIN(x)=ProcSet)" (is "?z_hhm=_")
        by (rule zenon_in_funcset_1 [of "x" "ProcSet" "((Nat \\ {0}) \\cup {BOT})", OF z_Hcb])
        show FALSE
        proof (rule zenon_except_notin_funcset [of "x" "p" "(Q[(j[p])])" "ProcSet" "((Nat \\ {0}) \\cup {BOT})", OF z_Hns])
         assume z_Hny:"(~?z_hcb)"
         show FALSE
         by (rule notE [OF z_Hny z_Hcb])
        next
         assume z_Hiu:"(~((Q[(j[p])]) \\in ((Nat \\ {0}) \\cup {BOT})))" (is "~?z_hiv")
         have z_Hnz: "(~((Q[(j[p])]) \\in {BOT}))" (is "~?z_hoa")
         by (rule zenon_notin_cup_1 [of "(Q[(j[p])])" "(Nat \\ {0})" "{BOT}", OF z_Hiu])
         have z_Hob: "((Q[(j[p])])~=BOT)" (is "?z_hdy~=_")
         by (rule zenon_notin_addElt_0 [of "?z_hdy" "BOT" "{}", OF z_Hnz])
         show FALSE
         proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vf. zenon_Vf)" "(?z_hdy=BOT)" "cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))))" "((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))))))", OF z_Hd])
          assume z_Hfa:"(?z_hdy=BOT)"
          assume z_Hfb:"cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))))" (is "?z_hfb")
          show FALSE
          by (rule notE [OF z_Hob z_Hfa])
         next
          assume z_Hob:"(?z_hdy~=BOT)"
          assume z_Hft:"((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))))))" (is "?z_hfu&?z_hfw")
          have z_Hfw: "?z_hfw" (is "?z_hfk&?z_hfx")
          by (rule zenon_and_1 [OF z_Hft])
          have z_Hfk: "?z_hfk"
          by (rule zenon_and_0 [OF z_Hfw])
          show FALSE
          proof (rule zenon_notin_funcset [of "?z_hdx" "ProcSet" "((Nat \\ {0}) \\cup {BOT})", OF z_Hns])
           assume z_Hhh:"(~isAFcn(?z_hdx))" (is "~?z_hhi")
           show FALSE
           by (rule zenon_L1_ [OF z_Hhh])
          next
           assume z_Hhj:"(DOMAIN(?z_hdx)~=ProcSet)" (is "?z_hhk~=_")
           show FALSE
           by (rule zenon_L2_ [OF z_Hhj z_Hhl])
          next
           assume z_Hoe:"(~(\\A zenon_Vac:((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT})))))" (is "~(\\A x : ?z_hog(x))")
           have z_Hoh: "(\\E zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT})))))" (is "\\E x : ?z_hoi(x)")
           by (rule zenon_notallex_0 [of "?z_hog", OF z_Hoe])
           have z_Hoj: "?z_hoi((CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT}))))))" (is "~(?z_hiw=>?z_hkm)")
           by (rule zenon_ex_choose_0 [of "?z_hoi", OF z_Hoh])
           have z_Hiw: "?z_hiw"
           by (rule zenon_notimply_0 [OF z_Hoj])
           have z_Hkl: "(~?z_hkm)"
           by (rule zenon_notimply_1 [OF z_Hoj])
           have z_Hok: "(~((?z_hdx[(CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT})))))]) \\in (Nat \\ {0})))" (is "~?z_hol")
           by (rule zenon_notin_cup_0 [of "(?z_hdx[(CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT})))))])" "(Nat \\ {0})" "{BOT}", OF z_Hkl])
           show FALSE
           proof (rule zenon_notin_setminus [of "(?z_hdx[(CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT})))))])" "Nat" "{0}", OF z_Hok])
            assume z_Hom:"(~((?z_hdx[(CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT})))))]) \\in Nat))" (is "~?z_hon")
            have z_Hko: "((CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT}))))) \\in ?z_hhm)" (is "?z_hko")
            by (rule ssubst [where P="(\<lambda>zenon_Vng. ((CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT}))))) \\in zenon_Vng))", OF z_Hhl z_Hiw])
            show FALSE
            proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vjrc. (~(zenon_Vjrc \\in Nat)))" "x" "p" "?z_hdy" "(CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT})))))", OF z_Hom])
             assume z_Hko:"?z_hko"
             assume z_Hic:"(p=(CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT}))))))" (is "_=?z_hhv")
             assume z_Hor:"(~(?z_hdy \\in Nat))" (is "~?z_hos")
             show FALSE
             by (rule zenon_L4_ [OF z_Hm z_Hbk z_Hiu z_Hfk z_Hic z_Hiw])
            next
             assume z_Hko:"?z_hko"
             assume z_Hkp:"(p~=(CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT}))))))" (is "_~=?z_hhv")
             assume z_Hot:"(~((x[?z_hhv]) \\in Nat))" (is "~?z_hou")
             show FALSE
             by (rule zenon_L5_ [OF z_Hkl z_Hko z_Hiw z_Hcb z_Hkp])
            next
             assume z_Hlf:"(~?z_hko)"
             show FALSE
             by (rule notE [OF z_Hlf z_Hko])
            qed
           next
            assume z_Hov:"((?z_hdx[(CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT})))))]) \\in {0})" (is "?z_hov")
            show FALSE
            proof (rule zenon_in_addElt [of "(?z_hdx[(CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT})))))])" "0" "{}", OF z_Hov])
             assume z_How:"((?z_hdx[(CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT})))))])=0)" (is "?z_hkn=_")
             have z_Hko: "((CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT}))))) \\in ?z_hhm)" (is "?z_hko")
             by (rule ssubst [where P="(\<lambda>zenon_Vng. ((CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT}))))) \\in zenon_Vng))", OF z_Hhl z_Hiw])
             show FALSE
             proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vjb. (zenon_Vjb=0))" "x" "p" "?z_hdy" "(CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT})))))", OF z_How])
              assume z_Hko:"?z_hko"
              assume z_Hic:"(p=(CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT}))))))" (is "_=?z_hhv")
              assume z_Hox:"(?z_hdy=0)"
              show FALSE
              by (rule zenon_L4_ [OF z_Hm z_Hbk z_Hiu z_Hfk z_Hic z_Hiw])
             next
              assume z_Hko:"?z_hko"
              assume z_Hkp:"(p~=(CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT}))))))" (is "_~=?z_hhv")
              assume z_Hoy:"((x[?z_hhv])=0)" (is "?z_hkw=_")
              show FALSE
              by (rule zenon_L5_ [OF z_Hkl z_Hko z_Hiw z_Hcb z_Hkp])
             next
              assume z_Hlf:"(~?z_hko)"
              show FALSE
              by (rule notE [OF z_Hlf z_Hko])
             qed
            next
             assume z_Hoz:"((?z_hdx[(CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT})))))]) \\in {})" (is "?z_hoz")
             show FALSE
             by (rule zenon_in_emptyset [of "(?z_hdx[(CHOOSE zenon_Vac:(~((zenon_Vac \\in ProcSet)=>((?z_hdx[zenon_Vac]) \\in ((Nat \\ {0}) \\cup {BOT})))))])", OF z_Hoz])
            qed
           qed
          qed
         qed
        qed
       next
        assume z_Hpa:"(~?z_hls)" (is "~(?z_hlt&_)")
        show FALSE
        proof (rule zenon_notand [OF z_Hpa])
         assume z_Hpb:"(~?z_hlt)"
         have z_Hpc: "(~?z_hcf)"
         by (rule subst [where P="(\<lambda>zenon_Vohd. (~(zenon_Vohd \\in FuncSet(ProcSet, (Nat \\ {0})))))", OF z_Hk z_Hpb])
         show FALSE
         by (rule notE [OF z_Hpc z_Hcf])
        next
         assume z_Hpd:"(~?z_hn)"
         show FALSE
         by (rule notE [OF z_Hpd z_Hn])
        qed
       qed
      qed
     qed
    qed
   qed
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 45"; *} qed
lemma ob'85:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition PosInts suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition InvNL suppressed *)
assumes v'202: "(InvNL)"
(* usable definition A suppressed *)
assumes v'212: "(\<forall>S : (((((((S) \<in> ((SUBSET (Int))))) \<and> ((IsFiniteSet ((S)))))) \<Rightarrow> (\<exists> f \<in> ((((Injection (((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))), (S)))) \<inter> (subsetOf(([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))) \<rightarrow> (S)]), %M_1. (\<forall> t \<in> (S) : (\<exists> s \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))) : (((fapply ((M_1), (s))) = (t))))))))) : (\<forall> m \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))) : (\<forall> n \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))) : ((((less ((m), (n)))) \<Rightarrow> ((less ((fapply ((f), (m))), (fapply ((f), (n))))))))))))))"
assumes v'213: "(((((A) \<in> ((SUBSET (Int))))) \<and> ((IsFiniteSet ((A))))))"
shows "(\<exists> seq \<in> ([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) \<rightarrow> (A)]) : (\<forall> m \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) : (\<forall> n \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) : ((((less ((m), (n)))) \<Rightarrow> ((less ((fapply ((seq), (m))), (fapply ((seq), (n)))))))))))"(is "PROP ?ob'85")
proof -
ML_command {* writeln "*** TLAPS ENTER 85"; *}
show "PROP ?ob'85"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_2e4e23.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_2e4e23.znn.out
;; obligation #85
$hyp "v'202" InvNL
$hyp "v'212" (A. ((S) (=> (/\ (TLA.in S (TLA.SUBSET arith.Z))
(IsFiniteSet S))
(TLA.bEx (TLA.cap (Injection (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality S)) S)
(TLA.subsetOf (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality S)) S) ((M_1) (TLA.bAll S ((t) (TLA.bEx (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality S)) ((s) (= (TLA.fapply M_1 s)
t)))))))) ((f) (TLA.bAll (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality S)) ((m) (TLA.bAll (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality S)) ((n) (=> (arith.lt m n) (arith.lt (TLA.fapply f m)
(TLA.fapply f n))))))))))))
$hyp "v'213" (/\ (TLA.in A (TLA.SUBSET arith.Z))
(IsFiniteSet A))
$goal (TLA.bEx (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) A) ((seq) (TLA.bAll (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) ((m) (TLA.bAll (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) ((n) (=> (arith.lt m n) (arith.lt (TLA.fapply seq m)
(TLA.fapply seq n)))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hc:"((A \\in SUBSET(Int))&IsFiniteSet(A))" (is "?z_he&?z_hi")
 using v'213 by blast
 have z_Hb:"(\\A S:(((S \\in SUBSET(Int))&IsFiniteSet(S))=>bEx((Injection(isa'dotdot(1, Cardinality(S)), S) \\cap subsetOf(FuncSet(isa'dotdot(1, Cardinality(S)), S), (\<lambda>M_1. bAll(S, (\<lambda>t. bEx(isa'dotdot(1, Cardinality(S)), (\<lambda>s. ((M_1[s])=t)))))))), (\<lambda>f. bAll(isa'dotdot(1, Cardinality(S)), (\<lambda>m. bAll(isa'dotdot(1, Cardinality(S)), (\<lambda>n. ((m < n)=>((f[m]) < (f[n])))))))))))" (is "\\A x : ?z_hbt(x)")
 using v'212 by blast
 assume z_Hd:"(~bEx(FuncSet(isa'dotdot(1, Cardinality(A)), A), (\<lambda>seq. bAll(isa'dotdot(1, Cardinality(A)), (\<lambda>m. bAll(isa'dotdot(1, Cardinality(A)), (\<lambda>n. ((m < n)=>((seq[m]) < (seq[n]))))))))))" (is "~?z_hbu")
 have z_He: "?z_he"
 by (rule zenon_and_0 [OF z_Hc])
 have z_Hi: "?z_hi"
 by (rule zenon_and_1 [OF z_Hc])
 have z_Hci_z_Hd: "(~(\\E x:((x \\in FuncSet(isa'dotdot(1, Cardinality(A)), A))&bAll(isa'dotdot(1, Cardinality(A)), (\<lambda>m. bAll(isa'dotdot(1, Cardinality(A)), (\<lambda>n. ((m < n)=>((x[m]) < (x[n])))))))))) == (~?z_hbu)" (is "?z_hci == ?z_hd")
 by (unfold bEx_def)
 have z_Hci: "?z_hci" (is "~(\\E x : ?z_hcv(x))")
 by (unfold z_Hci_z_Hd, fact z_Hd)
 have z_Hcw: "?z_hbt(A)" (is "?z_hc=>?z_hcx")
 by (rule zenon_all_0 [of "?z_hbt" "A", OF z_Hb])
 show FALSE
 proof (rule zenon_imply [OF z_Hcw])
  assume z_Hcy:"(~?z_hc)"
  show FALSE
  proof (rule zenon_notand [OF z_Hcy])
   assume z_Hcz:"(~?z_he)"
   show FALSE
   by (rule notE [OF z_Hcz z_He])
  next
   assume z_Hda:"(~?z_hi)"
   show FALSE
   by (rule notE [OF z_Hda z_Hi])
  qed
 next
  assume z_Hcx:"?z_hcx"
  have z_Hdb_z_Hcx: "(\\E x:((x \\in (Injection(isa'dotdot(1, Cardinality(A)), A) \\cap subsetOf(FuncSet(isa'dotdot(1, Cardinality(A)), A), (\<lambda>M_1. bAll(A, (\<lambda>t. bEx(isa'dotdot(1, Cardinality(A)), (\<lambda>s. ((M_1[s])=t)))))))))&bAll(isa'dotdot(1, Cardinality(A)), (\<lambda>m. bAll(isa'dotdot(1, Cardinality(A)), (\<lambda>n. ((m < n)=>((x[m]) < (x[n]))))))))) == ?z_hcx" (is "?z_hdb == _")
  by (unfold bEx_def)
  have z_Hdb: "?z_hdb" (is "\\E x : ?z_hdl(x)")
  by (unfold z_Hdb_z_Hcx, fact z_Hcx)
  have z_Hdm: "?z_hdl((CHOOSE x:((x \\in (Injection(isa'dotdot(1, Cardinality(A)), A) \\cap subsetOf(FuncSet(isa'dotdot(1, Cardinality(A)), A), (\<lambda>M_1. bAll(A, (\<lambda>t. bEx(isa'dotdot(1, Cardinality(A)), (\<lambda>s. ((M_1[s])=t)))))))))&bAll(isa'dotdot(1, Cardinality(A)), (\<lambda>m. bAll(isa'dotdot(1, Cardinality(A)), (\<lambda>n. ((m < n)=>((x[m]) < (x[n]))))))))))" (is "?z_hdo&?z_hdp")
  by (rule zenon_ex_choose_0 [of "?z_hdl", OF z_Hdb])
  have z_Hdo: "?z_hdo"
  by (rule zenon_and_0 [OF z_Hdm])
  have z_Hdp: "?z_hdp"
  by (rule zenon_and_1 [OF z_Hdm])
  have z_Hdq: "((CHOOSE x:((x \\in (Injection(isa'dotdot(1, Cardinality(A)), A) \\cap subsetOf(FuncSet(isa'dotdot(1, Cardinality(A)), A), (\<lambda>M_1. bAll(A, (\<lambda>t. bEx(isa'dotdot(1, Cardinality(A)), (\<lambda>s. ((M_1[s])=t)))))))))&bAll(isa'dotdot(1, Cardinality(A)), (\<lambda>m. bAll(isa'dotdot(1, Cardinality(A)), (\<lambda>n. ((m < n)=>((x[m]) < (x[n]))))))))) \\in subsetOf(FuncSet(isa'dotdot(1, Cardinality(A)), A), (\<lambda>M_1. bAll(A, (\<lambda>t. bEx(isa'dotdot(1, Cardinality(A)), (\<lambda>s. ((M_1[s])=t))))))))" (is "?z_hdq")
  by (rule zenon_in_cap_1 [of "(CHOOSE x:((x \\in (Injection(isa'dotdot(1, Cardinality(A)), A) \\cap subsetOf(FuncSet(isa'dotdot(1, Cardinality(A)), A), (\<lambda>M_1. bAll(A, (\<lambda>t. bEx(isa'dotdot(1, Cardinality(A)), (\<lambda>s. ((M_1[s])=t)))))))))&bAll(isa'dotdot(1, Cardinality(A)), (\<lambda>m. bAll(isa'dotdot(1, Cardinality(A)), (\<lambda>n. ((m < n)=>((x[m]) < (x[n])))))))))" "Injection(isa'dotdot(1, Cardinality(A)), A)" "subsetOf(FuncSet(isa'dotdot(1, Cardinality(A)), A), (\<lambda>M_1. bAll(A, (\<lambda>t. bEx(isa'dotdot(1, Cardinality(A)), (\<lambda>s. ((M_1[s])=t)))))))", OF z_Hdo])
  have z_Hdr: "((CHOOSE x:((x \\in (Injection(isa'dotdot(1, Cardinality(A)), A) \\cap subsetOf(FuncSet(isa'dotdot(1, Cardinality(A)), A), (\<lambda>M_1. bAll(A, (\<lambda>t. bEx(isa'dotdot(1, Cardinality(A)), (\<lambda>s. ((M_1[s])=t)))))))))&bAll(isa'dotdot(1, Cardinality(A)), (\<lambda>m. bAll(isa'dotdot(1, Cardinality(A)), (\<lambda>n. ((m < n)=>((x[m]) < (x[n]))))))))) \\in FuncSet(isa'dotdot(1, Cardinality(A)), A))" (is "?z_hdr")
  by (rule zenon_in_subsetof_0 [of "(CHOOSE x:((x \\in (Injection(isa'dotdot(1, Cardinality(A)), A) \\cap subsetOf(FuncSet(isa'dotdot(1, Cardinality(A)), A), (\<lambda>M_1. bAll(A, (\<lambda>t. bEx(isa'dotdot(1, Cardinality(A)), (\<lambda>s. ((M_1[s])=t)))))))))&bAll(isa'dotdot(1, Cardinality(A)), (\<lambda>m. bAll(isa'dotdot(1, Cardinality(A)), (\<lambda>n. ((m < n)=>((x[m]) < (x[n])))))))))" "FuncSet(isa'dotdot(1, Cardinality(A)), A)" "(\<lambda>M_1. bAll(A, (\<lambda>t. bEx(isa'dotdot(1, Cardinality(A)), (\<lambda>s. ((M_1[s])=t))))))", OF z_Hdq])
  have z_Hds: "~?z_hcv((CHOOSE x:((x \\in (Injection(isa'dotdot(1, Cardinality(A)), A) \\cap subsetOf(FuncSet(isa'dotdot(1, Cardinality(A)), A), (\<lambda>M_1. bAll(A, (\<lambda>t. bEx(isa'dotdot(1, Cardinality(A)), (\<lambda>s. ((M_1[s])=t)))))))))&bAll(isa'dotdot(1, Cardinality(A)), (\<lambda>m. bAll(isa'dotdot(1, Cardinality(A)), (\<lambda>n. ((m < n)=>((x[m]) < (x[n]))))))))))"
  by (rule zenon_notex_0 [of "?z_hcv" "(CHOOSE x:((x \\in (Injection(isa'dotdot(1, Cardinality(A)), A) \\cap subsetOf(FuncSet(isa'dotdot(1, Cardinality(A)), A), (\<lambda>M_1. bAll(A, (\<lambda>t. bEx(isa'dotdot(1, Cardinality(A)), (\<lambda>s. ((M_1[s])=t)))))))))&bAll(isa'dotdot(1, Cardinality(A)), (\<lambda>m. bAll(isa'dotdot(1, Cardinality(A)), (\<lambda>n. ((m < n)=>((x[m]) < (x[n])))))))))", OF z_Hci])
  show FALSE
  proof (rule zenon_notand [OF z_Hds])
   assume z_Hdt:"(~?z_hdr)"
   show FALSE
   by (rule notE [OF z_Hdt z_Hdr])
  next
   assume z_Hdu:"(~?z_hdp)"
   show FALSE
   by (rule notE [OF z_Hdu z_Hdp])
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 85"; *} qed
lemma ob'79:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
assumes v'201: "(((((pc) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & (((X) \<in> (((Nat) \\ ({((0))}))))) & (((Q) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((i) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((j) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((l) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((x) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((v) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((M) \<in> ((SUBSET (subsetOf((CDomain), %a_ca. ((CFTypeOK ((a_ca))))))))))) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina))"
(* usable definition A suppressed *)
assumes v'211: "((\<And> a :: c. a \<in> (Int) \<Longrightarrow> (\<And> b :: c. b \<in> (Int) \<Longrightarrow> (((IsFiniteSet (((isa_peri_peri_a ((a), (b))))))) & ((((Cardinality (((isa_peri_peri_a ((a), (b))))))) = (cond(((greater ((a), (b)))), ((0)), ((arith_add (((arith_add ((b), ((minus ((a))))))), ((Succ[0])))))))))))))"
shows "((IsFiniteSet (((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0]))))))))))))))"(is "PROP ?ob'79")
proof -
ML_command {* writeln "*** TLAPS ENTER 79"; *}
show "PROP ?ob'79"
using assms by auto
ML_command {* writeln "*** TLAPS EXIT 79"; *} qed
lemma ob'74:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition PosInts suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition InvNL suppressed *)
assumes v'204: "(InvNL)"
(* usable definition A suppressed *)
assumes v'213: "((IsFiniteSet (((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0]))))))))))))))"
assumes v'214: "(((A) \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0])))))))))))))))"
assumes v'215: "((\<And> S :: c. (((IsFiniteSet ((S)))) \<Longrightarrow> (\<And> T :: c. T \<in> ((SUBSET (S))) \<Longrightarrow> (((IsFiniteSet ((T)))) & ((leq (((Cardinality ((T)))), ((Cardinality ((S))))))) & ((((((Cardinality ((S)))) = ((Cardinality ((T)))))) \<Rightarrow> (((S) = (T))))))))))"
shows "((IsFiniteSet ((A))))"(is "PROP ?ob'74")
proof -
ML_command {* writeln "*** TLAPS ENTER 74"; *}
show "PROP ?ob'74"
using assms by auto
ML_command {* writeln "*** TLAPS EXIT 74"; *} qed
lemma ob'51:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
assumes v'184: "((((pc) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & (((X) \<in> (((Nat) \\ ({((0))}))))) & (((Q) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((i) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((j) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((l) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((x) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((v) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((M) \<in> ((SUBSET (subsetOf(([''sigma'' : ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))]))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %a_ca. (\<forall> p \<in> (ProcSet) : ((((((fapply ((pc), (p))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p))) = (BOT))))) & (((((fapply ((pc), (p))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p))) \<in> ({(ACK), (BOT)}))))) & (((((fapply ((pc), (p))) \<in> ({(''D4'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)}))))))))))))))))"
assumes v'185: "(((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'198: "(cond((((fapply ((Q), (fapply ((j), (p))))) = (BOT))), (cond((((fapply ((j), (p))) = ((arith_add ((fapply ((l), (p))), ((minus (((Succ[0])))))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & (((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (M))))), (((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((arith_add ((fapply ((j), (p))), ((Succ[0])))))]))) & (((((a_pchash_primea :: c)) = (pc))) & ((((a_Mhash_primea :: c)) = (M))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D4'')]))) & ((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (subsetOf(([''sigma'' : ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))]))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %d. ((\<forall> p_1 \<in> (ProcSet) : ((((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (p_1))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (p_1))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''D4'')}))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (p_1))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)}))))))))) & (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((d), (''fres''))), (p))) = ((Head ((fapply ((a_ca), (''sigma'')))))))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = ((Tail ((fapply ((a_ca), (''sigma''))))))))))))))))))"
assumes v'199: "(((fapply ((pc), (p))) = (''D3'')))"
assumes v'200: "((((a_xhash_primea :: c)) = ([(x) EXCEPT ![(p)] = (fapply ((Q), (fapply ((j), (p)))))])))"
assumes v'201: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((j), (p)))] = (BOT)])))"
assumes v'202: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'203: "((((a_ihash_primea :: c)) = (i)))"
assumes v'204: "((((a_lhash_primea :: c)) = (l)))"
assumes v'205: "((((a_vhash_primea :: c)) = (v)))"
shows "((((a_pchash_primea :: c)) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})])))"(is "PROP ?ob'51")
proof -
ML_command {* writeln "*** TLAPS ENTER 51"; *}
show "PROP ?ob'51"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_41b42f.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_41b42f.znn.out
;; obligation #51
$hyp "v'184" (/\ (TLA.in pc
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in X (TLA.setminus arith.N (TLA.set 0))) (TLA.in Q
(TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in i (TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in j
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in l
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in x
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in v (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in M
(TLA.SUBSET (TLA.subsetOf (TLA.recordset "sigma" (TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))) ((a_ca) (TLA.bAll ProcSet ((p) (/\ (=> (TLA.in (TLA.fapply pc p)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply a_ca "fres") p) BOT))
(=> (TLA.in (TLA.fapply pc p) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p) (TLA.set ACK BOT)))
(=> (TLA.in (TLA.fapply pc p) (TLA.set "D4"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT))))))))))))
$hyp "v'185" (\/ Next (= a_h4fd5f73954dc53af536c1c75068837a
vars))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'198" (TLA.cond (= (TLA.fapply Q (TLA.fapply j p))
BOT) (TLA.cond (= (TLA.fapply j p) (arith.add (TLA.fapply l p)
(arith.minus (TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea
(TLA.except pc p "D1")) (/\ (= a_jhash_primea j) (= a_Mhash_primea
M))) (/\ (= a_jhash_primea (TLA.except j p (arith.add (TLA.fapply j p)
(TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea pc) (= a_Mhash_primea
M)))) (/\ (= a_pchash_primea (TLA.except pc p "D4")) (= a_jhash_primea j)
(= a_Mhash_primea
(TLA.subsetOf (TLA.recordset "sigma" (TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))) ((d) (/\ (TLA.bAll ProcSet ((p_1) (/\ (=> (TLA.in (TLA.fapply a_pchash_primea p_1)
(TLA.set "L0" "E1" "D1" "D2" "D3")) (= (TLA.fapply (TLA.fapply d "fres") p_1)
BOT)) (=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply d "fres") p_1) (TLA.set ACK BOT)))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "D4"))
(TLA.in (TLA.fapply (TLA.fapply d "fres") p_1) (TLA.cup (TLA.setminus arith.N
(TLA.set 0)) (TLA.set BOT)))))))
(TLA.bEx M ((a_ca) (/\ (= (TLA.fapply (TLA.fapply d "fres") p)
(Head (TLA.fapply a_ca "sigma"))) (TLA.bAll ProcSet ((q) (=> (-. (= q p))
(= (TLA.fapply (TLA.fapply d "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))) (= (TLA.fapply d "sigma")
(Tail (TLA.fapply a_ca "sigma"))))))))))))
$hyp "v'199" (= (TLA.fapply pc p) "D3")
$hyp "v'200" (= a_xhash_primea
(TLA.except x p (TLA.fapply Q (TLA.fapply j p))))
$hyp "v'201" (= a_Qhash_primea
(TLA.except Q (TLA.fapply j p) BOT))
$hyp "v'202" (= a_Xhash_primea X)
$hyp "v'203" (= a_ihash_primea i)
$hyp "v'204" (= a_lhash_primea l)
$hyp "v'205" (= a_vhash_primea v)
$goal (TLA.in a_pchash_primea
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Ha:"((pc \\in FuncSet(ProcSet, {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))&((X \\in (Nat \\ {0}))&((Q \\in FuncSet((Nat \\ {0}), ((Nat \\ {0}) \\cup {BOT})))&((i \\in FuncSet(ProcSet, (Nat \\ {0})))&((j \\in FuncSet(ProcSet, (Nat \\ {0})))&((l \\in FuncSet(ProcSet, (Nat \\ {0})))&((x \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {BOT})))&((v \\in FuncSet(ProcSet, (Nat \\ {0})))&(M \\in SUBSET(subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((a_ca[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>(((a_ca[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))))))))" (is "?z_hm&?z_hz")
 using v'184 by blast
 have z_Hd:"cond(((Q[(j[p])])=BOT), cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M)))), ((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma'']))))))))))))))" (is "?z_hd")
 using v'198 by blast
 assume z_Hl:"(~(a_pchash_primea \\in FuncSet(ProcSet, {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''})))" (is "~?z_hgi")
 have z_Hm: "?z_hm"
 by (rule zenon_and_0 [OF z_Ha])
 have z_Hgj: "(DOMAIN(pc)=ProcSet)" (is "?z_hgk=_")
 by (rule zenon_in_funcset_1 [of "pc" "ProcSet" "{''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}", OF z_Hm])
 show FALSE
 proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vf. zenon_Vf)" "((Q[(j[p])])=BOT)" "cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))))" "((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))))))", OF z_Hd])
  assume z_Hds:"((Q[(j[p])])=BOT)" (is "?z_hdt=_")
  assume z_Hdv:"cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))))" (is "?z_hdv")
  show FALSE
  proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vf. zenon_Vf)" "((j[p])=((l[p]) +  -.(1)))" "((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M)))" "((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M)))", OF z_Hdv])
   assume z_Hdw:"((j[p])=((l[p]) +  -.(1)))" (is "?z_hdu=?z_hdx")
   assume z_Hea:"((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M)))" (is "?z_heb&?z_hee")
   have z_Heb: "?z_heb" (is "_=?z_hed")
   by (rule zenon_and_0 [OF z_Hea])
   show FALSE
   proof (rule zenon_notin_funcset [of "a_pchash_primea" "ProcSet" "{''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}", OF z_Hl])
    assume z_Hgn:"(~isAFcn(a_pchash_primea))" (is "~?z_hgo")
    have z_Hgp: "(~isAFcn(?z_hed))" (is "~?z_hgq")
    by (rule subst [where P="(\<lambda>zenon_Vzva. (~isAFcn(zenon_Vzva)))", OF z_Heb z_Hgn])
    show FALSE
    by (rule zenon_notisafcn_except [of "pc" "p" "''D1''", OF z_Hgp])
   next
    assume z_Hgv:"(DOMAIN(a_pchash_primea)~=ProcSet)" (is "?z_hgw~=_")
    have z_Hgx: "(DOMAIN(?z_hed)~=ProcSet)" (is "?z_hgy~=_")
    by (rule subst [where P="(\<lambda>zenon_Vdwa. (DOMAIN(zenon_Vdwa)~=ProcSet))", OF z_Heb z_Hgv])
    have z_Hhd: "(?z_hgk~=ProcSet)"
    by (rule zenon_domain_except_0 [of "(\<lambda>zenon_Vcwa. (zenon_Vcwa~=ProcSet))" "pc" "p" "''D1''", OF z_Hgx])
    show FALSE
    by (rule notE [OF z_Hhd z_Hgj])
   next
    assume z_Hhh:"(~(\\A zenon_Vh:((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))))" (is "~(\\A x : ?z_hho(x))")
    have z_Hhp: "(\\E zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))))" (is "\\E x : ?z_hhr(x)")
    by (rule zenon_notallex_0 [of "?z_hho", OF z_Hhh])
    have z_Hhs: "?z_hhr((CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''})))))" (is "~(?z_hhu=>?z_hhv)")
    by (rule zenon_ex_choose_0 [of "?z_hhr", OF z_Hhp])
    have z_Hhu: "?z_hhu"
    by (rule zenon_notimply_0 [OF z_Hhs])
    have z_Hhw: "(~?z_hhv)"
    by (rule zenon_notimply_1 [OF z_Hhs])
    have z_Hhx: "((a_pchash_primea[(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))))])~=''L0'')" (is "?z_hhy~=?z_hr")
    by (rule zenon_notin_addElt_0 [of "?z_hhy" "?z_hr" "{''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}", OF z_Hhw])
    have z_Hia: "(~(?z_hhy \\in {''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))" (is "~?z_hib")
    by (rule zenon_notin_addElt_1 [of "?z_hhy" "?z_hr" "{''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}", OF z_Hhw])
    have z_Hic: "(?z_hhy~=''E1'')" (is "_~=?z_hs")
    by (rule zenon_notin_addElt_0 [of "?z_hhy" "?z_hs" "{''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}", OF z_Hia])
    have z_Hie: "(~(?z_hhy \\in {''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))" (is "~?z_hif")
    by (rule zenon_notin_addElt_1 [of "?z_hhy" "?z_hs" "{''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}", OF z_Hia])
    have z_Hig: "(?z_hhy~=''E2'')" (is "_~=?z_ht")
    by (rule zenon_notin_addElt_0 [of "?z_hhy" "?z_ht" "{''E3'', ''D1'', ''D2'', ''D3'', ''D4''}", OF z_Hie])
    have z_Hii: "(~(?z_hhy \\in {''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))" (is "~?z_hij")
    by (rule zenon_notin_addElt_1 [of "?z_hhy" "?z_ht" "{''E3'', ''D1'', ''D2'', ''D3'', ''D4''}", OF z_Hie])
    have z_Hik: "(?z_hhy~=''E3'')" (is "_~=?z_hu")
    by (rule zenon_notin_addElt_0 [of "?z_hhy" "?z_hu" "{''D1'', ''D2'', ''D3'', ''D4''}", OF z_Hii])
    have z_Him: "(~(?z_hhy \\in {''D1'', ''D2'', ''D3'', ''D4''}))" (is "~?z_hin")
    by (rule zenon_notin_addElt_1 [of "?z_hhy" "?z_hu" "{''D1'', ''D2'', ''D3'', ''D4''}", OF z_Hii])
    have z_Hio: "(?z_hhy~=''D1'')" (is "_~=?z_hv")
    by (rule zenon_notin_addElt_0 [of "?z_hhy" "?z_hv" "{''D2'', ''D3'', ''D4''}", OF z_Him])
    have z_Hiq: "(~(?z_hhy \\in {''D2'', ''D3'', ''D4''}))" (is "~?z_hir")
    by (rule zenon_notin_addElt_1 [of "?z_hhy" "?z_hv" "{''D2'', ''D3'', ''D4''}", OF z_Him])
    have z_His: "(?z_hhy~=''D2'')" (is "_~=?z_hw")
    by (rule zenon_notin_addElt_0 [of "?z_hhy" "?z_hw" "{''D3'', ''D4''}", OF z_Hiq])
    have z_Hiu: "(~(?z_hhy \\in {''D3'', ''D4''}))" (is "~?z_hiv")
    by (rule zenon_notin_addElt_1 [of "?z_hhy" "?z_hw" "{''D3'', ''D4''}", OF z_Hiq])
    have z_Hiw: "(?z_hhy~=''D3'')" (is "_~=?z_hx")
    by (rule zenon_notin_addElt_0 [of "?z_hhy" "?z_hx" "{''D4''}", OF z_Hiu])
    have z_Hix: "(~(?z_hhy \\in {''D4''}))" (is "~?z_hiy")
    by (rule zenon_notin_addElt_1 [of "?z_hhy" "?z_hx" "{''D4''}", OF z_Hiu])
    have z_Hiz: "(?z_hhy~=''D4'')" (is "_~=?z_hy")
    by (rule zenon_notin_addElt_0 [of "?z_hhy" "?z_hy" "{}", OF z_Hix])
    have z_Hjb: "((CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {?z_hr, ?z_hs, ?z_ht, ?z_hu, ?z_hv, ?z_hw, ?z_hx, ?z_hy})))) \\in ?z_hgk)" (is "?z_hjb")
    by (rule ssubst [where P="(\<lambda>zenon_Vji. ((CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {?z_hr, ?z_hs, ?z_ht, ?z_hu, ?z_hv, ?z_hw, ?z_hx, ?z_hy})))) \\in zenon_Vji))", OF z_Hgj z_Hhu])
    have z_Hjf: "(\\A zenon_Vma:((zenon_Vma \\in ProcSet)=>((pc[zenon_Vma]) \\in {?z_hr, ?z_hs, ?z_ht, ?z_hu, ?z_hv, ?z_hw, ?z_hx, ?z_hy})))" (is "\\A x : ?z_hjl(x)")
    by (rule zenon_in_funcset_2 [of "pc" "ProcSet" "{?z_hr, ?z_hs, ?z_ht, ?z_hu, ?z_hv, ?z_hw, ?z_hx, ?z_hy}", OF z_Hm])
    have z_Hjm: "(((isAFcn(a_pchash_primea)<=>isAFcn(?z_hed))&(DOMAIN(a_pchash_primea)=DOMAIN(?z_hed)))&(\\A zenon_Vmkb:((a_pchash_primea[zenon_Vmkb])=(?z_hed[zenon_Vmkb]))))" (is "?z_hjn&?z_hjq")
    by (rule zenon_funequal_0 [of "a_pchash_primea" "?z_hed", OF z_Heb])
    have z_Hjq: "?z_hjq" (is "\\A x : ?z_hjv(x)")
    by (rule zenon_and_1 [OF z_Hjm])
    have z_Hjw: "?z_hjv((CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {?z_hr, ?z_hs, ?z_ht, ?z_hu, ?z_hv, ?z_hw, ?z_hx, ?z_hy})))))" (is "_=?z_hjx")
    by (rule zenon_all_0 [of "?z_hjv" "(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {?z_hr, ?z_hs, ?z_ht, ?z_hu, ?z_hv, ?z_hw, ?z_hx, ?z_hy}))))", OF z_Hjq])
    show FALSE
    proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vfga. (?z_hhy=zenon_Vfga))" "pc" "p" "?z_hv" "(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {?z_hr, ?z_hs, ?z_ht, ?z_hu, ?z_hv, ?z_hw, ?z_hx, ?z_hy}))))", OF z_Hjw])
     assume z_Hjb:"?z_hjb"
     assume z_Hkb:"(p=(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {?z_hr, ?z_hs, ?z_ht, ?z_hu, ?z_hv, ?z_hw, ?z_hx, ?z_hy})))))" (is "_=?z_hht")
     assume z_Hkc:"(?z_hhy=?z_hv)"
     show FALSE
     by (rule notE [OF z_Hio z_Hkc])
    next
     assume z_Hjb:"?z_hjb"
     assume z_Hkd:"(p~=(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {?z_hr, ?z_hs, ?z_ht, ?z_hu, ?z_hv, ?z_hw, ?z_hx, ?z_hy})))))" (is "_~=?z_hht")
     assume z_Hke:"(?z_hhy=(pc[?z_hht]))" (is "_=?z_hkf")
     show FALSE
     proof (rule notE [OF z_Hhx])
      have z_Hkg: "(?z_hjx=?z_hr)"
      proof (rule zenon_nnpp [of "(?z_hjx=?z_hr)"])
       assume z_Hkh:"(?z_hjx~=?z_hr)"
       show FALSE
       proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vjqk. (zenon_Vjqk~=?z_hr))" "pc" "p" "?z_hv" "?z_hht", OF z_Hkh])
        assume z_Hjb:"?z_hjb"
        assume z_Hkb:"(p=?z_hht)"
        assume z_Hkl:"(?z_hv~=?z_hr)"
        show FALSE
        by (rule notE [OF z_Hkd z_Hkb])
       next
        assume z_Hjb:"?z_hjb"
        assume z_Hkd:"(p~=?z_hht)"
        assume z_Hkm:"(?z_hkf~=?z_hr)"
        show FALSE
        proof (rule notE [OF z_Hic])
         have z_Hkn: "(?z_hjx=?z_hs)"
         proof (rule zenon_nnpp [of "(?z_hjx=?z_hs)"])
          assume z_Hko:"(?z_hjx~=?z_hs)"
          show FALSE
          proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vlqk. (zenon_Vlqk~=?z_hs))" "pc" "p" "?z_hv" "?z_hht", OF z_Hko])
           assume z_Hjb:"?z_hjb"
           assume z_Hkb:"(p=?z_hht)"
           assume z_Hks:"(?z_hv~=?z_hs)"
           show FALSE
           by (rule notE [OF z_Hkd z_Hkb])
          next
           assume z_Hjb:"?z_hjb"
           assume z_Hkd:"(p~=?z_hht)"
           assume z_Hkt:"(?z_hkf~=?z_hs)"
           show FALSE
           proof (rule notE [OF z_Hig])
            have z_Hku: "(?z_hjx=?z_ht)"
            proof (rule zenon_nnpp [of "(?z_hjx=?z_ht)"])
             assume z_Hkv:"(?z_hjx~=?z_ht)"
             show FALSE
             proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vnqk. (zenon_Vnqk~=?z_ht))" "pc" "p" "?z_hv" "?z_hht", OF z_Hkv])
              assume z_Hjb:"?z_hjb"
              assume z_Hkb:"(p=?z_hht)"
              assume z_Hkz:"(?z_hv~=?z_ht)"
              show FALSE
              by (rule notE [OF z_Hkd z_Hkb])
             next
              assume z_Hjb:"?z_hjb"
              assume z_Hkd:"(p~=?z_hht)"
              assume z_Hla:"(?z_hkf~=?z_ht)"
              show FALSE
              proof (rule notE [OF z_Hik])
               have z_Hlb: "(?z_hjx=?z_hu)"
               proof (rule zenon_nnpp [of "(?z_hjx=?z_hu)"])
               assume z_Hlc:"(?z_hjx~=?z_hu)"
               show FALSE
               proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vpqk. (zenon_Vpqk~=?z_hu))" "pc" "p" "?z_hv" "?z_hht", OF z_Hlc])
               assume z_Hjb:"?z_hjb"
               assume z_Hkb:"(p=?z_hht)"
               assume z_Hlg:"(?z_hv~=?z_hu)"
               show FALSE
               by (rule notE [OF z_Hkd z_Hkb])
               next
               assume z_Hjb:"?z_hjb"
               assume z_Hkd:"(p~=?z_hht)"
               assume z_Hlh:"(?z_hkf~=?z_hu)"
               show FALSE
               proof (rule notE [OF z_Hio])
               have z_Hli: "(?z_hjx=?z_hv)"
               proof (rule zenon_nnpp [of "(?z_hjx=?z_hv)"])
               assume z_Hlj:"(?z_hjx~=?z_hv)"
               show FALSE
               proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vekk. (zenon_Vekk~=?z_hv))" "pc" "p" "?z_hv" "?z_hht", OF z_Hlj])
               assume z_Hjb:"?z_hjb"
               assume z_Hkb:"(p=?z_hht)"
               assume z_Hln:"(?z_hv~=?z_hv)"
               show FALSE
               by (rule notE [OF z_Hkd z_Hkb])
               next
               assume z_Hjb:"?z_hjb"
               assume z_Hkd:"(p~=?z_hht)"
               assume z_Hlo:"(?z_hkf~=?z_hv)"
               show FALSE
               proof (rule notE [OF z_His])
               have z_Hlp: "(?z_hjx=?z_hw)"
               proof (rule zenon_nnpp [of "(?z_hjx=?z_hw)"])
               assume z_Hlq:"(?z_hjx~=?z_hw)"
               show FALSE
               proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vnlf. (zenon_Vnlf~=?z_hw))" "pc" "p" "?z_hv" "?z_hht", OF z_Hlq])
               assume z_Hjb:"?z_hjb"
               assume z_Hkb:"(p=?z_hht)"
               assume z_Hlu:"(?z_hv~=?z_hw)"
               show FALSE
               by (rule notE [OF z_Hkd z_Hkb])
               next
               assume z_Hjb:"?z_hjb"
               assume z_Hkd:"(p~=?z_hht)"
               assume z_Hlv:"(?z_hkf~=?z_hw)"
               show FALSE
               proof (rule notE [OF z_Hiw])
               have z_Hlw: "(?z_hjx=?z_hx)"
               proof (rule zenon_nnpp [of "(?z_hjx=?z_hx)"])
               assume z_Hlx:"(?z_hjx~=?z_hx)"
               show FALSE
               proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vpyh. (zenon_Vpyh~=?z_hx))" "pc" "p" "?z_hv" "?z_hht", OF z_Hlx])
               assume z_Hjb:"?z_hjb"
               assume z_Hkb:"(p=?z_hht)"
               assume z_Hmb:"(?z_hv~=?z_hx)"
               show FALSE
               by (rule notE [OF z_Hkd z_Hkb])
               next
               assume z_Hjb:"?z_hjb"
               assume z_Hkd:"(p~=?z_hht)"
               assume z_Hmc:"(?z_hkf~=?z_hx)"
               show FALSE
               proof (rule notE [OF z_Hiz])
               have z_Hmd: "(?z_hjx=?z_hy)"
               proof (rule zenon_nnpp [of "(?z_hjx=?z_hy)"])
               assume z_Hme:"(?z_hjx~=?z_hy)"
               show FALSE
               proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vxqk. (zenon_Vxqk~=?z_hy))" "pc" "p" "?z_hv" "?z_hht", OF z_Hme])
               assume z_Hjb:"?z_hjb"
               assume z_Hkb:"(p=?z_hht)"
               assume z_Hmi:"(?z_hv~=?z_hy)"
               show FALSE
               by (rule notE [OF z_Hkd z_Hkb])
               next
               assume z_Hjb:"?z_hjb"
               assume z_Hkd:"(p~=?z_hht)"
               assume z_Hmj:"(?z_hkf~=?z_hy)"
               have z_Hmk: "?z_hjl(?z_hht)" (is "_=>?z_hml")
               by (rule zenon_all_0 [of "?z_hjl" "?z_hht", OF z_Hjf])
               show FALSE
               proof (rule zenon_imply [OF z_Hmk])
               assume z_Hmm:"(~?z_hhu)"
               show FALSE
               by (rule notE [OF z_Hmm z_Hhu])
               next
               assume z_Hml:"?z_hml"
               show FALSE
               proof (rule zenon_in_addElt [of "?z_hkf" "?z_hr" "{?z_hs, ?z_ht, ?z_hu, ?z_hv, ?z_hw, ?z_hx, ?z_hy}", OF z_Hml])
               assume z_Hmn:"(?z_hkf=?z_hr)"
               show FALSE
               by (rule notE [OF z_Hkm z_Hmn])
               next
               assume z_Hmo:"(?z_hkf \\in {?z_hs, ?z_ht, ?z_hu, ?z_hv, ?z_hw, ?z_hx, ?z_hy})" (is "?z_hmo")
               show FALSE
               proof (rule zenon_in_addElt [of "?z_hkf" "?z_hs" "{?z_ht, ?z_hu, ?z_hv, ?z_hw, ?z_hx, ?z_hy}", OF z_Hmo])
               assume z_Hmp:"(?z_hkf=?z_hs)"
               show FALSE
               by (rule notE [OF z_Hkt z_Hmp])
               next
               assume z_Hmq:"(?z_hkf \\in {?z_ht, ?z_hu, ?z_hv, ?z_hw, ?z_hx, ?z_hy})" (is "?z_hmq")
               show FALSE
               proof (rule zenon_in_addElt [of "?z_hkf" "?z_ht" "{?z_hu, ?z_hv, ?z_hw, ?z_hx, ?z_hy}", OF z_Hmq])
               assume z_Hmr:"(?z_hkf=?z_ht)"
               show FALSE
               by (rule notE [OF z_Hla z_Hmr])
               next
               assume z_Hms:"(?z_hkf \\in {?z_hu, ?z_hv, ?z_hw, ?z_hx, ?z_hy})" (is "?z_hms")
               show FALSE
               proof (rule zenon_in_addElt [of "?z_hkf" "?z_hu" "{?z_hv, ?z_hw, ?z_hx, ?z_hy}", OF z_Hms])
               assume z_Hmt:"(?z_hkf=?z_hu)"
               show FALSE
               by (rule notE [OF z_Hlh z_Hmt])
               next
               assume z_Hmu:"(?z_hkf \\in {?z_hv, ?z_hw, ?z_hx, ?z_hy})" (is "?z_hmu")
               show FALSE
               proof (rule zenon_in_addElt [of "?z_hkf" "?z_hv" "{?z_hw, ?z_hx, ?z_hy}", OF z_Hmu])
               assume z_Hmv:"(?z_hkf=?z_hv)"
               show FALSE
               by (rule notE [OF z_Hlo z_Hmv])
               next
               assume z_Hmw:"(?z_hkf \\in {?z_hw, ?z_hx, ?z_hy})" (is "?z_hmw")
               show FALSE
               proof (rule zenon_in_addElt [of "?z_hkf" "?z_hw" "{?z_hx, ?z_hy}", OF z_Hmw])
               assume z_Hmx:"(?z_hkf=?z_hw)"
               show FALSE
               by (rule notE [OF z_Hlv z_Hmx])
               next
               assume z_Hmy:"(?z_hkf \\in {?z_hx, ?z_hy})" (is "?z_hmy")
               show FALSE
               proof (rule zenon_in_addElt [of "?z_hkf" "?z_hx" "{?z_hy}", OF z_Hmy])
               assume z_Hmz:"(?z_hkf=?z_hx)"
               show FALSE
               by (rule notE [OF z_Hmc z_Hmz])
               next
               assume z_Hna:"(?z_hkf \\in {?z_hy})" (is "?z_hna")
               show FALSE
               proof (rule zenon_in_addElt [of "?z_hkf" "?z_hy" "{}", OF z_Hna])
               assume z_Hnb:"(?z_hkf=?z_hy)"
               show FALSE
               by (rule notE [OF z_Hmj z_Hnb])
               next
               assume z_Hnc:"(?z_hkf \\in {})" (is "?z_hnc")
               show FALSE
               by (rule zenon_in_emptyset [of "?z_hkf", OF z_Hnc])
               qed
               qed
               qed
               qed
               qed
               qed
               qed
               qed
               qed
               next
               assume z_Hnd:"(~?z_hjb)"
               show FALSE
               by (rule notE [OF z_Hnd z_Hjb])
               qed
               qed
               have z_Hne: "(?z_hhy=?z_hy)"
               by (rule subst [where P="(\<lambda>zenon_Vfga. (?z_hhy=zenon_Vfga))", OF z_Hmd], fact z_Hjw)
               thus "(?z_hhy=?z_hy)" .
               qed
               next
               assume z_Hnd:"(~?z_hjb)"
               show FALSE
               by (rule notE [OF z_Hnd z_Hjb])
               qed
               qed
               have z_Hnf: "(?z_hhy=?z_hx)"
               by (rule subst [where P="(\<lambda>zenon_Vfga. (?z_hhy=zenon_Vfga))", OF z_Hlw], fact z_Hjw)
               thus "(?z_hhy=?z_hx)" .
               qed
               next
               assume z_Hnd:"(~?z_hjb)"
               show FALSE
               by (rule notE [OF z_Hnd z_Hjb])
               qed
               qed
               have z_Hng: "(?z_hhy=?z_hw)"
               by (rule subst [where P="(\<lambda>zenon_Vfga. (?z_hhy=zenon_Vfga))", OF z_Hlp], fact z_Hjw)
               thus "(?z_hhy=?z_hw)" .
               qed
               next
               assume z_Hnd:"(~?z_hjb)"
               show FALSE
               by (rule notE [OF z_Hnd z_Hjb])
               qed
               qed
               have z_Hkc: "(?z_hhy=?z_hv)"
               by (rule subst [where P="(\<lambda>zenon_Vfga. (?z_hhy=zenon_Vfga))", OF z_Hli], fact z_Hjw)
               thus "(?z_hhy=?z_hv)" .
               qed
               next
               assume z_Hnd:"(~?z_hjb)"
               show FALSE
               by (rule notE [OF z_Hnd z_Hjb])
               qed
               qed
               have z_Hnh: "(?z_hhy=?z_hu)"
               by (rule subst [where P="(\<lambda>zenon_Vfga. (?z_hhy=zenon_Vfga))", OF z_Hlb], fact z_Hjw)
               thus "(?z_hhy=?z_hu)" .
              qed
             next
              assume z_Hnd:"(~?z_hjb)"
              show FALSE
              by (rule notE [OF z_Hnd z_Hjb])
             qed
            qed
            have z_Hni: "(?z_hhy=?z_ht)"
            by (rule subst [where P="(\<lambda>zenon_Vfga. (?z_hhy=zenon_Vfga))", OF z_Hku], fact z_Hjw)
            thus "(?z_hhy=?z_ht)" .
           qed
          next
           assume z_Hnd:"(~?z_hjb)"
           show FALSE
           by (rule notE [OF z_Hnd z_Hjb])
          qed
         qed
         have z_Hnj: "(?z_hhy=?z_hs)"
         by (rule subst [where P="(\<lambda>zenon_Vfga. (?z_hhy=zenon_Vfga))", OF z_Hkn], fact z_Hjw)
         thus "(?z_hhy=?z_hs)" .
        qed
       next
        assume z_Hnd:"(~?z_hjb)"
        show FALSE
        by (rule notE [OF z_Hnd z_Hjb])
       qed
      qed
      have z_Hnk: "(?z_hhy=?z_hr)"
      by (rule subst [where P="(\<lambda>zenon_Vfga. (?z_hhy=zenon_Vfga))", OF z_Hkg], fact z_Hjw)
      thus "(?z_hhy=?z_hr)" .
     qed
    next
     assume z_Hnd:"(~?z_hjb)"
     show FALSE
     by (rule notE [OF z_Hnd z_Hjb])
    qed
   qed
  next
   assume z_Hnl:"((j[p])~=((l[p]) +  -.(1)))" (is "?z_hdu~=?z_hdx")
   assume z_Hej:"((a_jhash_primea=except(j, p, (?z_hdu + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M)))" (is "?z_hek&?z_hen")
   have z_Hen: "?z_hen" (is "?z_heo&?z_heh")
   by (rule zenon_and_1 [OF z_Hej])
   have z_Heo: "?z_heo"
   by (rule zenon_and_0 [OF z_Hen])
   show FALSE
   proof (rule notE [OF z_Hl])
    have z_Hnm: "(pc=a_pchash_primea)"
    by (rule sym [OF z_Heo])
    have z_Hgi: "?z_hgi"
    by (rule subst [where P="(\<lambda>zenon_Vwsk. (zenon_Vwsk \\in FuncSet(ProcSet, {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''})))", OF z_Hnm], fact z_Hm)
    thus "?z_hgi" .
   qed
  qed
 next
  assume z_Hnq:"((Q[(j[p])])~=BOT)" (is "?z_hdt~=_")
  assume z_Hep:"((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))))))" (is "?z_heq&?z_hes")
  have z_Heq: "?z_heq" (is "_=?z_her")
  by (rule zenon_and_0 [OF z_Hep])
  show FALSE
  proof (rule zenon_notin_funcset [of "a_pchash_primea" "ProcSet" "{''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}", OF z_Hl])
   assume z_Hgn:"(~isAFcn(a_pchash_primea))" (is "~?z_hgo")
   have z_Hnr: "(~isAFcn(?z_her))" (is "~?z_hns")
   by (rule subst [where P="(\<lambda>zenon_Vzva. (~isAFcn(zenon_Vzva)))", OF z_Heq z_Hgn])
   show FALSE
   by (rule zenon_notisafcn_except [of "pc" "p" "''D4''", OF z_Hnr])
  next
   assume z_Hgv:"(DOMAIN(a_pchash_primea)~=ProcSet)" (is "?z_hgw~=_")
   have z_Hnt: "(DOMAIN(?z_her)~=ProcSet)" (is "?z_hnu~=_")
   by (rule subst [where P="(\<lambda>zenon_Vdwa. (DOMAIN(zenon_Vdwa)~=ProcSet))", OF z_Heq z_Hgv])
   have z_Hhd: "(?z_hgk~=ProcSet)"
   by (rule zenon_domain_except_0 [of "(\<lambda>zenon_Vcwa. (zenon_Vcwa~=ProcSet))" "pc" "p" "''D4''", OF z_Hnt])
   show FALSE
   by (rule notE [OF z_Hhd z_Hgj])
  next
   assume z_Hhh:"(~(\\A zenon_Vh:((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))))" (is "~(\\A x : ?z_hho(x))")
   have z_Hhp: "(\\E zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))))" (is "\\E x : ?z_hhr(x)")
   by (rule zenon_notallex_0 [of "?z_hho", OF z_Hhh])
   have z_Hhs: "?z_hhr((CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''})))))" (is "~(?z_hhu=>?z_hhv)")
   by (rule zenon_ex_choose_0 [of "?z_hhr", OF z_Hhp])
   have z_Hhu: "?z_hhu"
   by (rule zenon_notimply_0 [OF z_Hhs])
   have z_Hhw: "(~?z_hhv)"
   by (rule zenon_notimply_1 [OF z_Hhs])
   have z_Hia: "(~((a_pchash_primea[(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))))]) \\in {''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))" (is "~?z_hib")
   by (rule zenon_notin_addElt_1 [of "(a_pchash_primea[(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))))])" "''L0''" "{''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}", OF z_Hhw])
   have z_Hie: "(~((a_pchash_primea[(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))))]) \\in {''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))" (is "~?z_hif")
   by (rule zenon_notin_addElt_1 [of "(a_pchash_primea[(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))))])" "''E1''" "{''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}", OF z_Hia])
   have z_Hii: "(~((a_pchash_primea[(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))))]) \\in {''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))" (is "~?z_hij")
   by (rule zenon_notin_addElt_1 [of "(a_pchash_primea[(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))))])" "''E2''" "{''E3'', ''D1'', ''D2'', ''D3'', ''D4''}", OF z_Hie])
   have z_Him: "(~((a_pchash_primea[(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))))]) \\in {''D1'', ''D2'', ''D3'', ''D4''}))" (is "~?z_hin")
   by (rule zenon_notin_addElt_1 [of "(a_pchash_primea[(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))))])" "''E3''" "{''D1'', ''D2'', ''D3'', ''D4''}", OF z_Hii])
   have z_Hiq: "(~((a_pchash_primea[(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))))]) \\in {''D2'', ''D3'', ''D4''}))" (is "~?z_hir")
   by (rule zenon_notin_addElt_1 [of "(a_pchash_primea[(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))))])" "''D1''" "{''D2'', ''D3'', ''D4''}", OF z_Him])
   have z_Hiu: "(~((a_pchash_primea[(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))))]) \\in {''D3'', ''D4''}))" (is "~?z_hiv")
   by (rule zenon_notin_addElt_1 [of "(a_pchash_primea[(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))))])" "''D2''" "{''D3'', ''D4''}", OF z_Hiq])
   have z_Hix: "(~((a_pchash_primea[(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))))]) \\in {''D4''}))" (is "~?z_hiy")
   by (rule zenon_notin_addElt_1 [of "(a_pchash_primea[(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))))])" "''D3''" "{''D4''}", OF z_Hiu])
   have z_Hiz: "((a_pchash_primea[(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))))])~=''D4'')" (is "?z_hhy~=?z_hy")
   by (rule zenon_notin_addElt_0 [of "?z_hhy" "?z_hy" "{}", OF z_Hix])
   have z_Hjb: "((CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ?z_hy})))) \\in ?z_hgk)" (is "?z_hjb")
   by (rule ssubst [where P="(\<lambda>zenon_Vji. ((CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ?z_hy})))) \\in zenon_Vji))", OF z_Hgj z_Hhu])
   have z_Hjf: "(\\A zenon_Vma:((zenon_Vma \\in ProcSet)=>((pc[zenon_Vma]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ?z_hy})))" (is "\\A x : ?z_hjl(x)")
   by (rule zenon_in_funcset_2 [of "pc" "ProcSet" "{''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ?z_hy}", OF z_Hm])
   have z_Hmk: "?z_hjl((CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ?z_hy})))))" (is "_=>?z_hml")
   by (rule zenon_all_0 [of "?z_hjl" "(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ?z_hy}))))", OF z_Hjf])
   show FALSE
   proof (rule zenon_imply [OF z_Hmk])
    assume z_Hmm:"(~?z_hhu)"
    show FALSE
    by (rule notE [OF z_Hmm z_Hhu])
   next
    assume z_Hml:"?z_hml"
    show FALSE
    proof (rule notE [OF z_Hhw])
     have z_Hnv: "((pc[(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ?z_hy}))))])=?z_hhy)" (is "?z_hkf=_")
     proof (rule zenon_nnpp [of "(?z_hkf=?z_hhy)"])
      assume z_Hnw:"(?z_hkf~=?z_hhy)"
      have z_Hnx: "(((isAFcn(a_pchash_primea)<=>isAFcn(?z_her))&(DOMAIN(a_pchash_primea)=DOMAIN(?z_her)))&(\\A zenon_Vfd:((a_pchash_primea[zenon_Vfd])=(?z_her[zenon_Vfd]))))" (is "?z_hny&?z_hob")
      by (rule zenon_funequal_0 [of "a_pchash_primea" "?z_her", OF z_Heq])
      have z_Hob: "?z_hob" (is "\\A x : ?z_hog(x)")
      by (rule zenon_and_1 [OF z_Hnx])
      have z_Hoh: "?z_hog((CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ?z_hy})))))" (is "_=?z_hoi")
      by (rule zenon_all_0 [of "?z_hog" "(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ?z_hy}))))", OF z_Hob])
      show FALSE
      proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vfga. (?z_hhy=zenon_Vfga))" "pc" "p" "?z_hy" "(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ?z_hy}))))", OF z_Hoh])
       assume z_Hjb:"?z_hjb"
       assume z_Hkb:"(p=(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ?z_hy})))))" (is "_=?z_hht")
       assume z_Hne:"(?z_hhy=?z_hy)"
       show FALSE
       by (rule notE [OF z_Hiz z_Hne])
      next
       assume z_Hjb:"?z_hjb"
       assume z_Hkd:"(p~=(CHOOSE zenon_Vh:(~((zenon_Vh \\in ProcSet)=>((a_pchash_primea[zenon_Vh]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ?z_hy})))))" (is "_~=?z_hht")
       assume z_Hke:"(?z_hhy=?z_hkf)"
       show FALSE
       by (rule zenon_eqsym [OF z_Hke z_Hnw])
      next
       assume z_Hnd:"(~?z_hjb)"
       show FALSE
       by (rule notE [OF z_Hnd z_Hjb])
      qed
     qed
     have z_Hhv: "?z_hhv"
     by (rule subst [where P="(\<lambda>zenon_Vxsk. (zenon_Vxsk \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ?z_hy}))", OF z_Hnv], fact z_Hml)
     thus "?z_hhv" .
    qed
   qed
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 51"; *} qed
lemma ob'110:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition PosInts suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition InvNL suppressed *)
assumes v'204: "(InvNL)"
(* usable definition A suppressed *)
fixes seq
assumes seq_in : "(seq \<in> ([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) \<rightarrow> (A)]))"
fixes w
assumes w_in : "(w \<in> (A))"
assumes v'220: "(\<forall> q \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) : (((fapply ((seq), (q))) \<noteq> (w))))"
assumes v'233: "(((w) \<notin> (setOfAll(((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))), %k. (fapply ((seq), (k)))))))"
assumes v'234: "((IsFiniteSet ((setOfAll(((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))), %k. (fapply ((seq), (k))))))))"
assumes v'235: "((\<And> S :: c. (\<And> x_1 :: c. (((IsFiniteSet ((S)))) \<Longrightarrow> (((IsFiniteSet ((((S) \<union> ({(x_1)})))))) & ((((Cardinality ((((S) \<union> ({(x_1)})))))) = (cond((((x_1) \<in> (S))), ((Cardinality ((S)))), ((arith_add (((Cardinality ((S)))), ((Succ[0]))))))))))))))"
shows "((((Cardinality ((((setOfAll(((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))), %k. (fapply ((seq), (k))))) \<union> ({(w)})))))) = ((arith_add (((Cardinality ((setOfAll(((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))), %k. (fapply ((seq), (k)))))))), ((Succ[0])))))))"(is "PROP ?ob'110")
proof -
ML_command {* writeln "*** TLAPS ENTER 110"; *}
show "PROP ?ob'110"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_69114c.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_69114c.znn.out
;; obligation #110
$hyp "v'204" InvNL
$hyp "seq_in" (TLA.in seq (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) A))
$hyp "w_in" (TLA.in w A)
$hyp "v'220" (TLA.bAll (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) ((q) (-. (= (TLA.fapply seq q)
w))))
$hyp "v'233" (-. (TLA.in w
(TLA.setOfAll (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) ((k) (TLA.fapply seq k)))))
$hyp "v'234" (IsFiniteSet (TLA.setOfAll (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) ((k) (TLA.fapply seq k))))
$hyp "v'235" (A. ((S) (A. ((x_1) (=> (IsFiniteSet S) (/\ (IsFiniteSet (TLA.cup S
(TLA.set x_1))) (= (Cardinality (TLA.cup S (TLA.set x_1)))
(TLA.cond (TLA.in x_1 S) (Cardinality S) (arith.add (Cardinality S)
(TLA.fapply TLA.Succ 0))))))))))
$goal (= (Cardinality (TLA.cup (TLA.setOfAll (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) ((k) (TLA.fapply seq k))) (TLA.set w)))
(arith.add (Cardinality (TLA.setOfAll (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) ((k) (TLA.fapply seq k))))
(TLA.fapply TLA.Succ 0)))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hg:"(\\A S:(\\A x_1:(IsFiniteSet(S)=>(IsFiniteSet((S \\cup {x_1}))&(Cardinality((S \\cup {x_1}))=cond((x_1 \\in S), Cardinality(S), (Cardinality(S) + 1)))))))" (is "\\A x : ?z_hy(x)")
 using v'235 by blast
 have z_He:"(~(w \\in setOfAll(isa'dotdot(1, Cardinality(A)), (\<lambda>k. (seq[k])))))" (is "~?z_hz")
 using v'233 by blast
 have z_Hf:"IsFiniteSet(setOfAll(isa'dotdot(1, Cardinality(A)), (\<lambda>k. (seq[k]))))" (is "?z_hf")
 using v'234 by blast
 assume z_Hh:"(Cardinality((setOfAll(isa'dotdot(1, Cardinality(A)), (\<lambda>k. (seq[k]))) \\cup {w}))~=(Cardinality(setOfAll(isa'dotdot(1, Cardinality(A)), (\<lambda>k. (seq[k])))) + 1))" (is "?z_hbj~=?z_hbm")
 have z_Hbo: "?z_hy(setOfAll(isa'dotdot(1, Cardinality(A)), (\<lambda>k. (seq[k]))))" (is "\\A x : ?z_hbp(x)")
 by (rule zenon_all_0 [of "?z_hy" "setOfAll(isa'dotdot(1, Cardinality(A)), (\<lambda>k. (seq[k])))", OF z_Hg])
 have z_Hbq: "?z_hbp(w)" (is "_=>?z_hbr")
 by (rule zenon_all_0 [of "?z_hbp" "w", OF z_Hbo])
 show FALSE
 proof (rule zenon_imply [OF z_Hbq])
  assume z_Hbs:"(~?z_hf)"
  show FALSE
  by (rule notE [OF z_Hbs z_Hf])
 next
  assume z_Hbr:"?z_hbr" (is "?z_hbt&?z_hbu")
  have z_Hbu: "?z_hbu" (is "_=?z_hbv")
  by (rule zenon_and_1 [OF z_Hbr])
  show FALSE
  proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vtb. (?z_hbj=zenon_Vtb))" "?z_hz" "Cardinality(setOfAll(isa'dotdot(1, Cardinality(A)), (\<lambda>k. (seq[k]))))" "?z_hbm", OF z_Hbu])
   assume z_Hz:"?z_hz"
   assume z_Hbz:"(?z_hbj=Cardinality(setOfAll(isa'dotdot(1, Cardinality(A)), (\<lambda>k. (seq[k])))))" (is "_=?z_hbn")
   show FALSE
   by (rule notE [OF z_He z_Hz])
  next
   assume z_He:"(~?z_hz)"
   assume z_Hca:"(?z_hbj=?z_hbm)"
   show FALSE
   by (rule notE [OF z_Hh z_Hca])
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 110"; *} qed
lemma ob'142:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition PosInts suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition InvNL suppressed *)
assumes v'204: "(InvNL)"
(* usable definition A suppressed *)
fixes seq
assumes seq_in : "(seq \<in> ([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) \<rightarrow> (A)]))"
fixes w
assumes w_in : "(w \<in> (A))"
assumes v'220: "(\<forall> q \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) : (((fapply ((seq), (q))) \<noteq> (w))))"
fixes a_k1a
assumes a_k1a_in : "(a_k1a \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_k2a
assumes a_k2a_in : "(a_k2a \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
assumes v'241: "(((a_k1a) \<noteq> (a_k2a)))"
assumes v'242: "(((fapply ((seq), (a_k1a))) = (fapply ((seq), (a_k2a)))))"
assumes v'243: "((greater ((fapply ((seq), (a_k1a))), (fapply ((seq), (a_k2a))))))"
shows "(FALSE)"(is "PROP ?ob'142")
proof -
ML_command {* writeln "*** TLAPS ENTER 142"; *}
show "PROP ?ob'142"
using assms by auto
ML_command {* writeln "*** TLAPS EXIT 142"; *} qed
lemma ob'135:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition PosInts suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition InvNL suppressed *)
assumes v'204: "(InvNL)"
(* usable definition A suppressed *)
fixes seq
assumes seq_in : "(seq \<in> ([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) \<rightarrow> (A)]))"
fixes w
assumes w_in : "(w \<in> (A))"
assumes v'220: "(\<forall> q \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) : (((fapply ((seq), (q))) \<noteq> (w))))"
fixes a_k1a
assumes a_k1a_in : "(a_k1a \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_k2a
assumes a_k2a_in : "(a_k2a \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
assumes v'240: "(((a_k1a) \<noteq> (a_k2a)))"
assumes v'241: "(((fapply ((seq), (a_k1a))) = (fapply ((seq), (a_k2a)))))"
assumes v'242: "((less ((fapply ((seq), (a_k1a))), (fapply ((seq), (a_k2a))))))"
shows "(FALSE)"(is "PROP ?ob'135")
proof -
ML_command {* writeln "*** TLAPS ENTER 135"; *}
show "PROP ?ob'135"
using assms by auto
ML_command {* writeln "*** TLAPS EXIT 135"; *} qed
lemma ob'128:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition PosInts suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition InvNL suppressed *)
assumes v'204: "(InvNL)"
(* usable definition A suppressed *)
fixes seq
assumes seq_in : "(seq \<in> ([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) \<rightarrow> (A)]))"
fixes w
assumes w_in : "(w \<in> (A))"
assumes v'220: "(\<forall> q \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) : (((fapply ((seq), (q))) \<noteq> (w))))"
assumes v'233: "((\<And> S :: c. (((IsFiniteSet ((S)))) \<Longrightarrow> (\<And> T :: c. (((IsFiniteSet ((T)))) \<Longrightarrow> (((less (((Cardinality ((T)))), ((Cardinality ((S))))))) \<Longrightarrow> (\<And> f :: c. f \<in> ([(S) \<rightarrow> (T)]) \<Longrightarrow> (\<exists> x_1 \<in> (S) : (\<exists> y \<in> (S) : (((((x_1) \<noteq> (y))) \<and> (((fapply ((f), (x_1))) = (fapply ((f), (y))))))))))))))))"
assumes v'234: "(((seq) \<in> ([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) \<rightarrow> (setOfAll(((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))), %k. (fapply ((seq), (k)))))])))"
assumes v'235: "((IsFiniteSet ((setOfAll(((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))), %k. (fapply ((seq), (k))))))))"
assumes v'236: "((IsFiniteSet (((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))))"
assumes v'237: "((less (((Cardinality ((setOfAll(((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))), %k. (fapply ((seq), (k)))))))), ((Cardinality (((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A)))))))))))))"
shows "(\<exists> a_k1a \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) : (\<exists> a_k2a \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) : (((((a_k1a) \<noteq> (a_k2a))) \<and> (((fapply ((seq), (a_k1a))) = (fapply ((seq), (a_k2a)))))))))"(is "PROP ?ob'128")
proof -
ML_command {* writeln "*** TLAPS ENTER 128"; *}
show "PROP ?ob'128"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_6b794e.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_6b794e.znn.out
;; obligation #128
$hyp "v'204" InvNL
$hyp "seq_in" (TLA.in seq (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) A))
$hyp "w_in" (TLA.in w A)
$hyp "v'220" (TLA.bAll (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) ((q) (-. (= (TLA.fapply seq q)
w))))
$hyp "v'233" (A. ((S) (=> (IsFiniteSet S) (A. ((T) (=> (IsFiniteSet T) (=> (arith.lt (Cardinality T)
(Cardinality S)) (TLA.bAll (TLA.FuncSet S T) ((f) (TLA.bEx S ((x_1) (TLA.bEx S ((y) (/\ (-. (= x_1
y)) (= (TLA.fapply f x_1)
(TLA.fapply f y))))))))))))))))
$hyp "v'234" (TLA.in seq (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) (TLA.setOfAll (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) ((k) (TLA.fapply seq k)))))
$hyp "v'235" (IsFiniteSet (TLA.setOfAll (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) ((k) (TLA.fapply seq k))))
$hyp "v'236" (IsFiniteSet (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "v'237" (arith.lt (Cardinality (TLA.setOfAll (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) ((k) (TLA.fapply seq k))))
(Cardinality (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A))))
$goal (TLA.bEx (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) ((a_k1a) (TLA.bEx (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) ((a_k2a) (/\ (-. (= a_k1a a_k2a)) (= (TLA.fapply seq a_k1a)
(TLA.fapply seq a_k2a)))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_He:"(\\A S:(IsFiniteSet(S)=>(\\A T:(IsFiniteSet(T)=>((Cardinality(T) < Cardinality(S))=>bAll(FuncSet(S, T), (\<lambda>f. bEx(S, (\<lambda>x_1. bEx(S, (\<lambda>y. ((x_1~=y)&((f[x_1])=(f[y]))))))))))))))" (is "\\A x : ?z_hbk(x)")
 using v'233 by blast
 have z_Hh:"IsFiniteSet(isa'dotdot(1, Cardinality(A)))" (is "?z_hh")
 using v'236 by blast
 have z_Hg:"IsFiniteSet(setOfAll(isa'dotdot(1, Cardinality(A)), (\<lambda>k. (seq[k]))))" (is "?z_hg")
 using v'235 by blast
 have z_Hi:"(Cardinality(setOfAll(isa'dotdot(1, Cardinality(A)), (\<lambda>k. (seq[k])))) < Cardinality(isa'dotdot(1, Cardinality(A))))" (is "?z_hi")
 using v'237 by blast
 have z_Hf:"(seq \\in FuncSet(isa'dotdot(1, Cardinality(A)), setOfAll(isa'dotdot(1, Cardinality(A)), (\<lambda>k. (seq[k])))))" (is "?z_hf")
 using v'234 by blast
 assume z_Hj:"(~bEx(isa'dotdot(1, Cardinality(A)), (\<lambda>a_k1a. bEx(isa'dotdot(1, Cardinality(A)), (\<lambda>a_k2a. ((a_k1a~=a_k2a)&((seq[a_k1a])=(seq[a_k2a]))))))))" (is "~?z_hbx")
 have z_Hci: "?z_hbk(isa'dotdot(1, Cardinality(A)))" (is "_=>?z_hcj")
 by (rule zenon_all_0 [of "?z_hbk" "isa'dotdot(1, Cardinality(A))", OF z_He])
 show FALSE
 proof (rule zenon_imply [OF z_Hci])
  assume z_Hck:"(~?z_hh)"
  show FALSE
  by (rule notE [OF z_Hck z_Hh])
 next
  assume z_Hcj:"?z_hcj" (is "\\A x : ?z_hcl(x)")
  have z_Hcm: "?z_hcl(setOfAll(isa'dotdot(1, Cardinality(A)), (\<lambda>k. (seq[k]))))" (is "_=>?z_hcn")
  by (rule zenon_all_0 [of "?z_hcl" "setOfAll(isa'dotdot(1, Cardinality(A)), (\<lambda>k. (seq[k])))", OF z_Hcj])
  show FALSE
  proof (rule zenon_imply [OF z_Hcm])
   assume z_Hco:"(~?z_hg)"
   show FALSE
   by (rule notE [OF z_Hco z_Hg])
  next
   assume z_Hcn:"?z_hcn" (is "_=>?z_hcp")
   show FALSE
   proof (rule zenon_imply [OF z_Hcn])
    assume z_Hcq:"(~?z_hi)"
    show FALSE
    by (rule notE [OF z_Hcq z_Hi])
   next
    assume z_Hcp:"?z_hcp"
    have z_Hbx: "?z_hbx"
    by (rule zenon_all_in_0 [of "FuncSet(isa'dotdot(1, Cardinality(A)), setOfAll(isa'dotdot(1, Cardinality(A)), (\<lambda>k. (seq[k]))))" "(\<lambda>f. bEx(isa'dotdot(1, Cardinality(A)), (\<lambda>x_1. bEx(isa'dotdot(1, Cardinality(A)), (\<lambda>y. ((x_1~=y)&((f[x_1])=(f[y]))))))))", OF z_Hcp z_Hf])
    show FALSE
    by (rule notE [OF z_Hj z_Hbx])
   qed
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 128"; *} qed
lemma ob'54:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
assumes v'184: "((((pc) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & (((X) \<in> (((Nat) \\ ({((0))}))))) & (((Q) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((i) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((j) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((l) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((x) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((v) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((M) \<in> ((SUBSET (subsetOf(([''sigma'' : ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))]))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %a_ca. (\<forall> p \<in> (ProcSet) : ((((((fapply ((pc), (p))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p))) = (BOT))))) & (((((fapply ((pc), (p))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p))) \<in> ({(ACK), (BOT)}))))) & (((((fapply ((pc), (p))) \<in> ({(''D4'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)}))))))))))))))))"
assumes v'185: "(((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'198: "(cond((((fapply ((Q), (fapply ((j), (p))))) = (BOT))), (cond((((fapply ((j), (p))) = ((arith_add ((fapply ((l), (p))), ((minus (((Succ[0])))))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & (((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (M))))), (((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((arith_add ((fapply ((j), (p))), ((Succ[0])))))]))) & (((((a_pchash_primea :: c)) = (pc))) & ((((a_Mhash_primea :: c)) = (M))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D4'')]))) & ((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (subsetOf(([''sigma'' : ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))]))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %d. ((\<forall> p_1 \<in> (ProcSet) : ((((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (p_1))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (p_1))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''D4'')}))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (p_1))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)}))))))))) & (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((d), (''fres''))), (p))) = ((Head ((fapply ((a_ca), (''sigma'')))))))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = ((Tail ((fapply ((a_ca), (''sigma''))))))))))))))))))"
assumes v'199: "(((fapply ((pc), (p))) = (''D3'')))"
assumes v'200: "((((a_xhash_primea :: c)) = ([(x) EXCEPT ![(p)] = (fapply ((Q), (fapply ((j), (p)))))])))"
assumes v'201: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((j), (p)))] = (BOT)])))"
assumes v'202: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'203: "((((a_ihash_primea :: c)) = (i)))"
assumes v'204: "((((a_lhash_primea :: c)) = (l)))"
assumes v'205: "((((a_vhash_primea :: c)) = (v)))"
shows "((((a_Mhash_primea :: c)) \<in> ((SUBSET (subsetOf(([''sigma'' : ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))]))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %a_ca. (\<forall> p_1 \<in> (ProcSet) : ((((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''D4'')}))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''fres''))), (p_1))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))))))))))))))"(is "PROP ?ob'54")
proof -
ML_command {* writeln "*** TLAPS ENTER 54"; *}
show "PROP ?ob'54"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_e5d7c1.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_e5d7c1.znn.out
;; obligation #54
$hyp "v'184" (/\ (TLA.in pc
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in X (TLA.setminus arith.N (TLA.set 0))) (TLA.in Q
(TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in i (TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in j
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in l
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in x
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in v (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in M
(TLA.SUBSET (TLA.subsetOf (TLA.recordset "sigma" (TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))) ((a_ca) (TLA.bAll ProcSet ((p) (/\ (=> (TLA.in (TLA.fapply pc p)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply a_ca "fres") p) BOT))
(=> (TLA.in (TLA.fapply pc p) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p) (TLA.set ACK BOT)))
(=> (TLA.in (TLA.fapply pc p) (TLA.set "D4"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT))))))))))))
$hyp "v'185" (\/ Next (= a_h4fd5f73954dc53af536c1c75068837a
vars))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'198" (TLA.cond (= (TLA.fapply Q (TLA.fapply j p))
BOT) (TLA.cond (= (TLA.fapply j p) (arith.add (TLA.fapply l p)
(arith.minus (TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea
(TLA.except pc p "D1")) (/\ (= a_jhash_primea j) (= a_Mhash_primea
M))) (/\ (= a_jhash_primea (TLA.except j p (arith.add (TLA.fapply j p)
(TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea pc) (= a_Mhash_primea
M)))) (/\ (= a_pchash_primea (TLA.except pc p "D4")) (= a_jhash_primea j)
(= a_Mhash_primea
(TLA.subsetOf (TLA.recordset "sigma" (TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))) ((d) (/\ (TLA.bAll ProcSet ((p_1) (/\ (=> (TLA.in (TLA.fapply a_pchash_primea p_1)
(TLA.set "L0" "E1" "D1" "D2" "D3")) (= (TLA.fapply (TLA.fapply d "fres") p_1)
BOT)) (=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply d "fres") p_1) (TLA.set ACK BOT)))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "D4"))
(TLA.in (TLA.fapply (TLA.fapply d "fres") p_1) (TLA.cup (TLA.setminus arith.N
(TLA.set 0)) (TLA.set BOT)))))))
(TLA.bEx M ((a_ca) (/\ (= (TLA.fapply (TLA.fapply d "fres") p)
(Head (TLA.fapply a_ca "sigma"))) (TLA.bAll ProcSet ((q) (=> (-. (= q p))
(= (TLA.fapply (TLA.fapply d "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))) (= (TLA.fapply d "sigma")
(Tail (TLA.fapply a_ca "sigma"))))))))))))
$hyp "v'199" (= (TLA.fapply pc p) "D3")
$hyp "v'200" (= a_xhash_primea
(TLA.except x p (TLA.fapply Q (TLA.fapply j p))))
$hyp "v'201" (= a_Qhash_primea
(TLA.except Q (TLA.fapply j p) BOT))
$hyp "v'202" (= a_Xhash_primea X)
$hyp "v'203" (= a_ihash_primea i)
$hyp "v'204" (= a_lhash_primea l)
$hyp "v'205" (= a_vhash_primea v)
$goal (TLA.in a_Mhash_primea
(TLA.SUBSET (TLA.subsetOf (TLA.recordset "sigma" (TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))) ((a_ca) (TLA.bAll ProcSet ((p_1) (/\ (=> (TLA.in (TLA.fapply a_pchash_primea p_1)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply a_ca "fres") p_1) BOT))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p_1) (TLA.set ACK BOT)))
(=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "D4"))
(TLA.in (TLA.fapply (TLA.fapply a_ca "fres") p_1)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Ha:"((pc \\in FuncSet(ProcSet, {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))&((X \\in (Nat \\ {0}))&((Q \\in FuncSet((Nat \\ {0}), ((Nat \\ {0}) \\cup {BOT})))&((i \\in FuncSet(ProcSet, (Nat \\ {0})))&((j \\in FuncSet(ProcSet, (Nat \\ {0})))&((l \\in FuncSet(ProcSet, (Nat \\ {0})))&((x \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {BOT})))&((v \\in FuncSet(ProcSet, (Nat \\ {0})))&(M \\in SUBSET(subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((a_ca[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>(((a_ca[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))))))))" (is "?z_hm&?z_hz")
 using v'184 by blast
 have z_He:"((pc[p])=''D3'')" (is "?z_hdc=?z_hx")
 using v'199 by blast
 have z_Hd:"cond(((Q[(j[p])])=BOT), cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M)))), ((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma'']))))))))))))))" (is "?z_hd")
 using v'198 by blast
 have zenon_L1_: "(a_Mhash_primea=M) ==> (~((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))) \\in M)) ==> ((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))) \\in a_Mhash_primea) ==> FALSE" (is "?z_heh ==> ?z_hgi ==> ?z_hhc ==> FALSE")
 proof -
  assume z_Heh:"?z_heh"
  assume z_Hgi:"?z_hgi" (is "~?z_hgj")
  assume z_Hhc:"?z_hhc"
  have z_Hhd: "(~?z_hhc)"
  by (rule ssubst [where P="(\<lambda>zenon_Vfpc. (~((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))) \\in zenon_Vfpc)))", OF z_Heh z_Hgi])
  show FALSE
  by (rule notE [OF z_Hhd z_Hhc])
 qed
 have zenon_L2_: "((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))) \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>(((a_ca[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))) ==> (~((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))) \\in [''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))])) ==> FALSE" (is "?z_hhi ==> ?z_hhj ==> FALSE")
 proof -
  assume z_Hhi:"?z_hhi"
  assume z_Hhj:"?z_hhj" (is "~?z_hhk")
  have z_Hhk: "?z_hhk"
  by (rule zenon_in_subsetof_0 [of "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))" "[''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))]" "(\<lambda>a_ca. bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>(((a_ca[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hhi])
  show FALSE
  by (rule notE [OF z_Hhj z_Hhk])
 qed
 have zenon_L3_: "(\\A x:((x \\in M)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>(((a_ca[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))) ==> (a_Mhash_primea=M) ==> ((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))) \\in a_Mhash_primea) ==> (~((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))) \\in [''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))])) ==> FALSE" (is "?z_hhl ==> ?z_heh ==> ?z_hhc ==> ?z_hhj ==> FALSE")
 proof -
  assume z_Hhl:"?z_hhl" (is "\\A x : ?z_hhp(x)")
  assume z_Heh:"?z_heh"
  assume z_Hhc:"?z_hhc"
  assume z_Hhj:"?z_hhj" (is "~?z_hhk")
  have z_Hhq: "?z_hhp((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))))" (is "?z_hgj=>?z_hhi")
  by (rule zenon_all_0 [of "?z_hhp" "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))", OF z_Hhl])
  show FALSE
  proof (rule zenon_imply [OF z_Hhq])
   assume z_Hgi:"(~?z_hgj)"
   show FALSE
   by (rule zenon_L1_ [OF z_Heh z_Hgi z_Hhc])
  next
   assume z_Hhi:"?z_hhi"
   show FALSE
   by (rule zenon_L2_ [OF z_Hhi z_Hhj])
  qed
 qed
 have zenon_L4_: "(\\A x:((x \\in ProcSet)=>((((pc[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((pc[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((pc[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))) ==> ((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))) \\in ProcSet) ==> ((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''E1'') ==> ((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=BOT) ==> FALSE" (is "?z_hhr ==> ?z_hii ==> ?z_hiv ==> ?z_hix ==> FALSE")
 proof -
  assume z_Hhr:"?z_hhr" (is "\\A x : ?z_hiz(x)")
  assume z_Hii:"?z_hii"
  assume z_Hiv:"?z_hiv" (is "?z_hiw=?z_hs")
  assume z_Hix:"?z_hix" (is "?z_hiy~=_")
  have z_Hja: "?z_hiz((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))" (is "_=>?z_hjb")
  by (rule zenon_all_0 [of "?z_hiz" "(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hhr])
  show FALSE
  proof (rule zenon_imply [OF z_Hja])
   assume z_Hjc:"(~?z_hii)"
   show FALSE
   by (rule notE [OF z_Hjc z_Hii])
  next
   assume z_Hjb:"?z_hjb" (is "?z_hjd&?z_hje")
   have z_Hjd: "?z_hjd" (is "?z_hjf=>?z_hjg")
   by (rule zenon_and_0 [OF z_Hjb])
   show FALSE
   proof (rule zenon_imply [OF z_Hjd])
    assume z_Hjh:"(~?z_hjf)"
    have z_Hji: "(~(?z_hiw \\in {?z_hs, ''D1'', ''D2'', ?z_hx}))" (is "~?z_hjj")
    by (rule zenon_notin_addElt_1 [of "?z_hiw" "''L0''" "{?z_hs, ''D1'', ''D2'', ?z_hx}", OF z_Hjh])
    have z_Hjl: "(?z_hiw~=?z_hs)"
    by (rule zenon_notin_addElt_0 [of "?z_hiw" "?z_hs" "{''D1'', ''D2'', ?z_hx}", OF z_Hji])
    show FALSE
    by (rule notE [OF z_Hjl z_Hiv])
   next
    assume z_Hjg:"?z_hjg"
    show FALSE
    by (rule notE [OF z_Hix z_Hjg])
   qed
  qed
 qed
 have zenon_L5_: "(DOMAIN(pc)=ProcSet) ==> ((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=(a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])) ==> ((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))~=p) ==> ((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))) \\in ProcSet) ==> (a_pchash_primea=except(pc, p, ''D1'')) ==> FALSE" (is "?z_hjn ==> ?z_hjp ==> ?z_hjr ==> ?z_hii ==> ?z_heb ==> FALSE")
 proof -
  assume z_Hjn:"?z_hjn" (is "?z_hjo=_")
  assume z_Hjp:"?z_hjp" (is "?z_hiw~=?z_hjq")
  assume z_Hjr:"?z_hjr" (is "?z_hij~=_")
  assume z_Hii:"?z_hii"
  assume z_Heb:"?z_heb" (is "_=?z_hed")
  have z_Hjs: "(\\A zenon_Vwc:((zenon_Vwc \\in ?z_hjo)<=>(zenon_Vwc \\in ProcSet)))" (is "\\A x : ?z_hjx(x)")
  by (rule zenon_setequal_0 [of "?z_hjo" "ProcSet", OF z_Hjn])
  have z_Hjy: "(((isAFcn(a_pchash_primea)<=>isAFcn(?z_hed))&(DOMAIN(a_pchash_primea)=DOMAIN(?z_hed)))&(\\A zenon_Vlpc:((a_pchash_primea[zenon_Vlpc])=(?z_hed[zenon_Vlpc]))))" (is "?z_hjz&?z_hkg")
  by (rule zenon_funequal_0 [of "a_pchash_primea" "?z_hed", OF z_Heb])
  have z_Hkg: "?z_hkg" (is "\\A x : ?z_hkl(x)")
  by (rule zenon_and_1 [OF z_Hjy])
  have z_Hkm: "?z_hjx(?z_hij)" (is "?z_hkn<=>_")
  by (rule zenon_all_0 [of "?z_hjx" "?z_hij", OF z_Hjs])
  show FALSE
  proof (rule zenon_equiv [OF z_Hkm])
   assume z_Hko:"(~?z_hkn)"
   assume z_Hjc:"(~?z_hii)"
   show FALSE
   by (rule notE [OF z_Hjc z_Hii])
  next
   assume z_Hkn:"?z_hkn"
   assume z_Hii:"?z_hii"
   have z_Hkp: "?z_hkl(?z_hij)" (is "_=?z_hkq")
   by (rule zenon_all_0 [of "?z_hkl" "?z_hij", OF z_Hkg])
   show FALSE
   proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vguf. (?z_hjq=zenon_Vguf))" "pc" "p" "''D1''" "?z_hij", OF z_Hkp])
    assume z_Hkn:"?z_hkn"
    assume z_Hku:"(p=?z_hij)"
    assume z_Hkv:"(?z_hjq=''D1'')" (is "_=?z_hv")
    show FALSE
    by (rule zenon_eqsym [OF z_Hku z_Hjr])
   next
    assume z_Hkn:"?z_hkn"
    assume z_Hkw:"(p~=?z_hij)"
    assume z_Hkx:"(?z_hjq=?z_hiw)"
    show FALSE
    by (rule zenon_eqsym [OF z_Hkx z_Hjp])
   next
    assume z_Hko:"(~?z_hkn)"
    show FALSE
    by (rule notE [OF z_Hko z_Hkn])
   qed
  qed
 qed
 have zenon_L6_: "((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=?z_hdc) ==> (a_pchash_primea=except(pc, p, ''D1'')) ==> ((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))) \\in ProcSet) ==> ((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=(a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])) ==> (DOMAIN(pc)=ProcSet) ==> FALSE" (is "?z_hky ==> ?z_heb ==> ?z_hii ==> ?z_hjp ==> ?z_hjn ==> FALSE")
 proof -
  assume z_Hky:"?z_hky" (is "?z_hiw~=_")
  assume z_Heb:"?z_heb" (is "_=?z_hed")
  assume z_Hii:"?z_hii"
  assume z_Hjp:"?z_hjp" (is "_~=?z_hjq")
  assume z_Hjn:"?z_hjn" (is "?z_hjo=_")
  show FALSE
  proof (rule zenon_noteq [of "?z_hdc"])
   have z_Hkz: "((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))=p)" (is "?z_hij=_")
   proof (rule zenon_nnpp [of "(?z_hij=p)"])
    assume z_Hjr:"(?z_hij~=p)"
    show FALSE
    by (rule zenon_L5_ [OF z_Hjn z_Hjp z_Hjr z_Hii z_Heb])
   qed
   have z_Hla: "(?z_hdc~=?z_hdc)"
   by (rule subst [where P="(\<lambda>zenon_Vdkp. ((pc[zenon_Vdkp])~=?z_hdc))", OF z_Hkz], fact z_Hky)
   thus "(?z_hdc~=?z_hdc)" .
  qed
 qed
 have zenon_L7_: "(\\A x:((x \\in ProcSet)=>((((pc[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((pc[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((pc[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))) ==> ((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))) \\in ProcSet) ==> ((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''D1'') ==> ((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=BOT) ==> FALSE" (is "?z_hhr ==> ?z_hii ==> ?z_hlf ==> ?z_hix ==> FALSE")
 proof -
  assume z_Hhr:"?z_hhr" (is "\\A x : ?z_hiz(x)")
  assume z_Hii:"?z_hii"
  assume z_Hlf:"?z_hlf" (is "?z_hiw=?z_hv")
  assume z_Hix:"?z_hix" (is "?z_hiy~=_")
  have z_Hja: "?z_hiz((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))" (is "_=>?z_hjb")
  by (rule zenon_all_0 [of "?z_hiz" "(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hhr])
  show FALSE
  proof (rule zenon_imply [OF z_Hja])
   assume z_Hjc:"(~?z_hii)"
   show FALSE
   by (rule notE [OF z_Hjc z_Hii])
  next
   assume z_Hjb:"?z_hjb" (is "?z_hjd&?z_hje")
   have z_Hjd: "?z_hjd" (is "?z_hjf=>?z_hjg")
   by (rule zenon_and_0 [OF z_Hjb])
   show FALSE
   proof (rule zenon_imply [OF z_Hjd])
    assume z_Hjh:"(~?z_hjf)"
    have z_Hji: "(~(?z_hiw \\in {''E1'', ?z_hv, ''D2'', ?z_hx}))" (is "~?z_hjj")
    by (rule zenon_notin_addElt_1 [of "?z_hiw" "''L0''" "{''E1'', ?z_hv, ''D2'', ?z_hx}", OF z_Hjh])
    have z_Hlg: "(~(?z_hiw \\in {?z_hv, ''D2'', ?z_hx}))" (is "~?z_hlh")
    by (rule zenon_notin_addElt_1 [of "?z_hiw" "''E1''" "{?z_hv, ''D2'', ?z_hx}", OF z_Hji])
    have z_Hli: "(?z_hiw~=?z_hv)"
    by (rule zenon_notin_addElt_0 [of "?z_hiw" "?z_hv" "{''D2'', ?z_hx}", OF z_Hlg])
    show FALSE
    by (rule notE [OF z_Hli z_Hlf])
   next
    assume z_Hjg:"?z_hjg"
    show FALSE
    by (rule notE [OF z_Hix z_Hjg])
   qed
  qed
 qed
 have zenon_L8_: "(\\A x:((x \\in ProcSet)=>((((pc[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((pc[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((pc[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))) ==> ((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))) \\in ProcSet) ==> ((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''D2'') ==> ((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=BOT) ==> FALSE" (is "?z_hhr ==> ?z_hii ==> ?z_hlk ==> ?z_hix ==> FALSE")
 proof -
  assume z_Hhr:"?z_hhr" (is "\\A x : ?z_hiz(x)")
  assume z_Hii:"?z_hii"
  assume z_Hlk:"?z_hlk" (is "?z_hiw=?z_hw")
  assume z_Hix:"?z_hix" (is "?z_hiy~=_")
  have z_Hja: "?z_hiz((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))" (is "_=>?z_hjb")
  by (rule zenon_all_0 [of "?z_hiz" "(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hhr])
  show FALSE
  proof (rule zenon_imply [OF z_Hja])
   assume z_Hjc:"(~?z_hii)"
   show FALSE
   by (rule notE [OF z_Hjc z_Hii])
  next
   assume z_Hjb:"?z_hjb" (is "?z_hjd&?z_hje")
   have z_Hjd: "?z_hjd" (is "?z_hjf=>?z_hjg")
   by (rule zenon_and_0 [OF z_Hjb])
   show FALSE
   proof (rule zenon_imply [OF z_Hjd])
    assume z_Hjh:"(~?z_hjf)"
    have z_Hji: "(~(?z_hiw \\in {''E1'', ''D1'', ?z_hw, ?z_hx}))" (is "~?z_hjj")
    by (rule zenon_notin_addElt_1 [of "?z_hiw" "''L0''" "{''E1'', ''D1'', ?z_hw, ?z_hx}", OF z_Hjh])
    have z_Hlg: "(~(?z_hiw \\in {''D1'', ?z_hw, ?z_hx}))" (is "~?z_hlh")
    by (rule zenon_notin_addElt_1 [of "?z_hiw" "''E1''" "{''D1'', ?z_hw, ?z_hx}", OF z_Hji])
    have z_Hll: "(~(?z_hiw \\in {?z_hw, ?z_hx}))" (is "~?z_hlm")
    by (rule zenon_notin_addElt_1 [of "?z_hiw" "''D1''" "{?z_hw, ?z_hx}", OF z_Hlg])
    have z_Hln: "(?z_hiw~=?z_hw)"
    by (rule zenon_notin_addElt_0 [of "?z_hiw" "?z_hw" "{?z_hx}", OF z_Hll])
    show FALSE
    by (rule notE [OF z_Hln z_Hlk])
   next
    assume z_Hjg:"?z_hjg"
    show FALSE
    by (rule notE [OF z_Hix z_Hjg])
   qed
  qed
 qed
 have zenon_L9_: "(\\A x:((x \\in ProcSet)=>((((pc[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((pc[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((pc[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))) ==> ((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))) \\in ProcSet) ==> ((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=?z_hx) ==> ((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=BOT) ==> FALSE" (is "?z_hhr ==> ?z_hii ==> ?z_hlp ==> ?z_hix ==> FALSE")
 proof -
  assume z_Hhr:"?z_hhr" (is "\\A x : ?z_hiz(x)")
  assume z_Hii:"?z_hii"
  assume z_Hlp:"?z_hlp" (is "?z_hiw=_")
  assume z_Hix:"?z_hix" (is "?z_hiy~=_")
  have z_Hja: "?z_hiz((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))" (is "_=>?z_hjb")
  by (rule zenon_all_0 [of "?z_hiz" "(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hhr])
  show FALSE
  proof (rule zenon_imply [OF z_Hja])
   assume z_Hjc:"(~?z_hii)"
   show FALSE
   by (rule notE [OF z_Hjc z_Hii])
  next
   assume z_Hjb:"?z_hjb" (is "?z_hjd&?z_hje")
   have z_Hjd: "?z_hjd" (is "?z_hjf=>?z_hjg")
   by (rule zenon_and_0 [OF z_Hjb])
   show FALSE
   proof (rule zenon_imply [OF z_Hjd])
    assume z_Hjh:"(~?z_hjf)"
    have z_Hji: "(~(?z_hiw \\in {''E1'', ''D1'', ''D2'', ?z_hx}))" (is "~?z_hjj")
    by (rule zenon_notin_addElt_1 [of "?z_hiw" "''L0''" "{''E1'', ''D1'', ''D2'', ?z_hx}", OF z_Hjh])
    have z_Hlg: "(~(?z_hiw \\in {''D1'', ''D2'', ?z_hx}))" (is "~?z_hlh")
    by (rule zenon_notin_addElt_1 [of "?z_hiw" "''E1''" "{''D1'', ''D2'', ?z_hx}", OF z_Hji])
    have z_Hll: "(~(?z_hiw \\in {''D2'', ?z_hx}))" (is "~?z_hlm")
    by (rule zenon_notin_addElt_1 [of "?z_hiw" "''D1''" "{''D2'', ?z_hx}", OF z_Hlg])
    have z_Hlq: "(~(?z_hiw \\in {?z_hx}))" (is "~?z_hlr")
    by (rule zenon_notin_addElt_1 [of "?z_hiw" "''D2''" "{?z_hx}", OF z_Hll])
    have z_Hls: "(?z_hiw~=?z_hx)"
    by (rule zenon_notin_addElt_0 [of "?z_hiw" "?z_hx" "{}", OF z_Hlq])
    show FALSE
    by (rule notE [OF z_Hls z_Hlp])
   next
    assume z_Hjg:"?z_hjg"
    show FALSE
    by (rule notE [OF z_Hix z_Hjg])
   qed
  qed
 qed
 have zenon_L10_: "((a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])) ==> (a_pchash_primea=pc) ==> FALSE" (is "?z_hlu ==> ?z_heo ==> FALSE")
 proof -
  assume z_Hlu:"?z_hlu" (is "?z_hjq~=?z_hiw")
  assume z_Heo:"?z_heo"
  show FALSE
  proof (rule zenon_noteq [of "?z_hiw"])
   have z_Hlv: "(?z_hiw~=?z_hiw)"
   by (rule subst [where P="(\<lambda>zenon_Vekp. ((zenon_Vekp[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=?z_hiw))", OF z_Heo], fact z_Hlu)
   thus "(?z_hiw~=?z_hiw)" .
  qed
 qed
 have zenon_L11_: "((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))) ==> (\\A x:((x \\in M)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>(((a_ca[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))) ==> ((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))) \\in a_Mhash_primea) ==> ((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))) \\in ProcSet) ==> ((a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx}) ==> ((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=BOT) ==> FALSE" (is "?z_hej ==> ?z_hhl ==> ?z_hhc ==> ?z_hii ==> ?z_hma ==> ?z_hix ==> FALSE")
 proof -
  assume z_Hej:"?z_hej" (is "?z_hek&?z_hen")
  assume z_Hhl:"?z_hhl" (is "\\A x : ?z_hhp(x)")
  assume z_Hhc:"?z_hhc"
  assume z_Hii:"?z_hii"
  assume z_Hma:"?z_hma"
  assume z_Hix:"?z_hix" (is "?z_hiy~=_")
  have z_Hen: "?z_hen" (is "?z_heo&?z_heh")
  by (rule zenon_and_1 [OF z_Hej])
  have z_Heo: "?z_heo"
  by (rule zenon_and_0 [OF z_Hen])
  have z_Heh: "?z_heh"
  by (rule zenon_and_1 [OF z_Hen])
  have z_Hhq: "?z_hhp((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))))" (is "?z_hgj=>?z_hhi")
  by (rule zenon_all_0 [of "?z_hhp" "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))", OF z_Hhl])
  show FALSE
  proof (rule zenon_imply [OF z_Hhq])
   assume z_Hgi:"(~?z_hgj)"
   show FALSE
   by (rule zenon_L1_ [OF z_Heh z_Hgi z_Hhc])
  next
   assume z_Hhi:"?z_hhi"
   have z_Hmb: "bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT})))))))" (is "?z_hmb")
   by (rule zenon_in_subsetof_1 [of "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))" "[''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))]" "(\<lambda>a_ca. bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>(((a_ca[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hhi])
   have z_Hhr_z_Hmb: "(\\A x:((x \\in ProcSet)=>((((pc[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((pc[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((pc[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))) == ?z_hmb" (is "?z_hhr == _")
   by (unfold bAll_def)
   have z_Hhr: "?z_hhr" (is "\\A x : ?z_hiz(x)")
   by (unfold z_Hhr_z_Hmb, fact z_Hmb)
   have z_Hja: "?z_hiz((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))" (is "_=>?z_hjb")
   by (rule zenon_all_0 [of "?z_hiz" "(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hhr])
   show FALSE
   proof (rule zenon_imply [OF z_Hja])
    assume z_Hjc:"(~?z_hii)"
    show FALSE
    by (rule notE [OF z_Hjc z_Hii])
   next
    assume z_Hjb:"?z_hjb" (is "?z_hjd&?z_hje")
    have z_Hjd: "?z_hjd" (is "?z_hjf=>?z_hjg")
    by (rule zenon_and_0 [OF z_Hjb])
    show FALSE
    proof (rule zenon_imply [OF z_Hjd])
     assume z_Hjh:"(~?z_hjf)"
     show FALSE
     proof (rule notE [OF z_Hjh])
      have z_Hkx: "((a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]))" (is "?z_hjq=?z_hiw")
      proof (rule zenon_nnpp [of "(?z_hjq=?z_hiw)"])
       assume z_Hlu:"(?z_hjq~=?z_hiw)"
       show FALSE
       by (rule zenon_L10_ [OF z_Hlu z_Heo])
      qed
      have z_Hjf: "?z_hjf"
      by (rule subst [where P="(\<lambda>zenon_Vfkp. (zenon_Vfkp \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx}))", OF z_Hkx], fact z_Hma)
      thus "?z_hjf" .
     qed
    next
     assume z_Hjg:"?z_hjg"
     show FALSE
     by (rule notE [OF z_Hix z_Hjg])
    qed
   qed
  qed
 qed
 have zenon_L12_: "((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma'']))))))))))))) ==> (~bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))) ==> ((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))) \\in a_Mhash_primea) ==> FALSE" (is "?z_hep ==> ?z_hmp ==> ?z_hhc ==> FALSE")
 proof -
  assume z_Hep:"?z_hep" (is "?z_heq&?z_hes")
  assume z_Hmp:"?z_hmp" (is "~?z_hmq")
  assume z_Hhc:"?z_hhc"
  have z_Hes: "?z_hes" (is "?z_hef&?z_het")
  by (rule zenon_and_1 [OF z_Hep])
  have z_Het: "?z_het" (is "_=?z_heu")
  by (rule zenon_and_1 [OF z_Hes])
  have z_Hnb: "(\\A zenon_Vse:((zenon_Vse \\in a_Mhash_primea)<=>(zenon_Vse \\in ?z_heu)))" (is "\\A x : ?z_hng(x)")
  by (rule zenon_setequal_0 [of "a_Mhash_primea" "?z_heu", OF z_Het])
  have z_Hnh: "?z_hng((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))))" (is "_<=>?z_hni")
  by (rule zenon_all_0 [of "?z_hng" "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))", OF z_Hnb])
  show FALSE
  proof (rule zenon_equiv [OF z_Hnh])
   assume z_Hhd:"(~?z_hhc)"
   assume z_Hnj:"(~?z_hni)"
   show FALSE
   by (rule notE [OF z_Hhd z_Hhc])
  next
   assume z_Hhc:"?z_hhc"
   assume z_Hni:"?z_hni"
   have z_Hnk: "(?z_hmq&bEx(M, (\<lambda>a_ca. (((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[q])=((a_ca[''fres''])[q])))))&(((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''sigma''])=Tail((a_ca[''sigma'']))))))))" (is "_&?z_hnl")
   by (rule zenon_in_subsetof_1 [of "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))" "[''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))]" "(\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))", OF z_Hni])
   have z_Hmq: "?z_hmq"
   by (rule zenon_and_0 [OF z_Hnk])
   show FALSE
   by (rule notE [OF z_Hmp z_Hmq])
  qed
 qed
 have zenon_L13_: "(DOMAIN(pc)=ProcSet) ==> ((a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])) ==> ((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))~=p) ==> ((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))) \\in ProcSet) ==> (a_pchash_primea=except(pc, p, ''D1'')) ==> FALSE" (is "?z_hjn ==> ?z_hlu ==> ?z_hjr ==> ?z_hii ==> ?z_heb ==> FALSE")
 proof -
  assume z_Hjn:"?z_hjn" (is "?z_hjo=_")
  assume z_Hlu:"?z_hlu" (is "?z_hjq~=?z_hiw")
  assume z_Hjr:"?z_hjr" (is "?z_hij~=_")
  assume z_Hii:"?z_hii"
  assume z_Heb:"?z_heb" (is "_=?z_hed")
  have z_Hjs: "(\\A zenon_Vwc:((zenon_Vwc \\in ?z_hjo)<=>(zenon_Vwc \\in ProcSet)))" (is "\\A x : ?z_hjx(x)")
  by (rule zenon_setequal_0 [of "?z_hjo" "ProcSet", OF z_Hjn])
  have z_Hjy: "(((isAFcn(a_pchash_primea)<=>isAFcn(?z_hed))&(DOMAIN(a_pchash_primea)=DOMAIN(?z_hed)))&(\\A zenon_Vlpc:((a_pchash_primea[zenon_Vlpc])=(?z_hed[zenon_Vlpc]))))" (is "?z_hjz&?z_hkg")
  by (rule zenon_funequal_0 [of "a_pchash_primea" "?z_hed", OF z_Heb])
  have z_Hkg: "?z_hkg" (is "\\A x : ?z_hkl(x)")
  by (rule zenon_and_1 [OF z_Hjy])
  have z_Hkm: "?z_hjx(?z_hij)" (is "?z_hkn<=>_")
  by (rule zenon_all_0 [of "?z_hjx" "?z_hij", OF z_Hjs])
  show FALSE
  proof (rule zenon_equiv [OF z_Hkm])
   assume z_Hko:"(~?z_hkn)"
   assume z_Hjc:"(~?z_hii)"
   show FALSE
   by (rule notE [OF z_Hjc z_Hii])
  next
   assume z_Hkn:"?z_hkn"
   assume z_Hii:"?z_hii"
   have z_Hkp: "?z_hkl(?z_hij)" (is "_=?z_hkq")
   by (rule zenon_all_0 [of "?z_hkl" "?z_hij", OF z_Hkg])
   show FALSE
   proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vguf. (?z_hjq=zenon_Vguf))" "pc" "p" "''D1''" "?z_hij", OF z_Hkp])
    assume z_Hkn:"?z_hkn"
    assume z_Hku:"(p=?z_hij)"
    assume z_Hkv:"(?z_hjq=''D1'')" (is "_=?z_hv")
    show FALSE
    by (rule zenon_eqsym [OF z_Hku z_Hjr])
   next
    assume z_Hkn:"?z_hkn"
    assume z_Hkw:"(p~=?z_hij)"
    assume z_Hkx:"(?z_hjq=?z_hiw)"
    show FALSE
    by (rule notE [OF z_Hlu z_Hkx])
   next
    assume z_Hko:"(~?z_hkn)"
    show FALSE
    by (rule notE [OF z_Hko z_Hkn])
   qed
  qed
 qed
 have zenon_L14_: "((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=?z_hx) ==> (?z_hdc=?z_hx) ==> (DOMAIN(pc)=ProcSet) ==> ((a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])) ==> ((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))) \\in ProcSet) ==> (a_pchash_primea=except(pc, p, ''D1'')) ==> FALSE" (is "?z_hls ==> ?z_he ==> ?z_hjn ==> ?z_hlu ==> ?z_hii ==> ?z_heb ==> FALSE")
 proof -
  assume z_Hls:"?z_hls" (is "?z_hiw~=_")
  assume z_He:"?z_he"
  assume z_Hjn:"?z_hjn" (is "?z_hjo=_")
  assume z_Hlu:"?z_hlu" (is "?z_hjq~=_")
  assume z_Hii:"?z_hii"
  assume z_Heb:"?z_heb" (is "_=?z_hed")
  show FALSE
  proof (rule notE [OF z_Hls])
   have z_Hnx: "(?z_hdc=?z_hiw)"
   proof (rule zenon_nnpp [of "(?z_hdc=?z_hiw)"])
    assume z_Hny:"(?z_hdc~=?z_hiw)"
    show FALSE
    proof (rule zenon_em [of "(?z_hiw=?z_hiw)"])
     assume z_Hnz:"(?z_hiw=?z_hiw)"
     show FALSE
     proof (rule notE [OF z_Hny])
      have z_Hoa: "(?z_hiw=?z_hdc)"
      proof (rule zenon_nnpp [of "(?z_hiw=?z_hdc)"])
       assume z_Hky:"(?z_hiw~=?z_hdc)"
       show FALSE
       proof (rule zenon_noteq [of "?z_hdc"])
        have z_Hkz: "((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))=p)" (is "?z_hij=_")
        proof (rule zenon_nnpp [of "(?z_hij=p)"])
         assume z_Hjr:"(?z_hij~=p)"
         show FALSE
         by (rule zenon_L13_ [OF z_Hjn z_Hlu z_Hjr z_Hii z_Heb])
        qed
        have z_Hla: "(?z_hdc~=?z_hdc)"
        by (rule subst [where P="(\<lambda>zenon_Vdkp. ((pc[zenon_Vdkp])~=?z_hdc))", OF z_Hkz], fact z_Hky)
        thus "(?z_hdc~=?z_hdc)" .
       qed
      qed
      have z_Hnx: "(?z_hdc=?z_hiw)"
      by (rule subst [where P="(\<lambda>zenon_Vhkp. (zenon_Vhkp=?z_hiw))", OF z_Hoa], fact z_Hnz)
      thus "(?z_hdc=?z_hiw)" .
     qed
    next
     assume z_Hlv:"(?z_hiw~=?z_hiw)"
     show FALSE
     by (rule zenon_noteq [OF z_Hlv])
    qed
   qed
   have z_Hlp: "(?z_hiw=?z_hx)"
   by (rule subst [where P="(\<lambda>zenon_Vikp. (zenon_Vikp=?z_hx))", OF z_Hnx], fact z_He)
   thus "(?z_hiw=?z_hx)" .
  qed
 qed
 have zenon_L15_: "((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))) ==> (\\A x:((x \\in M)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>(((a_ca[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))) ==> ((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))) \\in a_Mhash_primea) ==> ((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))) \\in ProcSet) ==> ((a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''D4''}) ==> (~((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in ((Nat \\ {0}) \\cup {BOT}))) ==> FALSE" (is "?z_hej ==> ?z_hhl ==> ?z_hhc ==> ?z_hii ==> ?z_hoh ==> ?z_hoi ==> FALSE")
 proof -
  assume z_Hej:"?z_hej" (is "?z_hek&?z_hen")
  assume z_Hhl:"?z_hhl" (is "\\A x : ?z_hhp(x)")
  assume z_Hhc:"?z_hhc"
  assume z_Hii:"?z_hii"
  assume z_Hoh:"?z_hoh"
  assume z_Hoi:"?z_hoi" (is "~?z_hoj")
  have z_Hen: "?z_hen" (is "?z_heo&?z_heh")
  by (rule zenon_and_1 [OF z_Hej])
  have z_Heo: "?z_heo"
  by (rule zenon_and_0 [OF z_Hen])
  have z_Heh: "?z_heh"
  by (rule zenon_and_1 [OF z_Hen])
  have z_Hhq: "?z_hhp((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))))" (is "?z_hgj=>?z_hhi")
  by (rule zenon_all_0 [of "?z_hhp" "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))", OF z_Hhl])
  show FALSE
  proof (rule zenon_imply [OF z_Hhq])
   assume z_Hgi:"(~?z_hgj)"
   show FALSE
   by (rule zenon_L1_ [OF z_Heh z_Hgi z_Hhc])
  next
   assume z_Hhi:"?z_hhi"
   have z_Hmb: "bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT})))))))" (is "?z_hmb")
   by (rule zenon_in_subsetof_1 [of "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))" "[''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))]" "(\<lambda>a_ca. bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>(((a_ca[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hhi])
   have z_Hhr_z_Hmb: "(\\A x:((x \\in ProcSet)=>((((pc[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((pc[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((pc[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))) == ?z_hmb" (is "?z_hhr == _")
   by (unfold bAll_def)
   have z_Hhr: "?z_hhr" (is "\\A x : ?z_hiz(x)")
   by (unfold z_Hhr_z_Hmb, fact z_Hmb)
   have z_Hja: "?z_hiz((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))" (is "_=>?z_hjb")
   by (rule zenon_all_0 [of "?z_hiz" "(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hhr])
   show FALSE
   proof (rule zenon_imply [OF z_Hja])
    assume z_Hjc:"(~?z_hii)"
    show FALSE
    by (rule notE [OF z_Hjc z_Hii])
   next
    assume z_Hjb:"?z_hjb" (is "?z_hjd&?z_hje")
    have z_Hje: "?z_hje" (is "?z_hok&?z_hol")
    by (rule zenon_and_1 [OF z_Hjb])
    have z_Hol: "?z_hol" (is "?z_hom=>_")
    by (rule zenon_and_1 [OF z_Hje])
    show FALSE
    proof (rule zenon_imply [OF z_Hol])
     assume z_Hon:"(~?z_hom)"
     show FALSE
     proof (rule notE [OF z_Hon])
      have z_Hkx: "((a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]))" (is "?z_hjq=?z_hiw")
      proof (rule zenon_nnpp [of "(?z_hjq=?z_hiw)"])
       assume z_Hlu:"(?z_hjq~=?z_hiw)"
       show FALSE
       by (rule zenon_L10_ [OF z_Hlu z_Heo])
      qed
      have z_Hom: "?z_hom"
      by (rule subst [where P="(\<lambda>zenon_Vjkp. (zenon_Vjkp \\in {''D4''}))", OF z_Hkx], fact z_Hoh)
      thus "?z_hom" .
     qed
    next
     assume z_Hoj:"?z_hoj"
     show FALSE
     by (rule notE [OF z_Hoi z_Hoj])
    qed
   qed
  qed
 qed
 assume z_Hl:"(~(a_Mhash_primea \\in SUBSET(subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))" (is "~?z_hor")
 have z_Hm: "?z_hm"
 by (rule zenon_and_0 [OF z_Ha])
 have z_Hz: "?z_hz" (is "?z_hba&?z_hbg")
 by (rule zenon_and_1 [OF z_Ha])
 have z_Hbg: "?z_hbg" (is "?z_hbh&?z_hbn")
 by (rule zenon_and_1 [OF z_Hz])
 have z_Hbn: "?z_hbn" (is "?z_hbo&?z_hbr")
 by (rule zenon_and_1 [OF z_Hbg])
 have z_Hbr: "?z_hbr" (is "?z_hbs&?z_hbu")
 by (rule zenon_and_1 [OF z_Hbn])
 have z_Hbu: "?z_hbu" (is "?z_hbv&?z_hbx")
 by (rule zenon_and_1 [OF z_Hbr])
 have z_Hbx: "?z_hbx" (is "?z_hby&?z_hcb")
 by (rule zenon_and_1 [OF z_Hbu])
 have z_Hcb: "?z_hcb" (is "?z_hcc&?z_hce")
 by (rule zenon_and_1 [OF z_Hbx])
 have z_Hce: "?z_hce"
 by (rule zenon_and_1 [OF z_Hcb])
 have z_Hot: "(M \\subseteq subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>(((a_ca[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))" (is "?z_hot")
 by (rule zenon_in_SUBSET_0 [of "M" "subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>(((a_ca[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))", OF z_Hce])
 have z_Hou_z_Hot: "bAll(M, (\<lambda>x. (x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>(((a_ca[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))) == ?z_hot" (is "?z_hou == _")
 by (unfold subset_def)
 have z_Hou: "?z_hou"
 by (unfold z_Hou_z_Hot, fact z_Hot)
 have z_Hhl_z_Hou: "(\\A x:((x \\in M)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>(((a_ca[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))) == ?z_hou" (is "?z_hhl == _")
 by (unfold bAll_def)
 have z_Hhl: "?z_hhl" (is "\\A x : ?z_hhp(x)")
 by (unfold z_Hhl_z_Hou, fact z_Hou)
 have z_How: "(~(a_Mhash_primea \\subseteq subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))" (is "~?z_hox")
 by (rule zenon_notin_SUBSET_0 [of "a_Mhash_primea" "subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))", OF z_Hl])
 have z_Hoy_z_How: "(~bAll(a_Mhash_primea, (\<lambda>x. (x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))) == (~?z_hox)" (is "?z_hoy == ?z_how")
 by (unfold subset_def)
 have z_Hoy: "?z_hoy" (is "~?z_hoz")
 by (unfold z_Hoy_z_How, fact z_How)
 have z_Hpb_z_Hoy: "(~(\\A x:((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))) == ?z_hoy" (is "?z_hpb == _")
 by (unfold bAll_def)
 have z_Hpb: "?z_hpb" (is "~(\\A x : ?z_hpd(x))")
 by (unfold z_Hpb_z_Hoy, fact z_Hoy)
 have z_Hpe: "(\\E x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))" (is "\\E x : ?z_hpf(x)")
 by (rule zenon_notallex_0 [of "?z_hpd", OF z_Hpb])
 have z_Hpg: "?z_hpf((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))))" (is "~(?z_hhc=>?z_hph)")
 by (rule zenon_ex_choose_0 [of "?z_hpf", OF z_Hpe])
 have z_Hhc: "?z_hhc"
 by (rule zenon_notimply_0 [OF z_Hpg])
 have z_Hpi: "(~?z_hph)"
 by (rule zenon_notimply_1 [OF z_Hpg])
 show FALSE
 proof (rule zenon_notin_subsetof [of "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))" "[''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))]" "(\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hpi])
  assume z_Hhj:"(~((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))) \\in [''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))]))" (is "~?z_hhk")
  show FALSE
  proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vf. zenon_Vf)" "((Q[(j[p])])=BOT)" "cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))))" "((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))))))", OF z_Hd])
   assume z_Hds:"((Q[(j[p])])=BOT)" (is "?z_hdt=_")
   assume z_Hdv:"cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))))" (is "?z_hdv")
   show FALSE
   proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vf. zenon_Vf)" "((j[p])=((l[p]) +  -.(1)))" "((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M)))" "((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M)))", OF z_Hdv])
    assume z_Hdw:"((j[p])=((l[p]) +  -.(1)))" (is "?z_hdu=?z_hdx")
    assume z_Hea:"((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M)))" (is "?z_heb&?z_hee")
    have z_Hee: "?z_hee" (is "?z_hef&?z_heh")
    by (rule zenon_and_1 [OF z_Hea])
    have z_Heh: "?z_heh"
    by (rule zenon_and_1 [OF z_Hee])
    show FALSE
    by (rule zenon_L3_ [OF z_Hhl z_Heh z_Hhc z_Hhj])
   next
    assume z_Hpl:"((j[p])~=((l[p]) +  -.(1)))" (is "?z_hdu~=?z_hdx")
    assume z_Hej:"((a_jhash_primea=except(j, p, (?z_hdu + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M)))" (is "?z_hek&?z_hen")
    have z_Hen: "?z_hen" (is "?z_heo&?z_heh")
    by (rule zenon_and_1 [OF z_Hej])
    have z_Heh: "?z_heh"
    by (rule zenon_and_1 [OF z_Hen])
    show FALSE
    by (rule zenon_L3_ [OF z_Hhl z_Heh z_Hhc z_Hhj])
   qed
  next
   assume z_Hpm:"((Q[(j[p])])~=BOT)" (is "?z_hdt~=_")
   assume z_Hep:"((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))))))" (is "?z_heq&?z_hes")
   have z_Hes: "?z_hes" (is "?z_hef&?z_het")
   by (rule zenon_and_1 [OF z_Hep])
   have z_Het: "?z_het" (is "_=?z_heu")
   by (rule zenon_and_1 [OF z_Hes])
   have z_Hnb: "(\\A zenon_Vse:((zenon_Vse \\in a_Mhash_primea)<=>(zenon_Vse \\in ?z_heu)))" (is "\\A x : ?z_hng(x)")
   by (rule zenon_setequal_0 [of "a_Mhash_primea" "?z_heu", OF z_Het])
   have z_Hnh: "?z_hng((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))))" (is "_<=>?z_hni")
   by (rule zenon_all_0 [of "?z_hng" "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))", OF z_Hnb])
   show FALSE
   proof (rule zenon_equiv [OF z_Hnh])
    assume z_Hhd:"(~?z_hhc)"
    assume z_Hnj:"(~?z_hni)"
    show FALSE
    by (rule notE [OF z_Hhd z_Hhc])
   next
    assume z_Hhc:"?z_hhc"
    assume z_Hni:"?z_hni"
    have z_Hhk: "?z_hhk"
    by (rule zenon_in_subsetof_0 [of "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))" "[''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))]" "(\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))", OF z_Hni])
    show FALSE
    by (rule notE [OF z_Hhj z_Hhk])
   qed
  qed
 next
  assume z_Hmp:"(~bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))" (is "~?z_hmq")
  have z_Hpn_z_Hmp: "(~(\\A x:((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))) == (~?z_hmq)" (is "?z_hpn == ?z_hmp")
  by (unfold bAll_def)
  have z_Hpn: "?z_hpn" (is "~(\\A x : ?z_hpp(x))")
  by (unfold z_Hpn_z_Hmp, fact z_Hmp)
  have z_Hpq: "(\\E x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))" (is "\\E x : ?z_hpr(x)")
  by (rule zenon_notallex_0 [of "?z_hpp", OF z_Hpn])
  have z_Hps: "?z_hpr((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))" (is "~(?z_hii=>?z_hpt)")
  by (rule zenon_ex_choose_0 [of "?z_hpr", OF z_Hpq])
  have z_Hii: "?z_hii"
  by (rule zenon_notimply_0 [OF z_Hps])
  have z_Hpu: "(~?z_hpt)" (is "~(?z_hpv&?z_hpw)")
  by (rule zenon_notimply_1 [OF z_Hps])
  show FALSE
  proof (rule zenon_notand [OF z_Hpu])
   assume z_Hpx:"(~?z_hpv)" (is "~(?z_hma=>?z_hjg)")
   have z_Hma: "?z_hma"
   by (rule zenon_notimply_0 [OF z_Hpx])
   have z_Hix: "((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=BOT)" (is "?z_hiy~=_")
   by (rule zenon_notimply_1 [OF z_Hpx])
   show FALSE
   proof (rule zenon_in_addElt [of "(a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''L0''" "{''E1'', ''D1'', ''D2'', ?z_hx}", OF z_Hma])
    assume z_Hpy:"((a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''L0'')" (is "?z_hjq=?z_hr")
    have z_Hjn: "(DOMAIN(pc)=ProcSet)" (is "?z_hjo=_")
    by (rule zenon_in_funcset_1 [of "pc" "ProcSet" "{?z_hr, ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hm])
    show FALSE
    proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vf. zenon_Vf)" "((Q[(j[p])])=BOT)" "cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))))" "((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))))))", OF z_Hd])
     assume z_Hds:"((Q[(j[p])])=BOT)" (is "?z_hdt=_")
     assume z_Hdv:"cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))))" (is "?z_hdv")
     show FALSE
     proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vf. zenon_Vf)" "((j[p])=((l[p]) +  -.(1)))" "((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M)))" "((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M)))", OF z_Hdv])
      assume z_Hdw:"((j[p])=((l[p]) +  -.(1)))" (is "?z_hdu=?z_hdx")
      assume z_Hea:"((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M)))" (is "?z_heb&?z_hee")
      have z_Heb: "?z_heb" (is "_=?z_hed")
      by (rule zenon_and_0 [OF z_Hea])
      have z_Hee: "?z_hee" (is "?z_hef&?z_heh")
      by (rule zenon_and_1 [OF z_Hea])
      have z_Heh: "?z_heh"
      by (rule zenon_and_1 [OF z_Hee])
      have z_Hhq: "?z_hhp((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))))" (is "?z_hgj=>?z_hhi")
      by (rule zenon_all_0 [of "?z_hhp" "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))", OF z_Hhl])
      show FALSE
      proof (rule zenon_imply [OF z_Hhq])
       assume z_Hgi:"(~?z_hgj)"
       show FALSE
       by (rule zenon_L1_ [OF z_Heh z_Hgi z_Hhc])
      next
       assume z_Hhi:"?z_hhi"
       have z_Hmb: "bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT})))))))" (is "?z_hmb")
       by (rule zenon_in_subsetof_1 [of "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))" "[''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))]" "(\<lambda>a_ca. bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>(((a_ca[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hhi])
       have z_Hhr_z_Hmb: "(\\A x:((x \\in ProcSet)=>((((pc[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((pc[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((pc[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))) == ?z_hmb" (is "?z_hhr == _")
       by (unfold bAll_def)
       have z_Hhr: "?z_hhr" (is "\\A x : ?z_hiz(x)")
       by (unfold z_Hhr_z_Hmb, fact z_Hmb)
       have z_Hjn: "(?z_hjo=ProcSet)"
       by (rule zenon_in_funcset_1 [of "pc" "ProcSet" "{?z_hr, ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hm])
       have z_Hpz: "(\\A zenon_Vla:((zenon_Vla \\in ProcSet)=>((pc[zenon_Vla]) \\in {?z_hr, ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''})))" (is "\\A x : ?z_hqf(x)")
       by (rule zenon_in_funcset_2 [of "pc" "ProcSet" "{?z_hr, ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hm])
       have z_Hqg: "?z_hqf((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))" (is "_=>?z_hqh")
       by (rule zenon_all_0 [of "?z_hqf" "(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hpz])
       show FALSE
       proof (rule zenon_imply [OF z_Hqg])
        assume z_Hjc:"(~?z_hii)"
        show FALSE
        by (rule notE [OF z_Hjc z_Hii])
       next
        assume z_Hqh:"?z_hqh"
        show FALSE
        proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "?z_hr" "{''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hqh])
         assume z_Hqj:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=?z_hr)" (is "?z_hiw=_")
         have z_Hja: "?z_hiz((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))" (is "_=>?z_hjb")
         by (rule zenon_all_0 [of "?z_hiz" "(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hhr])
         show FALSE
         proof (rule zenon_imply [OF z_Hja])
          assume z_Hjc:"(~?z_hii)"
          show FALSE
          by (rule notE [OF z_Hjc z_Hii])
         next
          assume z_Hjb:"?z_hjb" (is "?z_hjd&?z_hje")
          have z_Hjd: "?z_hjd" (is "?z_hjf=>_")
          by (rule zenon_and_0 [OF z_Hjb])
          show FALSE
          proof (rule zenon_imply [OF z_Hjd])
           assume z_Hjh:"(~?z_hjf)"
           have z_Hqk: "(?z_hiw~=?z_hr)"
           by (rule zenon_notin_addElt_0 [of "?z_hiw" "?z_hr" "{''E1'', ''D1'', ''D2'', ?z_hx}", OF z_Hjh])
           show FALSE
           by (rule notE [OF z_Hqk z_Hqj])
          next
           assume z_Hjg:"?z_hjg"
           show FALSE
           by (rule notE [OF z_Hix z_Hjg])
          qed
         qed
        next
         assume z_Hql:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''})" (is "?z_hql")
         show FALSE
         proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''E1''" "{''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hql])
          assume z_Hiv:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''E1'')" (is "?z_hiw=?z_hs")
          show FALSE
          by (rule zenon_L4_ [OF z_Hhr z_Hii z_Hiv z_Hix])
         next
          assume z_Hqn:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''})" (is "?z_hqn")
          show FALSE
          proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''E2''" "{''E3'', ''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hqn])
           assume z_Hqp:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''E2'')" (is "?z_hiw=?z_ht")
           have z_Hqq: "(?z_ht~=?z_hx)"
           by auto
           have z_Hky: "(?z_hiw~=?z_hdc)"
           by (rule zenon_stringdiffll [OF z_Hqq z_Hqp z_He])
            have z_Hqr: "(?z_ht~=?z_hr)"
            by auto
            have z_Hjp: "(?z_hiw~=?z_hjq)"
            by (rule zenon_stringdiffll [OF z_Hqr z_Hqp z_Hpy])
             show FALSE
             by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
          next
           assume z_Hqs:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''E3'', ''D1'', ''D2'', ?z_hx, ''D4''})" (is "?z_hqs")
           show FALSE
           proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''E3''" "{''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hqs])
            assume z_Hqu:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''E3'')" (is "?z_hiw=?z_hu")
            have z_Hqv: "(?z_hu~=?z_hx)"
            by auto
            have z_Hky: "(?z_hiw~=?z_hdc)"
            by (rule zenon_stringdiffll [OF z_Hqv z_Hqu z_He])
             have z_Hqw: "(?z_hu~=?z_hr)"
             by auto
             have z_Hjp: "(?z_hiw~=?z_hjq)"
             by (rule zenon_stringdiffll [OF z_Hqw z_Hqu z_Hpy])
              show FALSE
              by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
           next
            assume z_Hqx:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''D1'', ''D2'', ?z_hx, ''D4''})" (is "?z_hqx")
            show FALSE
            proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''D1''" "{''D2'', ?z_hx, ''D4''}", OF z_Hqx])
             assume z_Hlf:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''D1'')" (is "?z_hiw=?z_hv")
             show FALSE
             by (rule zenon_L7_ [OF z_Hhr z_Hii z_Hlf z_Hix])
            next
             assume z_Hqz:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''D2'', ?z_hx, ''D4''})" (is "?z_hqz")
             show FALSE
             proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''D2''" "{?z_hx, ''D4''}", OF z_Hqz])
              assume z_Hlk:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''D2'')" (is "?z_hiw=?z_hw")
              show FALSE
              by (rule zenon_L8_ [OF z_Hhr z_Hii z_Hlk z_Hix])
             next
              assume z_Hrb:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {?z_hx, ''D4''})" (is "?z_hrb")
              show FALSE
              proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "?z_hx" "{''D4''}", OF z_Hrb])
               assume z_Hlp:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=?z_hx)" (is "?z_hiw=_")
               show FALSE
               by (rule zenon_L9_ [OF z_Hhr z_Hii z_Hlp z_Hix])
              next
               assume z_Hom:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''D4''})" (is "?z_hom")
               show FALSE
               proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''D4''" "{}", OF z_Hom])
               assume z_Hrc:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''D4'')" (is "?z_hiw=?z_hy")
               have z_Hrd: "(?z_hy~=?z_hx)"
               by auto
               have z_Hky: "(?z_hiw~=?z_hdc)"
               by (rule zenon_stringdiffll [OF z_Hrd z_Hrc z_He])
               have z_Hre: "(?z_hy~=?z_hr)"
               by auto
               have z_Hjp: "(?z_hiw~=?z_hjq)"
               by (rule zenon_stringdiffll [OF z_Hre z_Hrc z_Hpy])
               show FALSE
               by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
               next
               assume z_Hrf:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {})" (is "?z_hrf")
               show FALSE
               by (rule zenon_in_emptyset [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])", OF z_Hrf])
               qed
              qed
             qed
            qed
           qed
          qed
         qed
        qed
       qed
      qed
     next
      assume z_Hpl:"((j[p])~=((l[p]) +  -.(1)))" (is "?z_hdu~=?z_hdx")
      assume z_Hej:"((a_jhash_primea=except(j, p, (?z_hdu + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M)))" (is "?z_hek&?z_hen")
      show FALSE
      by (rule zenon_L11_ [OF z_Hej z_Hhl z_Hhc z_Hii z_Hma z_Hix])
     qed
    next
     assume z_Hpm:"((Q[(j[p])])~=BOT)" (is "?z_hdt~=_")
     assume z_Hep:"((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {?z_hr, ''E1'', ''D1'', ''D2'', ?z_hx})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))))))" (is "?z_heq&?z_hes")
     show FALSE
     by (rule zenon_L12_ [OF z_Hep z_Hmp z_Hhc])
    qed
   next
    assume z_Hrg:"((a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''E1'', ''D1'', ''D2'', ?z_hx})" (is "?z_hrg")
    show FALSE
    proof (rule zenon_in_addElt [of "(a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''E1''" "{''D1'', ''D2'', ?z_hx}", OF z_Hrg])
     assume z_Hrh:"((a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''E1'')" (is "?z_hjq=?z_hs")
     have z_Hjn: "(DOMAIN(pc)=ProcSet)" (is "?z_hjo=_")
     by (rule zenon_in_funcset_1 [of "pc" "ProcSet" "{''L0'', ?z_hs, ''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hm])
     show FALSE
     proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vf. zenon_Vf)" "((Q[(j[p])])=BOT)" "cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))))" "((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))))))", OF z_Hd])
      assume z_Hds:"((Q[(j[p])])=BOT)" (is "?z_hdt=_")
      assume z_Hdv:"cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))))" (is "?z_hdv")
      show FALSE
      proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vf. zenon_Vf)" "((j[p])=((l[p]) +  -.(1)))" "((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M)))" "((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M)))", OF z_Hdv])
       assume z_Hdw:"((j[p])=((l[p]) +  -.(1)))" (is "?z_hdu=?z_hdx")
       assume z_Hea:"((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M)))" (is "?z_heb&?z_hee")
       have z_Heb: "?z_heb" (is "_=?z_hed")
       by (rule zenon_and_0 [OF z_Hea])
       have z_Hee: "?z_hee" (is "?z_hef&?z_heh")
       by (rule zenon_and_1 [OF z_Hea])
       have z_Heh: "?z_heh"
       by (rule zenon_and_1 [OF z_Hee])
       have z_Hhq: "?z_hhp((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))))" (is "?z_hgj=>?z_hhi")
       by (rule zenon_all_0 [of "?z_hhp" "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))", OF z_Hhl])
       show FALSE
       proof (rule zenon_imply [OF z_Hhq])
        assume z_Hgi:"(~?z_hgj)"
        show FALSE
        by (rule zenon_L1_ [OF z_Heh z_Hgi z_Hhc])
       next
        assume z_Hhi:"?z_hhi"
        have z_Hmb: "bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT})))))))" (is "?z_hmb")
        by (rule zenon_in_subsetof_1 [of "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))" "[''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))]" "(\<lambda>a_ca. bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>(((a_ca[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hhi])
        have z_Hhr_z_Hmb: "(\\A x:((x \\in ProcSet)=>((((pc[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((pc[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((pc[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))) == ?z_hmb" (is "?z_hhr == _")
        by (unfold bAll_def)
        have z_Hhr: "?z_hhr" (is "\\A x : ?z_hiz(x)")
        by (unfold z_Hhr_z_Hmb, fact z_Hmb)
        have z_Hjn: "(?z_hjo=ProcSet)"
        by (rule zenon_in_funcset_1 [of "pc" "ProcSet" "{''L0'', ?z_hs, ''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hm])
        have z_Hpz: "(\\A zenon_Vla:((zenon_Vla \\in ProcSet)=>((pc[zenon_Vla]) \\in {''L0'', ?z_hs, ''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''})))" (is "\\A x : ?z_hqf(x)")
        by (rule zenon_in_funcset_2 [of "pc" "ProcSet" "{''L0'', ?z_hs, ''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hm])
        have z_Hqg: "?z_hqf((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))" (is "_=>?z_hqh")
        by (rule zenon_all_0 [of "?z_hqf" "(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hpz])
        show FALSE
        proof (rule zenon_imply [OF z_Hqg])
         assume z_Hjc:"(~?z_hii)"
         show FALSE
         by (rule notE [OF z_Hjc z_Hii])
        next
         assume z_Hqh:"?z_hqh"
         show FALSE
         proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''L0''" "{?z_hs, ''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hqh])
          assume z_Hqj:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''L0'')" (is "?z_hiw=?z_hr")
          have z_Hri: "(?z_hr~=?z_hx)"
          by auto
          have z_Hky: "(?z_hiw~=?z_hdc)"
          by (rule zenon_stringdiffll [OF z_Hri z_Hqj z_He])
           have z_Hrj: "(?z_hr~=?z_hs)"
           by auto
           have z_Hjp: "(?z_hiw~=?z_hjq)"
           by (rule zenon_stringdiffll [OF z_Hrj z_Hqj z_Hrh])
            show FALSE
            by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
         next
          assume z_Hql:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {?z_hs, ''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''})" (is "?z_hql")
          show FALSE
          proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "?z_hs" "{''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hql])
           assume z_Hiv:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=?z_hs)" (is "?z_hiw=_")
           show FALSE
           by (rule zenon_L4_ [OF z_Hhr z_Hii z_Hiv z_Hix])
          next
           assume z_Hqn:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''})" (is "?z_hqn")
           show FALSE
           proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''E2''" "{''E3'', ''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hqn])
            assume z_Hqp:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''E2'')" (is "?z_hiw=?z_ht")
            have z_Hqq: "(?z_ht~=?z_hx)"
            by auto
            have z_Hky: "(?z_hiw~=?z_hdc)"
            by (rule zenon_stringdiffll [OF z_Hqq z_Hqp z_He])
             have z_Hrk: "(?z_ht~=?z_hs)"
             by auto
             have z_Hjp: "(?z_hiw~=?z_hjq)"
             by (rule zenon_stringdiffll [OF z_Hrk z_Hqp z_Hrh])
              show FALSE
              by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
           next
            assume z_Hqs:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''E3'', ''D1'', ''D2'', ?z_hx, ''D4''})" (is "?z_hqs")
            show FALSE
            proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''E3''" "{''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hqs])
             assume z_Hqu:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''E3'')" (is "?z_hiw=?z_hu")
             have z_Hqv: "(?z_hu~=?z_hx)"
             by auto
             have z_Hky: "(?z_hiw~=?z_hdc)"
             by (rule zenon_stringdiffll [OF z_Hqv z_Hqu z_He])
              have z_Hrl: "(?z_hu~=?z_hs)"
              by auto
              have z_Hjp: "(?z_hiw~=?z_hjq)"
              by (rule zenon_stringdiffll [OF z_Hrl z_Hqu z_Hrh])
               show FALSE
               by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
            next
             assume z_Hqx:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''D1'', ''D2'', ?z_hx, ''D4''})" (is "?z_hqx")
             show FALSE
             proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''D1''" "{''D2'', ?z_hx, ''D4''}", OF z_Hqx])
              assume z_Hlf:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''D1'')" (is "?z_hiw=?z_hv")
              show FALSE
              by (rule zenon_L7_ [OF z_Hhr z_Hii z_Hlf z_Hix])
             next
              assume z_Hqz:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''D2'', ?z_hx, ''D4''})" (is "?z_hqz")
              show FALSE
              proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''D2''" "{?z_hx, ''D4''}", OF z_Hqz])
               assume z_Hlk:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''D2'')" (is "?z_hiw=?z_hw")
               show FALSE
               by (rule zenon_L8_ [OF z_Hhr z_Hii z_Hlk z_Hix])
              next
               assume z_Hrb:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {?z_hx, ''D4''})" (is "?z_hrb")
               show FALSE
               proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "?z_hx" "{''D4''}", OF z_Hrb])
               assume z_Hlp:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=?z_hx)" (is "?z_hiw=_")
               show FALSE
               by (rule zenon_L9_ [OF z_Hhr z_Hii z_Hlp z_Hix])
               next
               assume z_Hom:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''D4''})" (is "?z_hom")
               show FALSE
               proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''D4''" "{}", OF z_Hom])
               assume z_Hrc:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''D4'')" (is "?z_hiw=?z_hy")
               have z_Hrd: "(?z_hy~=?z_hx)"
               by auto
               have z_Hky: "(?z_hiw~=?z_hdc)"
               by (rule zenon_stringdiffll [OF z_Hrd z_Hrc z_He])
               have z_Hrm: "(?z_hy~=?z_hs)"
               by auto
               have z_Hjp: "(?z_hiw~=?z_hjq)"
               by (rule zenon_stringdiffll [OF z_Hrm z_Hrc z_Hrh])
               show FALSE
               by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
               next
               assume z_Hrf:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {})" (is "?z_hrf")
               show FALSE
               by (rule zenon_in_emptyset [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])", OF z_Hrf])
               qed
               qed
              qed
             qed
            qed
           qed
          qed
         qed
        qed
       qed
      next
       assume z_Hpl:"((j[p])~=((l[p]) +  -.(1)))" (is "?z_hdu~=?z_hdx")
       assume z_Hej:"((a_jhash_primea=except(j, p, (?z_hdu + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M)))" (is "?z_hek&?z_hen")
       show FALSE
       by (rule zenon_L11_ [OF z_Hej z_Hhl z_Hhc z_Hii z_Hma z_Hix])
      qed
     next
      assume z_Hpm:"((Q[(j[p])])~=BOT)" (is "?z_hdt~=_")
      assume z_Hep:"((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ?z_hs, ''D1'', ''D2'', ?z_hx})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))))))" (is "?z_heq&?z_hes")
      show FALSE
      by (rule zenon_L12_ [OF z_Hep z_Hmp z_Hhc])
     qed
    next
     assume z_Hrn:"((a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''D1'', ''D2'', ?z_hx})" (is "?z_hrn")
     show FALSE
     proof (rule zenon_in_addElt [of "(a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''D1''" "{''D2'', ?z_hx}", OF z_Hrn])
      assume z_Hkv:"((a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''D1'')" (is "?z_hjq=?z_hv")
      have z_Hjn: "(DOMAIN(pc)=ProcSet)" (is "?z_hjo=_")
      by (rule zenon_in_funcset_1 [of "pc" "ProcSet" "{''L0'', ''E1'', ''E2'', ''E3'', ?z_hv, ''D2'', ?z_hx, ''D4''}", OF z_Hm])
      show FALSE
      proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vf. zenon_Vf)" "((Q[(j[p])])=BOT)" "cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ?z_hv))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))))" "((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))))))", OF z_Hd])
       assume z_Hds:"((Q[(j[p])])=BOT)" (is "?z_hdt=_")
       assume z_Hdv:"cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ?z_hv))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))))" (is "?z_hdv")
       show FALSE
       proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vf. zenon_Vf)" "((j[p])=((l[p]) +  -.(1)))" "((a_pchash_primea=except(pc, p, ?z_hv))&((a_jhash_primea=j)&(a_Mhash_primea=M)))" "((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M)))", OF z_Hdv])
        assume z_Hdw:"((j[p])=((l[p]) +  -.(1)))" (is "?z_hdu=?z_hdx")
        assume z_Hea:"((a_pchash_primea=except(pc, p, ?z_hv))&((a_jhash_primea=j)&(a_Mhash_primea=M)))" (is "?z_heb&?z_hee")
        have z_Heb: "?z_heb" (is "_=?z_hed")
        by (rule zenon_and_0 [OF z_Hea])
        have z_Hee: "?z_hee" (is "?z_hef&?z_heh")
        by (rule zenon_and_1 [OF z_Hea])
        have z_Heh: "?z_heh"
        by (rule zenon_and_1 [OF z_Hee])
        have z_Hhq: "?z_hhp((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))))" (is "?z_hgj=>?z_hhi")
        by (rule zenon_all_0 [of "?z_hhp" "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))", OF z_Hhl])
        show FALSE
        proof (rule zenon_imply [OF z_Hhq])
         assume z_Hgi:"(~?z_hgj)"
         show FALSE
         by (rule zenon_L1_ [OF z_Heh z_Hgi z_Hhc])
        next
         assume z_Hhi:"?z_hhi"
         have z_Hmb: "bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT})))))))" (is "?z_hmb")
         by (rule zenon_in_subsetof_1 [of "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))" "[''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))]" "(\<lambda>a_ca. bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>(((a_ca[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hhi])
         have z_Hhr_z_Hmb: "(\\A x:((x \\in ProcSet)=>((((pc[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((pc[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((pc[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))) == ?z_hmb" (is "?z_hhr == _")
         by (unfold bAll_def)
         have z_Hhr: "?z_hhr" (is "\\A x : ?z_hiz(x)")
         by (unfold z_Hhr_z_Hmb, fact z_Hmb)
         have z_Hjn: "(?z_hjo=ProcSet)"
         by (rule zenon_in_funcset_1 [of "pc" "ProcSet" "{''L0'', ''E1'', ''E2'', ''E3'', ?z_hv, ''D2'', ?z_hx, ''D4''}", OF z_Hm])
         have z_Hpz: "(\\A zenon_Vla:((zenon_Vla \\in ProcSet)=>((pc[zenon_Vla]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ?z_hv, ''D2'', ?z_hx, ''D4''})))" (is "\\A x : ?z_hqf(x)")
         by (rule zenon_in_funcset_2 [of "pc" "ProcSet" "{''L0'', ''E1'', ''E2'', ''E3'', ?z_hv, ''D2'', ?z_hx, ''D4''}", OF z_Hm])
         have z_Hqg: "?z_hqf((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))" (is "_=>?z_hqh")
         by (rule zenon_all_0 [of "?z_hqf" "(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hpz])
         show FALSE
         proof (rule zenon_imply [OF z_Hqg])
          assume z_Hjc:"(~?z_hii)"
          show FALSE
          by (rule notE [OF z_Hjc z_Hii])
         next
          assume z_Hqh:"?z_hqh"
          show FALSE
          proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''L0''" "{''E1'', ''E2'', ''E3'', ?z_hv, ''D2'', ?z_hx, ''D4''}", OF z_Hqh])
           assume z_Hqj:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''L0'')" (is "?z_hiw=?z_hr")
           have z_Hri: "(?z_hr~=?z_hx)"
           by auto
           have z_Hky: "(?z_hiw~=?z_hdc)"
           by (rule zenon_stringdiffll [OF z_Hri z_Hqj z_He])
            have z_Hro: "(?z_hr~=?z_hv)"
            by auto
            have z_Hjp: "(?z_hiw~=?z_hjq)"
            by (rule zenon_stringdiffll [OF z_Hro z_Hqj z_Hkv])
             show FALSE
             by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
          next
           assume z_Hql:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''E1'', ''E2'', ''E3'', ?z_hv, ''D2'', ?z_hx, ''D4''})" (is "?z_hql")
           show FALSE
           proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''E1''" "{''E2'', ''E3'', ?z_hv, ''D2'', ?z_hx, ''D4''}", OF z_Hql])
            assume z_Hiv:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''E1'')" (is "?z_hiw=?z_hs")
            have z_Hrp: "(?z_hs~=?z_hx)"
            by auto
            have z_Hky: "(?z_hiw~=?z_hdc)"
            by (rule zenon_stringdiffll [OF z_Hrp z_Hiv z_He])
             have z_Hrq: "(?z_hs~=?z_hv)"
             by auto
             have z_Hjp: "(?z_hiw~=?z_hjq)"
             by (rule zenon_stringdiffll [OF z_Hrq z_Hiv z_Hkv])
              show FALSE
              by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
           next
            assume z_Hqn:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''E2'', ''E3'', ?z_hv, ''D2'', ?z_hx, ''D4''})" (is "?z_hqn")
            show FALSE
            proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''E2''" "{''E3'', ?z_hv, ''D2'', ?z_hx, ''D4''}", OF z_Hqn])
             assume z_Hqp:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''E2'')" (is "?z_hiw=?z_ht")
             have z_Hqq: "(?z_ht~=?z_hx)"
             by auto
             have z_Hky: "(?z_hiw~=?z_hdc)"
             by (rule zenon_stringdiffll [OF z_Hqq z_Hqp z_He])
              have z_Hrr: "(?z_ht~=?z_hv)"
              by auto
              have z_Hjp: "(?z_hiw~=?z_hjq)"
              by (rule zenon_stringdiffll [OF z_Hrr z_Hqp z_Hkv])
               show FALSE
               by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
            next
             assume z_Hqs:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''E3'', ?z_hv, ''D2'', ?z_hx, ''D4''})" (is "?z_hqs")
             show FALSE
             proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''E3''" "{?z_hv, ''D2'', ?z_hx, ''D4''}", OF z_Hqs])
              assume z_Hqu:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''E3'')" (is "?z_hiw=?z_hu")
              have z_Hqv: "(?z_hu~=?z_hx)"
              by auto
              have z_Hky: "(?z_hiw~=?z_hdc)"
              by (rule zenon_stringdiffll [OF z_Hqv z_Hqu z_He])
               have z_Hrs: "(?z_hu~=?z_hv)"
               by auto
               have z_Hjp: "(?z_hiw~=?z_hjq)"
               by (rule zenon_stringdiffll [OF z_Hrs z_Hqu z_Hkv])
               show FALSE
               by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
             next
              assume z_Hqx:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {?z_hv, ''D2'', ?z_hx, ''D4''})" (is "?z_hqx")
              show FALSE
              proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "?z_hv" "{''D2'', ?z_hx, ''D4''}", OF z_Hqx])
               assume z_Hlf:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=?z_hv)" (is "?z_hiw=_")
               show FALSE
               by (rule zenon_L7_ [OF z_Hhr z_Hii z_Hlf z_Hix])
              next
               assume z_Hqz:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''D2'', ?z_hx, ''D4''})" (is "?z_hqz")
               show FALSE
               proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''D2''" "{?z_hx, ''D4''}", OF z_Hqz])
               assume z_Hlk:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''D2'')" (is "?z_hiw=?z_hw")
               show FALSE
               by (rule zenon_L8_ [OF z_Hhr z_Hii z_Hlk z_Hix])
               next
               assume z_Hrb:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {?z_hx, ''D4''})" (is "?z_hrb")
               show FALSE
               proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "?z_hx" "{''D4''}", OF z_Hrb])
               assume z_Hlp:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=?z_hx)" (is "?z_hiw=_")
               show FALSE
               by (rule zenon_L9_ [OF z_Hhr z_Hii z_Hlp z_Hix])
               next
               assume z_Hom:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''D4''})" (is "?z_hom")
               show FALSE
               proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''D4''" "{}", OF z_Hom])
               assume z_Hrc:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''D4'')" (is "?z_hiw=?z_hy")
               have z_Hrd: "(?z_hy~=?z_hx)"
               by auto
               have z_Hky: "(?z_hiw~=?z_hdc)"
               by (rule zenon_stringdiffll [OF z_Hrd z_Hrc z_He])
               have z_Hrt: "(?z_hy~=?z_hv)"
               by auto
               have z_Hjp: "(?z_hiw~=?z_hjq)"
               by (rule zenon_stringdiffll [OF z_Hrt z_Hrc z_Hkv])
               show FALSE
               by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
               next
               assume z_Hrf:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {})" (is "?z_hrf")
               show FALSE
               by (rule zenon_in_emptyset [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])", OF z_Hrf])
               qed
               qed
               qed
              qed
             qed
            qed
           qed
          qed
         qed
        qed
       next
        assume z_Hpl:"((j[p])~=((l[p]) +  -.(1)))" (is "?z_hdu~=?z_hdx")
        assume z_Hej:"((a_jhash_primea=except(j, p, (?z_hdu + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M)))" (is "?z_hek&?z_hen")
        show FALSE
        by (rule zenon_L11_ [OF z_Hej z_Hhl z_Hhc z_Hii z_Hma z_Hix])
       qed
      next
       assume z_Hpm:"((Q[(j[p])])~=BOT)" (is "?z_hdt~=_")
       assume z_Hep:"((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ?z_hv, ''D2'', ?z_hx})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))))))" (is "?z_heq&?z_hes")
       show FALSE
       by (rule zenon_L12_ [OF z_Hep z_Hmp z_Hhc])
      qed
     next
      assume z_Hru:"((a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''D2'', ?z_hx})" (is "?z_hru")
      show FALSE
      proof (rule zenon_in_addElt [of "(a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''D2''" "{?z_hx}", OF z_Hru])
       assume z_Hrv:"((a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''D2'')" (is "?z_hjq=?z_hw")
       have z_Hjn: "(DOMAIN(pc)=ProcSet)" (is "?z_hjo=_")
       by (rule zenon_in_funcset_1 [of "pc" "ProcSet" "{''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ?z_hw, ?z_hx, ''D4''}", OF z_Hm])
       show FALSE
       proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vf. zenon_Vf)" "((Q[(j[p])])=BOT)" "cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))))" "((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))))))", OF z_Hd])
        assume z_Hds:"((Q[(j[p])])=BOT)" (is "?z_hdt=_")
        assume z_Hdv:"cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))))" (is "?z_hdv")
        show FALSE
        proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vf. zenon_Vf)" "((j[p])=((l[p]) +  -.(1)))" "((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M)))" "((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M)))", OF z_Hdv])
         assume z_Hdw:"((j[p])=((l[p]) +  -.(1)))" (is "?z_hdu=?z_hdx")
         assume z_Hea:"((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M)))" (is "?z_heb&?z_hee")
         have z_Heb: "?z_heb" (is "_=?z_hed")
         by (rule zenon_and_0 [OF z_Hea])
         have z_Hee: "?z_hee" (is "?z_hef&?z_heh")
         by (rule zenon_and_1 [OF z_Hea])
         have z_Heh: "?z_heh"
         by (rule zenon_and_1 [OF z_Hee])
         have z_Hhq: "?z_hhp((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))))" (is "?z_hgj=>?z_hhi")
         by (rule zenon_all_0 [of "?z_hhp" "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))", OF z_Hhl])
         show FALSE
         proof (rule zenon_imply [OF z_Hhq])
          assume z_Hgi:"(~?z_hgj)"
          show FALSE
          by (rule zenon_L1_ [OF z_Heh z_Hgi z_Hhc])
         next
          assume z_Hhi:"?z_hhi"
          have z_Hmb: "bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT})))))))" (is "?z_hmb")
          by (rule zenon_in_subsetof_1 [of "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))" "[''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))]" "(\<lambda>a_ca. bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>(((a_ca[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hhi])
          have z_Hhr_z_Hmb: "(\\A x:((x \\in ProcSet)=>((((pc[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((pc[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((pc[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))) == ?z_hmb" (is "?z_hhr == _")
          by (unfold bAll_def)
          have z_Hhr: "?z_hhr" (is "\\A x : ?z_hiz(x)")
          by (unfold z_Hhr_z_Hmb, fact z_Hmb)
          have z_Hjn: "(?z_hjo=ProcSet)"
          by (rule zenon_in_funcset_1 [of "pc" "ProcSet" "{''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ?z_hw, ?z_hx, ''D4''}", OF z_Hm])
          have z_Hpz: "(\\A zenon_Vla:((zenon_Vla \\in ProcSet)=>((pc[zenon_Vla]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ?z_hw, ?z_hx, ''D4''})))" (is "\\A x : ?z_hqf(x)")
          by (rule zenon_in_funcset_2 [of "pc" "ProcSet" "{''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ?z_hw, ?z_hx, ''D4''}", OF z_Hm])
          have z_Hqg: "?z_hqf((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))" (is "_=>?z_hqh")
          by (rule zenon_all_0 [of "?z_hqf" "(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hpz])
          show FALSE
          proof (rule zenon_imply [OF z_Hqg])
           assume z_Hjc:"(~?z_hii)"
           show FALSE
           by (rule notE [OF z_Hjc z_Hii])
          next
           assume z_Hqh:"?z_hqh"
           show FALSE
           proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''L0''" "{''E1'', ''E2'', ''E3'', ''D1'', ?z_hw, ?z_hx, ''D4''}", OF z_Hqh])
            assume z_Hqj:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''L0'')" (is "?z_hiw=?z_hr")
            have z_Hri: "(?z_hr~=?z_hx)"
            by auto
            have z_Hky: "(?z_hiw~=?z_hdc)"
            by (rule zenon_stringdiffll [OF z_Hri z_Hqj z_He])
             have z_Hrw: "(?z_hr~=?z_hw)"
             by auto
             have z_Hjp: "(?z_hiw~=?z_hjq)"
             by (rule zenon_stringdiffll [OF z_Hrw z_Hqj z_Hrv])
              show FALSE
              by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
           next
            assume z_Hql:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''E1'', ''E2'', ''E3'', ''D1'', ?z_hw, ?z_hx, ''D4''})" (is "?z_hql")
            show FALSE
            proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''E1''" "{''E2'', ''E3'', ''D1'', ?z_hw, ?z_hx, ''D4''}", OF z_Hql])
             assume z_Hiv:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''E1'')" (is "?z_hiw=?z_hs")
             have z_Hrp: "(?z_hs~=?z_hx)"
             by auto
             have z_Hky: "(?z_hiw~=?z_hdc)"
             by (rule zenon_stringdiffll [OF z_Hrp z_Hiv z_He])
              have z_Hrx: "(?z_hs~=?z_hw)"
              by auto
              have z_Hjp: "(?z_hiw~=?z_hjq)"
              by (rule zenon_stringdiffll [OF z_Hrx z_Hiv z_Hrv])
               show FALSE
               by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
            next
             assume z_Hqn:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''E2'', ''E3'', ''D1'', ?z_hw, ?z_hx, ''D4''})" (is "?z_hqn")
             show FALSE
             proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''E2''" "{''E3'', ''D1'', ?z_hw, ?z_hx, ''D4''}", OF z_Hqn])
              assume z_Hqp:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''E2'')" (is "?z_hiw=?z_ht")
              have z_Hqq: "(?z_ht~=?z_hx)"
              by auto
              have z_Hky: "(?z_hiw~=?z_hdc)"
              by (rule zenon_stringdiffll [OF z_Hqq z_Hqp z_He])
               have z_Hry: "(?z_ht~=?z_hw)"
               by auto
               have z_Hjp: "(?z_hiw~=?z_hjq)"
               by (rule zenon_stringdiffll [OF z_Hry z_Hqp z_Hrv])
               show FALSE
               by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
             next
              assume z_Hqs:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''E3'', ''D1'', ?z_hw, ?z_hx, ''D4''})" (is "?z_hqs")
              show FALSE
              proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''E3''" "{''D1'', ?z_hw, ?z_hx, ''D4''}", OF z_Hqs])
               assume z_Hqu:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''E3'')" (is "?z_hiw=?z_hu")
               have z_Hqv: "(?z_hu~=?z_hx)"
               by auto
               have z_Hky: "(?z_hiw~=?z_hdc)"
               by (rule zenon_stringdiffll [OF z_Hqv z_Hqu z_He])
               have z_Hrz: "(?z_hu~=?z_hw)"
               by auto
               have z_Hjp: "(?z_hiw~=?z_hjq)"
               by (rule zenon_stringdiffll [OF z_Hrz z_Hqu z_Hrv])
               show FALSE
               by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
              next
               assume z_Hqx:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''D1'', ?z_hw, ?z_hx, ''D4''})" (is "?z_hqx")
               show FALSE
               proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''D1''" "{?z_hw, ?z_hx, ''D4''}", OF z_Hqx])
               assume z_Hlf:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''D1'')" (is "?z_hiw=?z_hv")
               have z_Hsa: "(?z_hv~=?z_hx)"
               by auto
               have z_Hky: "(?z_hiw~=?z_hdc)"
               by (rule zenon_stringdiffll [OF z_Hsa z_Hlf z_He])
               have z_Hsb: "(?z_hv~=?z_hw)"
               by auto
               have z_Hjp: "(?z_hiw~=?z_hjq)"
               by (rule zenon_stringdiffll [OF z_Hsb z_Hlf z_Hrv])
               show FALSE
               by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
               next
               assume z_Hqz:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {?z_hw, ?z_hx, ''D4''})" (is "?z_hqz")
               show FALSE
               proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "?z_hw" "{?z_hx, ''D4''}", OF z_Hqz])
               assume z_Hlk:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=?z_hw)" (is "?z_hiw=_")
               show FALSE
               by (rule zenon_L8_ [OF z_Hhr z_Hii z_Hlk z_Hix])
               next
               assume z_Hrb:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {?z_hx, ''D4''})" (is "?z_hrb")
               show FALSE
               proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "?z_hx" "{''D4''}", OF z_Hrb])
               assume z_Hlp:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=?z_hx)" (is "?z_hiw=_")
               show FALSE
               by (rule zenon_L9_ [OF z_Hhr z_Hii z_Hlp z_Hix])
               next
               assume z_Hom:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''D4''})" (is "?z_hom")
               show FALSE
               proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''D4''" "{}", OF z_Hom])
               assume z_Hrc:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''D4'')" (is "?z_hiw=?z_hy")
               have z_Hrd: "(?z_hy~=?z_hx)"
               by auto
               have z_Hky: "(?z_hiw~=?z_hdc)"
               by (rule zenon_stringdiffll [OF z_Hrd z_Hrc z_He])
               have z_Hsc: "(?z_hy~=?z_hw)"
               by auto
               have z_Hjp: "(?z_hiw~=?z_hjq)"
               by (rule zenon_stringdiffll [OF z_Hsc z_Hrc z_Hrv])
               show FALSE
               by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
               next
               assume z_Hrf:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {})" (is "?z_hrf")
               show FALSE
               by (rule zenon_in_emptyset [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])", OF z_Hrf])
               qed
               qed
               qed
               qed
              qed
             qed
            qed
           qed
          qed
         qed
        next
         assume z_Hpl:"((j[p])~=((l[p]) +  -.(1)))" (is "?z_hdu~=?z_hdx")
         assume z_Hej:"((a_jhash_primea=except(j, p, (?z_hdu + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M)))" (is "?z_hek&?z_hen")
         show FALSE
         by (rule zenon_L11_ [OF z_Hej z_Hhl z_Hhc z_Hii z_Hma z_Hix])
        qed
       next
        assume z_Hpm:"((Q[(j[p])])~=BOT)" (is "?z_hdt~=_")
        assume z_Hep:"((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ?z_hw, ?z_hx})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))))))" (is "?z_heq&?z_hes")
        show FALSE
        by (rule zenon_L12_ [OF z_Hep z_Hmp z_Hhc])
       qed
      next
       assume z_Hsd:"((a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {?z_hx})" (is "?z_hsd")
       show FALSE
       proof (rule zenon_in_addElt [of "(a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "?z_hx" "{}", OF z_Hsd])
        assume z_Hse:"((a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=?z_hx)" (is "?z_hjq=_")
        have z_Hjn: "(DOMAIN(pc)=ProcSet)" (is "?z_hjo=_")
        by (rule zenon_in_funcset_1 [of "pc" "ProcSet" "{''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hm])
        show FALSE
        proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vf. zenon_Vf)" "((Q[(j[p])])=BOT)" "cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))))" "((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))))))", OF z_Hd])
         assume z_Hds:"((Q[(j[p])])=BOT)" (is "?z_hdt=_")
         assume z_Hdv:"cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))))" (is "?z_hdv")
         show FALSE
         proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vf. zenon_Vf)" "((j[p])=((l[p]) +  -.(1)))" "((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M)))" "((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M)))", OF z_Hdv])
          assume z_Hdw:"((j[p])=((l[p]) +  -.(1)))" (is "?z_hdu=?z_hdx")
          assume z_Hea:"((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M)))" (is "?z_heb&?z_hee")
          have z_Heb: "?z_heb" (is "_=?z_hed")
          by (rule zenon_and_0 [OF z_Hea])
          have z_Hee: "?z_hee" (is "?z_hef&?z_heh")
          by (rule zenon_and_1 [OF z_Hea])
          have z_Heh: "?z_heh"
          by (rule zenon_and_1 [OF z_Hee])
          have z_Hhq: "?z_hhp((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))))" (is "?z_hgj=>?z_hhi")
          by (rule zenon_all_0 [of "?z_hhp" "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))", OF z_Hhl])
          show FALSE
          proof (rule zenon_imply [OF z_Hhq])
           assume z_Hgi:"(~?z_hgj)"
           show FALSE
           by (rule zenon_L1_ [OF z_Heh z_Hgi z_Hhc])
          next
           assume z_Hhi:"?z_hhi"
           have z_Hmb: "bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT})))))))" (is "?z_hmb")
           by (rule zenon_in_subsetof_1 [of "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))" "[''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))]" "(\<lambda>a_ca. bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>(((a_ca[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hhi])
           have z_Hhr_z_Hmb: "(\\A x:((x \\in ProcSet)=>((((pc[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((pc[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((pc[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))) == ?z_hmb" (is "?z_hhr == _")
           by (unfold bAll_def)
           have z_Hhr: "?z_hhr" (is "\\A x : ?z_hiz(x)")
           by (unfold z_Hhr_z_Hmb, fact z_Hmb)
           have z_Hjn: "(?z_hjo=ProcSet)"
           by (rule zenon_in_funcset_1 [of "pc" "ProcSet" "{''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hm])
           have z_Hpz: "(\\A zenon_Vla:((zenon_Vla \\in ProcSet)=>((pc[zenon_Vla]) \\in {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''})))" (is "\\A x : ?z_hqf(x)")
           by (rule zenon_in_funcset_2 [of "pc" "ProcSet" "{''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hm])
           have z_Hqg: "?z_hqf((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))" (is "_=>?z_hqh")
           by (rule zenon_all_0 [of "?z_hqf" "(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hpz])
           show FALSE
           proof (rule zenon_imply [OF z_Hqg])
            assume z_Hjc:"(~?z_hii)"
            show FALSE
            by (rule notE [OF z_Hjc z_Hii])
           next
            assume z_Hqh:"?z_hqh"
            show FALSE
            proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''L0''" "{''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hqh])
             assume z_Hqj:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''L0'')" (is "?z_hiw=?z_hr")
             have z_Hri: "(?z_hr~=?z_hx)"
             by auto
             have z_Hky: "(?z_hiw~=?z_hdc)"
             by (rule zenon_stringdiffll [OF z_Hri z_Hqj z_He])
              have z_Hri: "(?z_hr~=?z_hx)"
              by auto
              have z_Hjp: "(?z_hiw~=?z_hjq)"
              by (rule zenon_stringdiffll [OF z_Hri z_Hqj z_Hse])
               show FALSE
               by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
            next
             assume z_Hql:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''})" (is "?z_hql")
             show FALSE
             proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''E1''" "{''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hql])
              assume z_Hiv:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''E1'')" (is "?z_hiw=?z_hs")
              have z_Hrp: "(?z_hs~=?z_hx)"
              by auto
              have z_Hky: "(?z_hiw~=?z_hdc)"
              by (rule zenon_stringdiffll [OF z_Hrp z_Hiv z_He])
               have z_Hrp: "(?z_hs~=?z_hx)"
               by auto
               have z_Hjp: "(?z_hiw~=?z_hjq)"
               by (rule zenon_stringdiffll [OF z_Hrp z_Hiv z_Hse])
               show FALSE
               by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
             next
              assume z_Hqn:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''})" (is "?z_hqn")
              show FALSE
              proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''E2''" "{''E3'', ''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hqn])
               assume z_Hqp:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''E2'')" (is "?z_hiw=?z_ht")
               have z_Hqq: "(?z_ht~=?z_hx)"
               by auto
               have z_Hky: "(?z_hiw~=?z_hdc)"
               by (rule zenon_stringdiffll [OF z_Hqq z_Hqp z_He])
               have z_Hqq: "(?z_ht~=?z_hx)"
               by auto
               have z_Hjp: "(?z_hiw~=?z_hjq)"
               by (rule zenon_stringdiffll [OF z_Hqq z_Hqp z_Hse])
               show FALSE
               by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
              next
               assume z_Hqs:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''E3'', ''D1'', ''D2'', ?z_hx, ''D4''})" (is "?z_hqs")
               show FALSE
               proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''E3''" "{''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hqs])
               assume z_Hqu:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''E3'')" (is "?z_hiw=?z_hu")
               have z_Hqv: "(?z_hu~=?z_hx)"
               by auto
               have z_Hky: "(?z_hiw~=?z_hdc)"
               by (rule zenon_stringdiffll [OF z_Hqv z_Hqu z_He])
               have z_Hqv: "(?z_hu~=?z_hx)"
               by auto
               have z_Hjp: "(?z_hiw~=?z_hjq)"
               by (rule zenon_stringdiffll [OF z_Hqv z_Hqu z_Hse])
               show FALSE
               by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
               next
               assume z_Hqx:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''D1'', ''D2'', ?z_hx, ''D4''})" (is "?z_hqx")
               show FALSE
               proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''D1''" "{''D2'', ?z_hx, ''D4''}", OF z_Hqx])
               assume z_Hlf:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''D1'')" (is "?z_hiw=?z_hv")
               have z_Hsa: "(?z_hv~=?z_hx)"
               by auto
               have z_Hky: "(?z_hiw~=?z_hdc)"
               by (rule zenon_stringdiffll [OF z_Hsa z_Hlf z_He])
               have z_Hsa: "(?z_hv~=?z_hx)"
               by auto
               have z_Hjp: "(?z_hiw~=?z_hjq)"
               by (rule zenon_stringdiffll [OF z_Hsa z_Hlf z_Hse])
               show FALSE
               by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
               next
               assume z_Hqz:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''D2'', ?z_hx, ''D4''})" (is "?z_hqz")
               show FALSE
               proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''D2''" "{?z_hx, ''D4''}", OF z_Hqz])
               assume z_Hlk:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''D2'')" (is "?z_hiw=?z_hw")
               have z_Hsf: "(?z_hw~=?z_hx)"
               by auto
               have z_Hky: "(?z_hiw~=?z_hdc)"
               by (rule zenon_stringdiffll [OF z_Hsf z_Hlk z_He])
               have z_Hsf: "(?z_hw~=?z_hx)"
               by auto
               have z_Hjp: "(?z_hiw~=?z_hjq)"
               by (rule zenon_stringdiffll [OF z_Hsf z_Hlk z_Hse])
               show FALSE
               by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
               next
               assume z_Hrb:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {?z_hx, ''D4''})" (is "?z_hrb")
               show FALSE
               proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "?z_hx" "{''D4''}", OF z_Hrb])
               assume z_Hlp:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=?z_hx)" (is "?z_hiw=_")
               show FALSE
               by (rule zenon_L9_ [OF z_Hhr z_Hii z_Hlp z_Hix])
               next
               assume z_Hom:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''D4''})" (is "?z_hom")
               show FALSE
               proof (rule zenon_in_addElt [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''D4''" "{}", OF z_Hom])
               assume z_Hrc:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''D4'')" (is "?z_hiw=?z_hy")
               have z_Hrd: "(?z_hy~=?z_hx)"
               by auto
               have z_Hky: "(?z_hiw~=?z_hdc)"
               by (rule zenon_stringdiffll [OF z_Hrd z_Hrc z_He])
               have z_Hrd: "(?z_hy~=?z_hx)"
               by auto
               have z_Hjp: "(?z_hiw~=?z_hjq)"
               by (rule zenon_stringdiffll [OF z_Hrd z_Hrc z_Hse])
               show FALSE
               by (rule zenon_L6_ [OF z_Hky z_Heb z_Hii z_Hjp z_Hjn])
               next
               assume z_Hrf:"((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {})" (is "?z_hrf")
               show FALSE
               by (rule zenon_in_emptyset [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])", OF z_Hrf])
               qed
               qed
               qed
               qed
               qed
              qed
             qed
            qed
           qed
          qed
         next
          assume z_Hpl:"((j[p])~=((l[p]) +  -.(1)))" (is "?z_hdu~=?z_hdx")
          assume z_Hej:"((a_jhash_primea=except(j, p, (?z_hdu + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M)))" (is "?z_hek&?z_hen")
          show FALSE
          by (rule zenon_L11_ [OF z_Hej z_Hhl z_Hhc z_Hii z_Hma z_Hix])
         qed
        next
         assume z_Hpm:"((Q[(j[p])])~=BOT)" (is "?z_hdt~=_")
         assume z_Hep:"((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))))))" (is "?z_heq&?z_hes")
         show FALSE
         by (rule zenon_L12_ [OF z_Hep z_Hmp z_Hhc])
        qed
       next
        assume z_Hsg:"((a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {})" (is "?z_hsg")
        show FALSE
        by (rule zenon_in_emptyset [of "(a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])", OF z_Hsg])
       qed
      qed
     qed
    qed
   qed
  next
   assume z_Hsh:"(~?z_hpw)" (is "~(?z_hsi&?z_hsj)")
   show FALSE
   proof (rule zenon_notand [OF z_Hsh])
    assume z_Hsk:"(~?z_hsi)" (is "~(?z_hsl=>?z_hsm)")
    have z_Hsl: "?z_hsl"
    by (rule zenon_notimply_0 [OF z_Hsk])
    have z_Hsn: "(~?z_hsm)"
    by (rule zenon_notimply_1 [OF z_Hsk])
    have z_Hso: "(~((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {BOT}))" (is "~?z_hsp")
    by (rule zenon_notin_addElt_1 [of "(((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "ACK" "{BOT}", OF z_Hsn])
    have z_Hix: "((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=BOT)" (is "?z_hiy~=_")
    by (rule zenon_notin_addElt_0 [of "?z_hiy" "BOT" "{}", OF z_Hso])
    have z_Hjn: "(DOMAIN(pc)=ProcSet)" (is "?z_hjo=_")
    by (rule zenon_in_funcset_1 [of "pc" "ProcSet" "{''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hm])
    show FALSE
    proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vf. zenon_Vf)" "((Q[(j[p])])=BOT)" "cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))))" "((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))))))", OF z_Hd])
     assume z_Hds:"((Q[(j[p])])=BOT)" (is "?z_hdt=_")
     assume z_Hdv:"cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))))" (is "?z_hdv")
     show FALSE
     proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vf. zenon_Vf)" "((j[p])=((l[p]) +  -.(1)))" "((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M)))" "((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M)))", OF z_Hdv])
      assume z_Hdw:"((j[p])=((l[p]) +  -.(1)))" (is "?z_hdu=?z_hdx")
      assume z_Hea:"((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M)))" (is "?z_heb&?z_hee")
      have z_Heb: "?z_heb" (is "_=?z_hed")
      by (rule zenon_and_0 [OF z_Hea])
      have z_Hee: "?z_hee" (is "?z_hef&?z_heh")
      by (rule zenon_and_1 [OF z_Hea])
      have z_Heh: "?z_heh"
      by (rule zenon_and_1 [OF z_Hee])
      have z_Hhq: "?z_hhp((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))))" (is "?z_hgj=>?z_hhi")
      by (rule zenon_all_0 [of "?z_hhp" "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))", OF z_Hhl])
      show FALSE
      proof (rule zenon_imply [OF z_Hhq])
       assume z_Hgi:"(~?z_hgj)"
       show FALSE
       by (rule zenon_L1_ [OF z_Heh z_Hgi z_Hhc])
      next
       assume z_Hhi:"?z_hhi"
       have z_Hmb: "bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT})))))))" (is "?z_hmb")
       by (rule zenon_in_subsetof_1 [of "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))" "[''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))]" "(\<lambda>a_ca. bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>(((a_ca[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hhi])
       have z_Hhr_z_Hmb: "(\\A x:((x \\in ProcSet)=>((((pc[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((pc[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((pc[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))) == ?z_hmb" (is "?z_hhr == _")
       by (unfold bAll_def)
       have z_Hhr: "?z_hhr" (is "\\A x : ?z_hiz(x)")
       by (unfold z_Hhr_z_Hmb, fact z_Hmb)
       have z_Hja: "?z_hiz((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))" (is "_=>?z_hjb")
       by (rule zenon_all_0 [of "?z_hiz" "(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hhr])
       show FALSE
       proof (rule zenon_imply [OF z_Hja])
        assume z_Hjc:"(~?z_hii)"
        show FALSE
        by (rule notE [OF z_Hjc z_Hii])
       next
        assume z_Hjb:"?z_hjb" (is "?z_hjd&?z_hje")
        have z_Hjd: "?z_hjd" (is "?z_hjf=>?z_hjg")
        by (rule zenon_and_0 [OF z_Hjb])
        have z_Hje: "?z_hje" (is "?z_hok&?z_hol")
        by (rule zenon_and_1 [OF z_Hjb])
        have z_Hok: "?z_hok" (is "?z_hsq=>_")
        by (rule zenon_and_0 [OF z_Hje])
        show FALSE
        proof (rule zenon_imply [OF z_Hjd])
         assume z_Hjh:"(~?z_hjf)"
         have z_Hji: "(~((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''E1'', ''D1'', ''D2'', ?z_hx}))" (is "~?z_hjj")
         by (rule zenon_notin_addElt_1 [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''L0''" "{''E1'', ''D1'', ''D2'', ?z_hx}", OF z_Hjh])
         have z_Hlg: "(~((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''D1'', ''D2'', ?z_hx}))" (is "~?z_hlh")
         by (rule zenon_notin_addElt_1 [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''E1''" "{''D1'', ''D2'', ?z_hx}", OF z_Hji])
         have z_Hll: "(~((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''D2'', ?z_hx}))" (is "~?z_hlm")
         by (rule zenon_notin_addElt_1 [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''D1''" "{''D2'', ?z_hx}", OF z_Hlg])
         have z_Hlq: "(~((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {?z_hx}))" (is "~?z_hlr")
         by (rule zenon_notin_addElt_1 [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''D2''" "{?z_hx}", OF z_Hll])
         have z_Hls: "((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=?z_hx)" (is "?z_hiw~=_")
         by (rule zenon_notin_addElt_0 [of "?z_hiw" "?z_hx" "{}", OF z_Hlq])
         show FALSE
         proof (rule zenon_imply [OF z_Hok])
          assume z_Hsr:"(~?z_hsq)"
          show FALSE
          proof (rule notE [OF z_Hsr])
           have z_Hkx: "((a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=?z_hiw)" (is "?z_hjq=_")
           proof (rule zenon_nnpp [of "(?z_hjq=?z_hiw)"])
            assume z_Hlu:"(?z_hjq~=?z_hiw)"
            show FALSE
            by (rule zenon_L14_ [OF z_Hls z_He z_Hjn z_Hlu z_Hii z_Heb])
           qed
           have z_Hsq: "?z_hsq"
           by (rule subst [where P="(\<lambda>zenon_Vkkp. (zenon_Vkkp \\in {''E2'', ''E3''}))", OF z_Hkx], fact z_Hsl)
           thus "?z_hsq" .
          qed
         next
          assume z_Hsm:"?z_hsm"
          show FALSE
          by (rule notE [OF z_Hsn z_Hsm])
         qed
        next
         assume z_Hjg:"?z_hjg"
         show FALSE
         by (rule notE [OF z_Hix z_Hjg])
        qed
       qed
      qed
     next
      assume z_Hpl:"((j[p])~=((l[p]) +  -.(1)))" (is "?z_hdu~=?z_hdx")
      assume z_Hej:"((a_jhash_primea=except(j, p, (?z_hdu + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M)))" (is "?z_hek&?z_hen")
      have z_Hen: "?z_hen" (is "?z_heo&?z_heh")
      by (rule zenon_and_1 [OF z_Hej])
      have z_Heo: "?z_heo"
      by (rule zenon_and_0 [OF z_Hen])
      have z_Heh: "?z_heh"
      by (rule zenon_and_1 [OF z_Hen])
      have z_Hhq: "?z_hhp((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))))" (is "?z_hgj=>?z_hhi")
      by (rule zenon_all_0 [of "?z_hhp" "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))", OF z_Hhl])
      show FALSE
      proof (rule zenon_imply [OF z_Hhq])
       assume z_Hgi:"(~?z_hgj)"
       show FALSE
       by (rule zenon_L1_ [OF z_Heh z_Hgi z_Hhc])
      next
       assume z_Hhi:"?z_hhi"
       have z_Hmb: "bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT})))))))" (is "?z_hmb")
       by (rule zenon_in_subsetof_1 [of "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))" "[''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))]" "(\<lambda>a_ca. bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>(((a_ca[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hhi])
       have z_Hhr_z_Hmb: "(\\A x:((x \\in ProcSet)=>((((pc[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((pc[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((pc[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))) == ?z_hmb" (is "?z_hhr == _")
       by (unfold bAll_def)
       have z_Hhr: "?z_hhr" (is "\\A x : ?z_hiz(x)")
       by (unfold z_Hhr_z_Hmb, fact z_Hmb)
       have z_Hja: "?z_hiz((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))" (is "_=>?z_hjb")
       by (rule zenon_all_0 [of "?z_hiz" "(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hhr])
       show FALSE
       proof (rule zenon_imply [OF z_Hja])
        assume z_Hjc:"(~?z_hii)"
        show FALSE
        by (rule notE [OF z_Hjc z_Hii])
       next
        assume z_Hjb:"?z_hjb" (is "?z_hjd&?z_hje")
        have z_Hje: "?z_hje" (is "?z_hok&?z_hol")
        by (rule zenon_and_1 [OF z_Hjb])
        have z_Hok: "?z_hok" (is "?z_hsq=>_")
        by (rule zenon_and_0 [OF z_Hje])
        show FALSE
        proof (rule zenon_imply [OF z_Hok])
         assume z_Hsr:"(~?z_hsq)"
         show FALSE
         proof (rule notE [OF z_Hsr])
          have z_Hkx: "((a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]))" (is "?z_hjq=?z_hiw")
          proof (rule zenon_nnpp [of "(?z_hjq=?z_hiw)"])
           assume z_Hlu:"(?z_hjq~=?z_hiw)"
           show FALSE
           by (rule zenon_L10_ [OF z_Hlu z_Heo])
          qed
          have z_Hsq: "?z_hsq"
          by (rule subst [where P="(\<lambda>zenon_Vkkp. (zenon_Vkkp \\in {''E2'', ''E3''}))", OF z_Hkx], fact z_Hsl)
          thus "?z_hsq" .
         qed
        next
         assume z_Hsm:"?z_hsm"
         show FALSE
         by (rule notE [OF z_Hsn z_Hsm])
        qed
       qed
      qed
     qed
    next
     assume z_Hpm:"((Q[(j[p])])~=BOT)" (is "?z_hdt~=_")
     assume z_Hep:"((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))))))" (is "?z_heq&?z_hes")
     show FALSE
     by (rule zenon_L12_ [OF z_Hep z_Hmp z_Hhc])
    qed
   next
    assume z_Hsv:"(~?z_hsj)" (is "~(?z_hoh=>?z_hoj)")
    have z_Hoh: "?z_hoh"
    by (rule zenon_notimply_0 [OF z_Hsv])
    have z_Hoi: "(~?z_hoj)"
    by (rule zenon_notimply_1 [OF z_Hsv])
    have z_Hso: "(~((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {BOT}))" (is "~?z_hsp")
    by (rule zenon_notin_cup_1 [of "(((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "(Nat \\ {0})" "{BOT}", OF z_Hoi])
    have z_Hix: "((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=BOT)" (is "?z_hiy~=_")
    by (rule zenon_notin_addElt_0 [of "?z_hiy" "BOT" "{}", OF z_Hso])
    have z_Hjn: "(DOMAIN(pc)=ProcSet)" (is "?z_hjo=_")
    by (rule zenon_in_funcset_1 [of "pc" "ProcSet" "{''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ?z_hx, ''D4''}", OF z_Hm])
    show FALSE
    proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vf. zenon_Vf)" "((Q[(j[p])])=BOT)" "cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))))" "((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))))))", OF z_Hd])
     assume z_Hds:"((Q[(j[p])])=BOT)" (is "?z_hdt=_")
     assume z_Hdv:"cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))))" (is "?z_hdv")
     show FALSE
     proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vf. zenon_Vf)" "((j[p])=((l[p]) +  -.(1)))" "((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M)))" "((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M)))", OF z_Hdv])
      assume z_Hdw:"((j[p])=((l[p]) +  -.(1)))" (is "?z_hdu=?z_hdx")
      assume z_Hea:"((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M)))" (is "?z_heb&?z_hee")
      have z_Heb: "?z_heb" (is "_=?z_hed")
      by (rule zenon_and_0 [OF z_Hea])
      have z_Hee: "?z_hee" (is "?z_hef&?z_heh")
      by (rule zenon_and_1 [OF z_Hea])
      have z_Heh: "?z_heh"
      by (rule zenon_and_1 [OF z_Hee])
      have z_Hhq: "?z_hhp((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))))))))" (is "?z_hgj=>?z_hhi")
      by (rule zenon_all_0 [of "?z_hhp" "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))", OF z_Hhl])
      show FALSE
      proof (rule zenon_imply [OF z_Hhq])
       assume z_Hgi:"(~?z_hgj)"
       show FALSE
       by (rule zenon_L1_ [OF z_Heh z_Hgi z_Hhc])
      next
       assume z_Hhi:"?z_hhi"
       have z_Hmb: "bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT})))))))" (is "?z_hmb")
       by (rule zenon_in_subsetof_1 [of "(CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))" "[''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))]" "(\<lambda>a_ca. bAll(ProcSet, (\<lambda>p. ((((pc[p]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p])=BOT))&((((pc[p]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p]) \\in {ACK, BOT}))&(((pc[p]) \\in {''D4''})=>(((a_ca[''fres''])[p]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hhi])
       have z_Hhr_z_Hmb: "(\\A x:((x \\in ProcSet)=>((((pc[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((pc[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((pc[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))) == ?z_hmb" (is "?z_hhr == _")
       by (unfold bAll_def)
       have z_Hhr: "?z_hhr" (is "\\A x : ?z_hiz(x)")
       by (unfold z_Hhr_z_Hmb, fact z_Hmb)
       have z_Hja: "?z_hiz((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))" (is "_=>?z_hjb")
       by (rule zenon_all_0 [of "?z_hiz" "(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hhr])
       show FALSE
       proof (rule zenon_imply [OF z_Hja])
        assume z_Hjc:"(~?z_hii)"
        show FALSE
        by (rule notE [OF z_Hjc z_Hii])
       next
        assume z_Hjb:"?z_hjb" (is "?z_hjd&?z_hje")
        have z_Hjd: "?z_hjd" (is "?z_hjf=>?z_hjg")
        by (rule zenon_and_0 [OF z_Hjb])
        have z_Hje: "?z_hje" (is "?z_hok&?z_hol")
        by (rule zenon_and_1 [OF z_Hjb])
        have z_Hol: "?z_hol" (is "?z_hom=>_")
        by (rule zenon_and_1 [OF z_Hje])
        show FALSE
        proof (rule zenon_imply [OF z_Hjd])
         assume z_Hjh:"(~?z_hjf)"
         have z_Hji: "(~((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''E1'', ''D1'', ''D2'', ?z_hx}))" (is "~?z_hjj")
         by (rule zenon_notin_addElt_1 [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''L0''" "{''E1'', ''D1'', ''D2'', ?z_hx}", OF z_Hjh])
         have z_Hlg: "(~((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''D1'', ''D2'', ?z_hx}))" (is "~?z_hlh")
         by (rule zenon_notin_addElt_1 [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''E1''" "{''D1'', ''D2'', ?z_hx}", OF z_Hji])
         have z_Hll: "(~((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {''D2'', ?z_hx}))" (is "~?z_hlm")
         by (rule zenon_notin_addElt_1 [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''D1''" "{''D2'', ?z_hx}", OF z_Hlg])
         have z_Hlq: "(~((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {?z_hx}))" (is "~?z_hlr")
         by (rule zenon_notin_addElt_1 [of "(pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''D2''" "{?z_hx}", OF z_Hll])
         have z_Hls: "((pc[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=?z_hx)" (is "?z_hiw~=_")
         by (rule zenon_notin_addElt_0 [of "?z_hiw" "?z_hx" "{}", OF z_Hlq])
         show FALSE
         proof (rule zenon_imply [OF z_Hol])
          assume z_Hon:"(~?z_hom)"
          show FALSE
          proof (rule notE [OF z_Hon])
           have z_Hkx: "((a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((((CHOOSE x:(~((x \\in a_Mhash_primea)=>(x \\in subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>a_ca. bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((a_ca[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((a_ca[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((a_ca[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))))))[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=?z_hiw)" (is "?z_hjq=_")
           proof (rule zenon_nnpp [of "(?z_hjq=?z_hiw)"])
            assume z_Hlu:"(?z_hjq~=?z_hiw)"
            show FALSE
            by (rule zenon_L14_ [OF z_Hls z_He z_Hjn z_Hlu z_Hii z_Heb])
           qed
           have z_Hom: "?z_hom"
           by (rule subst [where P="(\<lambda>zenon_Vjkp. (zenon_Vjkp \\in {''D4''}))", OF z_Hkx], fact z_Hoh)
           thus "?z_hom" .
          qed
         next
          assume z_Hoj:"?z_hoj"
          show FALSE
          by (rule notE [OF z_Hoi z_Hoj])
         qed
        next
         assume z_Hjg:"?z_hjg"
         show FALSE
         by (rule notE [OF z_Hix z_Hjg])
        qed
       qed
      qed
     next
      assume z_Hpl:"((j[p])~=((l[p]) +  -.(1)))" (is "?z_hdu~=?z_hdx")
      assume z_Hej:"((a_jhash_primea=except(j, p, (?z_hdu + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M)))" (is "?z_hek&?z_hen")
      show FALSE
      by (rule zenon_L15_ [OF z_Hej z_Hhl z_Hhc z_Hii z_Hoh z_Hoi])
     qed
    next
     assume z_Hpm:"((Q[(j[p])])~=BOT)" (is "?z_hdt~=_")
     assume z_Hep:"((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf([''sigma'' : (UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. (bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ?z_hx})=>(((d[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((d[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((d[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT})))))))&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))))))" (is "?z_heq&?z_hes")
     show FALSE
     by (rule zenon_L12_ [OF z_Hep z_Hmp z_Hhc])
    qed
   qed
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 54"; *} qed
lemma ob'196:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'208: "((((i) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((j) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((l) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((x) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((v) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))))"
assumes v'209: "(((pc) = ([ p \<in> (ProcSet)  \<mapsto> (''L0'')])))"
assumes v'210: "(((X) = ((Succ[0]))))"
assumes v'211: "(((Q) = ([ a_indexa \<in> (((Nat) \\ ({((0))})))  \<mapsto> (BOT)])))"
assumes v'212: "(((M) = ({(((''sigma'' :> (<<>>)) @@ (''fres'' :> ([ p \<in> (ProcSet)  \<mapsto> (BOT)]))))})))"
assumes v'223: "((\<And> A :: c. A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0]))))))))))))) \<Longrightarrow> (((GoodEnqSet ((A)))) \<Longrightarrow> (\<And> seq :: c. seq \<in> ((Perm ((A)))) \<Longrightarrow> (((JInvSeq ((seq)))) \<Longrightarrow> (\<exists> a_ca \<in> (M) : (((ValuesMatchInds ((seq), (fapply ((a_ca), (''sigma'')))))) & ((GoodRes ((A), (fapply ((a_ca), (''fres'')))))))))))))"
shows "(\<forall> A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0]))))))))))))) : ((((GoodEnqSet ((A)))) \<Rightarrow> (\<forall> seq \<in> ((Perm ((A)))) : ((((JInvSeq ((seq)))) \<Rightarrow> (\<exists> a_ca \<in> (M) : (((ValuesMatchInds ((seq), (fapply ((a_ca), (''sigma'')))))) & ((GoodRes ((A), (fapply ((a_ca), (''fres''))))))))))))))"(is "PROP ?ob'196")
proof -
ML_command {* writeln "*** TLAPS ENTER 196"; *}
show "PROP ?ob'196"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_2c40b9.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_2c40b9.znn.out
;; obligation #196
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'208" (/\ (TLA.in i (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in j (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in l (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in x (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0)) (TLA.set BOT)))) (TLA.in v
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))))
$hyp "v'209" (= pc (TLA.Fcn ProcSet ((p) "L0")))
$hyp "v'210" (= X (TLA.fapply TLA.Succ 0))
$hyp "v'211" (= Q (TLA.Fcn (TLA.setminus arith.N
(TLA.set 0)) ((a_indexa) BOT)))
$hyp "v'212" (= M
(TLA.set (TLA.record "sigma" (TLA.tuple ) "fres" (TLA.Fcn ProcSet ((p) BOT)))))
$hyp "v'223" (TLA.bAll (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add X
(arith.minus (TLA.fapply TLA.Succ 0))))) ((A) (=> (GoodEnqSet A) (TLA.bAll (Perm A) ((seq) (=> (JInvSeq seq) (TLA.bEx M ((a_ca) (/\ (ValuesMatchInds seq
(TLA.fapply a_ca "sigma")) (GoodRes A
(TLA.fapply a_ca "fres")))))))))))
$goal (TLA.bAll (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add X (arith.minus (TLA.fapply TLA.Succ 0))))) ((A) (=> (GoodEnqSet A)
(TLA.bAll (Perm A) ((seq) (=> (JInvSeq seq)
(TLA.bEx M ((a_ca) (/\ (ValuesMatchInds seq (TLA.fapply a_ca "sigma"))
(GoodRes A
(TLA.fapply a_ca "fres")))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hg:"bAll(SUBSET(isa'dotdot(1, (X +  -.(1)))), (\<lambda>A. (GoodEnqSet(A)=>bAll(Perm(A), (\<lambda>seq. (JInvSeq(seq)=>bEx(M, (\<lambda>a_ca. (ValuesMatchInds(seq, (a_ca[''sigma'']))&GoodRes(A, (a_ca[''fres''])))))))))))" (is "?z_hg")
 using v'223 by blast
 assume z_Hh:"(~?z_hg)"
 show FALSE
 by (rule notE [OF z_Hh z_Hg])
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 196"; *} qed
lemma ob'162:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition PosInts suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition InvNL suppressed *)
assumes v'203: "(InvNL)"
(* usable definition A suppressed *)
fixes seq
assumes seq_in : "(seq \<in> ([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) \<rightarrow> (A)]))"
fixes m
assumes m_in : "(m \<in> ((isa_peri_peri_a (((Succ[0])), ((a_Lena ((seq))))))))"
fixes n
assumes n_in : "(n \<in> ((isa_peri_peri_a (((Succ[0])), ((a_Lena ((seq))))))))"
assumes v'221: "(((less ((n), (m)))) & ((greater ((fapply ((seq), (n))), (fapply ((seq), (m)))))) & (((fapply ((Q), (fapply ((seq), (m))))) \<noteq> (BOT))))"
assumes v'229: "(((((m) \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))) \<and> (((n) \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A)))))))))))"
assumes v'230: "(((A) \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0])))))))))))))))"
shows "((((fapply ((seq), (n))) \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0]))))))))))))) & (((fapply ((seq), (m))) \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0]))))))))))))))"(is "PROP ?ob'162")
proof -
ML_command {* writeln "*** TLAPS ENTER 162"; *}
show "PROP ?ob'162"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_75e459.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_75e459.znn.out
;; obligation #162
$hyp "v'203" InvNL
$hyp "seq_in" (TLA.in seq (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) A))
$hyp "m_in" (TLA.in m (arith.intrange (TLA.fapply TLA.Succ 0)
(a_Lena seq)))
$hyp "n_in" (TLA.in n (arith.intrange (TLA.fapply TLA.Succ 0)
(a_Lena seq)))
$hyp "v'221" (/\ (arith.lt n m) (arith.lt (TLA.fapply seq m)
(TLA.fapply seq n)) (-. (= (TLA.fapply Q (TLA.fapply seq m))
BOT)))
$hyp "v'229" (/\ (TLA.in m (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A))) (TLA.in n (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A))))
$hyp "v'230" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add X
(arith.minus (TLA.fapply TLA.Succ 0))))))
$goal (/\ (TLA.in (TLA.fapply seq n) (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add X (arith.minus (TLA.fapply TLA.Succ 0)))))
(TLA.in (TLA.fapply seq m) (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add X
(arith.minus (TLA.fapply TLA.Succ 0))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hf:"((m \\in isa'dotdot(1, Cardinality(A)))&(n \\in isa'dotdot(1, Cardinality(A))))" (is "?z_hi&?z_ho")
 using v'229 by blast
 have z_Hb:"(seq \\in FuncSet(isa'dotdot(1, Cardinality(A)), A))" (is "?z_hb")
 using seq_in by blast
 have z_Hg:"(A \\in SUBSET(isa'dotdot(1, (X +  -.(1)))))" (is "?z_hg")
 using v'230 by blast
 assume z_Hh:"(~(((seq[n]) \\in isa'dotdot(1, (X +  -.(1))))&((seq[m]) \\in isa'dotdot(1, (X +  -.(1))))))" (is "~(?z_hy&?z_hba)")
 have z_Hi: "?z_hi"
 by (rule zenon_and_0 [OF z_Hf])
 have z_Ho: "?z_ho"
 by (rule zenon_and_1 [OF z_Hf])
 have z_Hbc: "(A \\subseteq isa'dotdot(1, (X +  -.(1))))" (is "?z_hbc")
 by (rule zenon_in_SUBSET_0 [of "A" "isa'dotdot(1, (X +  -.(1)))", OF z_Hg])
 have z_Hbd_z_Hbc: "bAll(A, (\<lambda>x. (x \\in isa'dotdot(1, (X +  -.(1)))))) == ?z_hbc" (is "?z_hbd == _")
 by (unfold subset_def)
 have z_Hbd: "?z_hbd"
 by (unfold z_Hbd_z_Hbc, fact z_Hbc)
 have z_Hbh_z_Hbd: "(\\A x:((x \\in A)=>(x \\in isa'dotdot(1, (X +  -.(1)))))) == ?z_hbd" (is "?z_hbh == _")
 by (unfold bAll_def)
 have z_Hbh: "?z_hbh" (is "\\A x : ?z_hbk(x)")
 by (unfold z_Hbh_z_Hbd, fact z_Hbd)
 show FALSE
 proof (rule zenon_notand [OF z_Hh])
  assume z_Hbl:"(~?z_hy)"
  have z_Hbm: "?z_hbk((seq[n]))" (is "?z_hbn=>_")
  by (rule zenon_all_0 [of "?z_hbk" "(seq[n])", OF z_Hbh])
  show FALSE
  proof (rule zenon_imply [OF z_Hbm])
   assume z_Hbo:"(~?z_hbn)"
   have z_Hbp: "(\\A zenon_Vq:((zenon_Vq \\in isa'dotdot(1, Cardinality(A)))=>((seq[zenon_Vq]) \\in A)))" (is "\\A x : ?z_hbv(x)")
   by (rule zenon_in_funcset_2 [of "seq" "isa'dotdot(1, Cardinality(A))" "A", OF z_Hb])
   have z_Hbw: "?z_hbv(n)"
   by (rule zenon_all_0 [of "?z_hbv" "n", OF z_Hbp])
   show FALSE
   proof (rule zenon_imply [OF z_Hbw])
    assume z_Hbx:"(~?z_ho)"
    show FALSE
    by (rule notE [OF z_Hbx z_Ho])
   next
    assume z_Hbn:"?z_hbn"
    show FALSE
    by (rule notE [OF z_Hbo z_Hbn])
   qed
  next
   assume z_Hy:"?z_hy"
   show FALSE
   by (rule notE [OF z_Hbl z_Hy])
  qed
 next
  assume z_Hby:"(~?z_hba)"
  have z_Hbz: "?z_hbk((seq[m]))" (is "?z_hca=>_")
  by (rule zenon_all_0 [of "?z_hbk" "(seq[m])", OF z_Hbh])
  show FALSE
  proof (rule zenon_imply [OF z_Hbz])
   assume z_Hcb:"(~?z_hca)"
   have z_Hbp: "(\\A zenon_Vq:((zenon_Vq \\in isa'dotdot(1, Cardinality(A)))=>((seq[zenon_Vq]) \\in A)))" (is "\\A x : ?z_hbv(x)")
   by (rule zenon_in_funcset_2 [of "seq" "isa'dotdot(1, Cardinality(A))" "A", OF z_Hb])
   have z_Hcc: "?z_hbv(m)"
   by (rule zenon_all_0 [of "?z_hbv" "m", OF z_Hbp])
   show FALSE
   proof (rule zenon_imply [OF z_Hcc])
    assume z_Hcd:"(~?z_hi)"
    show FALSE
    by (rule notE [OF z_Hcd z_Hi])
   next
    assume z_Hca:"?z_hca"
    show FALSE
    by (rule notE [OF z_Hcb z_Hca])
   qed
  next
   assume z_Hba:"?z_hba"
   show FALSE
   by (rule notE [OF z_Hby z_Hba])
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 162"; *} qed
lemma ob'199:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'208: "((((i) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((j) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((l) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((x) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((v) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))))"
assumes v'209: "(((pc) = ([ p \<in> (ProcSet)  \<mapsto> (''L0'')])))"
assumes v'210: "(((X) = ((Succ[0]))))"
assumes v'211: "(((Q) = ([ a_indexa \<in> (((Nat) \\ ({((0))})))  \<mapsto> (BOT)])))"
assumes v'212: "(((M) = ({(((''sigma'' :> (<<>>)) @@ (''fres'' :> ([ p \<in> (ProcSet)  \<mapsto> (BOT)]))))})))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0]))))))))))))))"
assumes v'224: "((GoodEnqSet ((A))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'226: "((JInvSeq ((seq))))"
assumes v'232: "(((A) = ({})))"
shows "(((fapply ((Choice(%CS. (((CS) = ([ T \<in> ((SUBSET (A)))  \<mapsto> (cond((((T) = ({}))), ((0)), ((arith_add (((Succ[0])), (fapply ((CS), (((T) \\ ({(Choice(%x_1. (((x_1) \<in> (T)))))}))))))))))]))))), (A))) = ((0))))"(is "PROP ?ob'199")
proof -
ML_command {* writeln "*** TLAPS ENTER 199"; *}
show "PROP ?ob'199"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_5f2150.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_5f2150.znn.out
;; obligation #199
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'208" (/\ (TLA.in i (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in j (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in l (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in x (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0)) (TLA.set BOT)))) (TLA.in v
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))))
$hyp "v'209" (= pc (TLA.Fcn ProcSet ((p) "L0")))
$hyp "v'210" (= X (TLA.fapply TLA.Succ 0))
$hyp "v'211" (= Q (TLA.Fcn (TLA.setminus arith.N
(TLA.set 0)) ((a_indexa) BOT)))
$hyp "v'212" (= M
(TLA.set (TLA.record "sigma" (TLA.tuple ) "fres" (TLA.Fcn ProcSet ((p) BOT)))))
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add X
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "v'224" (GoodEnqSet A)
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'226" (JInvSeq seq)
$hyp "v'232" (= A TLA.emptyset)
$goal (= (TLA.fapply (t. ((CS) (= CS
(TLA.Fcn (TLA.SUBSET A) ((T) (TLA.cond (= T
TLA.emptyset) 0 (arith.add (TLA.fapply TLA.Succ 0)
(TLA.fapply CS (TLA.setminus T (TLA.set (t. ((x_1) (TLA.in x_1
T))))))))))))) A)
0)
END ZENON  INPUT *)
(* PROOF-FOUND *)
ML_command {* writeln "*** TLAPS EXIT 199"; *} qed
lemma ob'438:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'227: "(((fapply ((pc), (p))) = (''E2'')))"
assumes v'228: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E3'')])))"
assumes v'229: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((i), (p)))] = (fapply ((v), (p)))])))"
assumes v'230: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'231: "((((a_ihash_primea :: c)) = (i)))"
assumes v'232: "((((a_jhash_primea :: c)) = (j)))"
assumes v'233: "((((a_lhash_primea :: c)) = (l)))"
assumes v'234: "((((a_xhash_primea :: c)) = (x)))"
assumes v'235: "((((a_vhash_primea :: c)) = (v)))"
assumes v'236: "((((a_Mhash_primea :: c)) = (M)))"
assumes v'237: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'240: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'241: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
assumes v'257: "((\<And> k :: c. k \<in> ((DOMAIN (seq))) \<Longrightarrow> (((fapply (([ k_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k_1)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k_1)))))))))))))]), (k))) = (fapply (([ k_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k_1))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k_1)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k_1)))))))))))))]), (k)))))))"
shows "((([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k)))))))))))))]) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k)))))))))))))])))"(is "PROP ?ob'438")
proof -
ML_command {* writeln "*** TLAPS ENTER 438"; *}
show "PROP ?ob'438"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_194487.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_194487.znn.out
;; obligation #438
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'227" (= (TLA.fapply pc p) "E2")
$hyp "v'228" (= a_pchash_primea
(TLA.except pc p "E3"))
$hyp "v'229" (= a_Qhash_primea
(TLA.except Q (TLA.fapply i p) (TLA.fapply v p)))
$hyp "v'230" (= a_Xhash_primea X)
$hyp "v'231" (= a_ihash_primea i)
$hyp "v'232" (= a_jhash_primea j)
$hyp "v'233" (= a_lhash_primea l)
$hyp "v'234" (= a_xhash_primea x)
$hyp "v'235" (= a_vhash_primea v)
$hyp "v'236" (= a_Mhash_primea M)
$hyp "v'237" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'240" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'241" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'257" (TLA.bAll (TLA.DOMAIN seq) ((k) (= (TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((k_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k_1))
BOT)) (TLA.fapply Q (TLA.fapply seq k_1)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k_1))))))))) k)
(TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((k_1) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k_1))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k_1)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k_1))))))))) k))))
$goal (= (TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k)))))))))
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hs:"bAll(DOMAIN(seq), (\<lambda>k. ((Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))]))))[k])=(Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))]))))[k]))))" (is "?z_hs")
 using v'257 by blast
 assume z_Ht:"(Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))]))))~=Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))))" (is "?z_hz~=?z_hby")
 have z_Hcp: "(~(((isAFcn(?z_hz)&isAFcn(?z_hby))&(DOMAIN(?z_hz)=DOMAIN(?z_hby)))&(\\A zenon_Vi:((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi]))))))" (is "~(?z_hcr&?z_hcy)")
 by (rule zenon_notfunequal_0 [of "?z_hz" "?z_hby", OF z_Ht])
 show FALSE
 proof (rule zenon_notand [OF z_Hcp])
  assume z_Hdf:"(~?z_hcr)" (is "~(?z_hcs&?z_hcv)")
  show FALSE
  proof (rule zenon_notand [OF z_Hdf])
   assume z_Hdg:"(~?z_hcs)" (is "~(?z_hct&?z_hcu)")
   show FALSE
   proof (rule zenon_notand [OF z_Hdg])
    assume z_Hdh:"(~?z_hct)"
    show FALSE
    by (rule zenon_notisafcn_fcn [of "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))])))", OF z_Hdh])
   next
    assume z_Hdi:"(~?z_hcu)"
    show FALSE
    by (rule zenon_notisafcn_fcn [of "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdi])
   qed
  next
   assume z_Hdj:"(DOMAIN(?z_hz)~=DOMAIN(?z_hby))" (is "?z_hcw~=?z_hcx")
   have z_Hdk: "(DOMAIN(seq)~=?z_hcx)" (is "?z_hu~=_")
   by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Von. (zenon_Von~=?z_hcx))" "?z_hu" "(\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))])))", OF z_Hdj])
   have z_Hdo: "(?z_hu~=?z_hu)"
   by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vim. (?z_hu~=zenon_Vim))" "?z_hu" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdk])
   show FALSE
   by (rule zenon_noteq [OF z_Hdo])
  qed
 next
  assume z_Hds:"(~?z_hcy)" (is "~(\\A x : ?z_hdt(x))")
  have z_Hdu: "(\\E zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi])))))" (is "\\E x : ?z_hdw(x)")
  by (rule zenon_notallex_0 [of "?z_hdt", OF z_Hds])
  have z_Hdx: "?z_hdw((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi]))))))" (is "~(?z_hdz=>?z_hea)")
  by (rule zenon_ex_choose_0 [of "?z_hdw", OF z_Hdu])
  have z_Hdz: "?z_hdz"
  by (rule zenon_notimply_0 [OF z_Hdx])
  have z_Heb: "((?z_hz[(CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi])))))])~=(?z_hby[(CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi])))))]))" (is "?z_hec~=?z_hed")
  by (rule zenon_notimply_1 [OF z_Hdx])
  have z_Hee: "((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi]))))) \\in DOMAIN(seq))" (is "?z_hee")
  by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vcg. ((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi]))))) \\in zenon_Vcg))" "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdz])
  have z_Hea: "?z_hea"
  by (rule zenon_all_in_0 [of "DOMAIN(seq)" "(\<lambda>k. ((?z_hz[k])=(?z_hby[k])))", OF z_Hs z_Hee])
  show FALSE
  by (rule notE [OF z_Heb z_Hea])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 438"; *} qed
lemma ob'431:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'226: "(((fapply ((pc), (p))) = (''E2'')))"
assumes v'227: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E3'')])))"
assumes v'228: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((i), (p)))] = (fapply ((v), (p)))])))"
assumes v'229: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'230: "((((a_ihash_primea :: c)) = (i)))"
assumes v'231: "((((a_jhash_primea :: c)) = (j)))"
assumes v'232: "((((a_lhash_primea :: c)) = (l)))"
assumes v'233: "((((a_xhash_primea :: c)) = (x)))"
assumes v'234: "((((a_vhash_primea :: c)) = (v)))"
assumes v'235: "((((a_Mhash_primea :: c)) = (M)))"
assumes v'236: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'239: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'240: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
assumes v'256: "((GoodRes ((A), (fapply ((a_ca), (''fres''))))))"
assumes v'257: "(((fapply ((a_ca), (''sigma''))) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply ((pc), (q))) = (''E2''))) \<and> (((fapply ((i), (q))) = (fapply ((seq), (k)))))))))))))])))"
assumes v'258: "((([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k)))))))))))))]) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k)))))))))))))])))"
shows "(((fapply ((a_ca), (''sigma''))) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (k)))))))))))))])))"(is "PROP ?ob'431")
proof -
ML_command {* writeln "*** TLAPS ENTER 431"; *}
show "PROP ?ob'431"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_d38325.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_d38325.znn.out
;; obligation #431
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'226" (= (TLA.fapply pc p) "E2")
$hyp "v'227" (= a_pchash_primea
(TLA.except pc p "E3"))
$hyp "v'228" (= a_Qhash_primea
(TLA.except Q (TLA.fapply i p) (TLA.fapply v p)))
$hyp "v'229" (= a_Xhash_primea X)
$hyp "v'230" (= a_ihash_primea i)
$hyp "v'231" (= a_jhash_primea j)
$hyp "v'232" (= a_lhash_primea l)
$hyp "v'233" (= a_xhash_primea x)
$hyp "v'234" (= a_vhash_primea v)
$hyp "v'235" (= a_Mhash_primea M)
$hyp "v'236" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'239" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'240" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'256" (GoodRes A
(TLA.fapply a_ca "fres"))
$hyp "v'257" (= (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply pc q)
"E2") (= (TLA.fapply i q)
(TLA.fapply seq k))))))))))
$hyp "v'258" (= (TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k)))))))))
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k))))))))))
$goal (= (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq k))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hu:"(Fcn(DOMAIN(seq), (\<lambda>k. (CASE ((Q[(seq[k])])~=BOT) -> (Q[(seq[k])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((pc[q])=''E2'')&((i[q])=(seq[k])))))]))))=Fcn(DOMAIN(seq), (\<lambda>k. (CASE ((a_Qhash_primea[(seq[k])])~=BOT) -> (a_Qhash_primea[(seq[k])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k])))))])))))" (is "?z_hw=?z_hbv")
 using v'258 by blast
 have z_Ht:"((a_ca[''sigma''])=?z_hw)" (is "?z_hcn=_")
 using v'257 by blast
 assume z_Hv:"(?z_hcn~=?z_hbv)"
 show FALSE
 proof (rule notE [OF z_Hv])
  have z_Hcq: "(?z_hw=?z_hcn)"
  by (rule sym [OF z_Ht])
  have z_Hcr: "(?z_hcn=?z_hbv)"
  by (rule subst [where P="(\<lambda>zenon_Vi. (zenon_Vi=?z_hbv))", OF z_Hcq], fact z_Hu)
  thus "(?z_hcn=?z_hbv)" .
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 431"; *} qed
lemma ob'410:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'226: "(\<exists> a_newunde_linea \<in> ({(''E1''), (''D1'')}) : (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (a_newunde_linea)]))) & (cond((((a_newunde_linea) = (''E1''))), (\<exists> a_newunde_va \<in> (((Nat) \\ ({((0))}))) : ((((a_vhash_primea :: c)) = ([(v) EXCEPT ![(p)] = (a_newunde_va)])))), ((((a_vhash_primea :: c)) = (v)))))))"
assumes v'227: "(((fapply ((pc), (p))) = (''L0'')))"
assumes v'228: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'229: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'230: "((((a_ihash_primea :: c)) = (i)))"
assumes v'231: "((((a_jhash_primea :: c)) = (j)))"
assumes v'232: "((((a_lhash_primea :: c)) = (l)))"
assumes v'233: "((((a_xhash_primea :: c)) = (x)))"
assumes v'234: "((((a_Mhash_primea :: c)) = (M)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'237: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'238: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
assumes v'251: "((\<And> k :: c. k \<in> ((DOMAIN (seq))) \<Longrightarrow> (((fapply (([ k_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k_1)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k_1)))))))))))))]), (k))) = (fapply (([ k_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k_1))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k_1)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k_1)))))))))))))]), (k)))))))"
shows "((([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k)))))))))))))]) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k)))))))))))))])))"(is "PROP ?ob'410")
proof -
ML_command {* writeln "*** TLAPS ENTER 410"; *}
show "PROP ?ob'410"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_2ae8ed.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_2ae8ed.znn.out
;; obligation #410
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'226" (TLA.bEx (TLA.set "E1" "D1") ((a_newunde_linea) (/\ (= a_pchash_primea
(TLA.except pc p a_newunde_linea)) (TLA.cond (= a_newunde_linea
"E1") (TLA.bEx (TLA.setminus arith.N
(TLA.set 0)) ((a_newunde_va) (= a_vhash_primea
(TLA.except v p a_newunde_va)))) (= a_vhash_primea
v)))))
$hyp "v'227" (= (TLA.fapply pc p) "L0")
$hyp "v'228" (= a_Xhash_primea X)
$hyp "v'229" (= a_Qhash_primea Q)
$hyp "v'230" (= a_ihash_primea i)
$hyp "v'231" (= a_jhash_primea j)
$hyp "v'232" (= a_lhash_primea l)
$hyp "v'233" (= a_xhash_primea x)
$hyp "v'234" (= a_Mhash_primea
M)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'237" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'238" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'251" (TLA.bAll (TLA.DOMAIN seq) ((k) (= (TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((k_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k_1))
BOT)) (TLA.fapply Q (TLA.fapply seq k_1)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k_1))))))))) k)
(TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((k_1) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k_1))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k_1)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k_1))))))))) k))))
$goal (= (TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k)))))))))
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hr:"bAll(DOMAIN(seq), (\<lambda>k. ((Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))]))))[k])=(Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))]))))[k]))))" (is "?z_hr")
 using v'251 by blast
 assume z_Hs:"(Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))]))))~=Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))))" (is "?z_hy~=?z_hbx")
 have z_Hco: "(~(((isAFcn(?z_hy)&isAFcn(?z_hbx))&(DOMAIN(?z_hy)=DOMAIN(?z_hbx)))&(\\A zenon_Vi:((zenon_Vi \\in DOMAIN(?z_hbx))=>((?z_hy[zenon_Vi])=(?z_hbx[zenon_Vi]))))))" (is "~(?z_hcq&?z_hcx)")
 by (rule zenon_notfunequal_0 [of "?z_hy" "?z_hbx", OF z_Hs])
 show FALSE
 proof (rule zenon_notand [OF z_Hco])
  assume z_Hde:"(~?z_hcq)" (is "~(?z_hcr&?z_hcu)")
  show FALSE
  proof (rule zenon_notand [OF z_Hde])
   assume z_Hdf:"(~?z_hcr)" (is "~(?z_hcs&?z_hct)")
   show FALSE
   proof (rule zenon_notand [OF z_Hdf])
    assume z_Hdg:"(~?z_hcs)"
    show FALSE
    by (rule zenon_notisafcn_fcn [of "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))])))", OF z_Hdg])
   next
    assume z_Hdh:"(~?z_hct)"
    show FALSE
    by (rule zenon_notisafcn_fcn [of "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdh])
   qed
  next
   assume z_Hdi:"(DOMAIN(?z_hy)~=DOMAIN(?z_hbx))" (is "?z_hcv~=?z_hcw")
   have z_Hdj: "(DOMAIN(seq)~=?z_hcw)" (is "?z_ht~=_")
   by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vws. (zenon_Vws~=?z_hcw))" "?z_ht" "(\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))])))", OF z_Hdi])
   have z_Hdn: "(?z_ht~=?z_ht)"
   by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vys. (?z_ht~=zenon_Vys))" "?z_ht" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdj])
   show FALSE
   by (rule zenon_noteq [OF z_Hdn])
  qed
 next
  assume z_Hdr:"(~?z_hcx)" (is "~(\\A x : ?z_hds(x))")
  have z_Hdt: "(\\E zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbx))=>((?z_hy[zenon_Vi])=(?z_hbx[zenon_Vi])))))" (is "\\E x : ?z_hdv(x)")
  by (rule zenon_notallex_0 [of "?z_hds", OF z_Hdr])
  have z_Hdw: "?z_hdv((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbx))=>((?z_hy[zenon_Vi])=(?z_hbx[zenon_Vi]))))))" (is "~(?z_hdy=>?z_hdz)")
  by (rule zenon_ex_choose_0 [of "?z_hdv", OF z_Hdt])
  have z_Hdy: "?z_hdy"
  by (rule zenon_notimply_0 [OF z_Hdw])
  have z_Hea: "((?z_hy[(CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbx))=>((?z_hy[zenon_Vi])=(?z_hbx[zenon_Vi])))))])~=(?z_hbx[(CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbx))=>((?z_hy[zenon_Vi])=(?z_hbx[zenon_Vi])))))]))" (is "?z_heb~=?z_hec")
  by (rule zenon_notimply_1 [OF z_Hdw])
  have z_Hed: "((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbx))=>((?z_hy[zenon_Vi])=(?z_hbx[zenon_Vi]))))) \\in DOMAIN(seq))" (is "?z_hed")
  by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vrf. ((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbx))=>((?z_hy[zenon_Vi])=(?z_hbx[zenon_Vi]))))) \\in zenon_Vrf))" "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdy])
  have z_Hdz: "?z_hdz"
  by (rule zenon_all_in_0 [of "DOMAIN(seq)" "(\<lambda>k. ((?z_hy[k])=(?z_hbx[k])))", OF z_Hr z_Hed])
  show FALSE
  by (rule notE [OF z_Hea z_Hdz])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 410"; *} qed
lemma ob'404:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'225: "(\<exists> a_newunde_linea \<in> ({(''E1''), (''D1'')}) : (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (a_newunde_linea)]))) & (cond((((a_newunde_linea) = (''E1''))), (\<exists> a_newunde_va \<in> (((Nat) \\ ({((0))}))) : ((((a_vhash_primea :: c)) = ([(v) EXCEPT ![(p)] = (a_newunde_va)])))), ((((a_vhash_primea :: c)) = (v)))))))"
assumes v'226: "(((fapply ((pc), (p))) = (''L0'')))"
assumes v'227: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'228: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'229: "((((a_ihash_primea :: c)) = (i)))"
assumes v'230: "((((a_jhash_primea :: c)) = (j)))"
assumes v'231: "((((a_lhash_primea :: c)) = (l)))"
assumes v'232: "((((a_xhash_primea :: c)) = (x)))"
assumes v'233: "((((a_Mhash_primea :: c)) = (M)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
assumes v'250: "((([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k)))))))))))))]) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k)))))))))))))])))"
shows "(((((fapply ((a_ca), (''sigma''))) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply ((pc), (q))) = (''E2''))) \<and> (((fapply ((i), (q))) = (fapply ((seq), (k)))))))))))))]))) = (((fapply ((a_ca), (''sigma''))) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (k)))))))))))))])))))"(is "PROP ?ob'404")
proof -
ML_command {* writeln "*** TLAPS ENTER 404"; *}
show "PROP ?ob'404"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_a7b682.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_a7b682.znn.out
;; obligation #404
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'225" (TLA.bEx (TLA.set "E1" "D1") ((a_newunde_linea) (/\ (= a_pchash_primea
(TLA.except pc p a_newunde_linea)) (TLA.cond (= a_newunde_linea
"E1") (TLA.bEx (TLA.setminus arith.N
(TLA.set 0)) ((a_newunde_va) (= a_vhash_primea
(TLA.except v p a_newunde_va)))) (= a_vhash_primea
v)))))
$hyp "v'226" (= (TLA.fapply pc p) "L0")
$hyp "v'227" (= a_Xhash_primea X)
$hyp "v'228" (= a_Qhash_primea Q)
$hyp "v'229" (= a_ihash_primea i)
$hyp "v'230" (= a_jhash_primea j)
$hyp "v'231" (= a_lhash_primea l)
$hyp "v'232" (= a_xhash_primea x)
$hyp "v'233" (= a_Mhash_primea
M)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'250" (= (TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k)))))))))
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k))))))))))
$goal (= (= (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply pc q)
"E2") (= (TLA.fapply i q) (TLA.fapply seq k))))))))))
(= (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq k)))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hr:"(Fcn(DOMAIN(seq), (\<lambda>k. (CASE ((Q[(seq[k])])~=BOT) -> (Q[(seq[k])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k])))))]))))=Fcn(DOMAIN(seq), (\<lambda>k. (CASE ((a_Qhash_primea[(seq[k])])~=BOT) -> (a_Qhash_primea[(seq[k])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k])))))])))))" (is "?z_ht=?z_hbs")
 using v'250 by blast
 assume z_Hs:"(((a_ca[''sigma''])=?z_ht)~=((a_ca[''sigma''])=?z_hbs))" (is "?z_hcj~=?z_hcn")
 show FALSE
 proof (rule zenon_noteq [of "?z_hcn"])
  have z_Hco: "(?z_hcn~=?z_hcn)"
  by (rule subst [where P="(\<lambda>zenon_Vob. (((a_ca[''sigma''])=zenon_Vob)~=?z_hcn))", OF z_Hr], fact z_Hs)
  thus "(?z_hcn~=?z_hcn)" .
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 404"; *} qed
lemma ob'497:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'228: "(((fapply ((pc), (p))) = (''D1'')))"
assumes v'229: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D2'')])))"
assumes v'230: "((((a_lhash_primea :: c)) = ([(l) EXCEPT ![(p)] = (X)])))"
assumes v'231: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'232: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'233: "((((a_ihash_primea :: c)) = (i)))"
assumes v'234: "((((a_jhash_primea :: c)) = (j)))"
assumes v'235: "((((a_xhash_primea :: c)) = (x)))"
assumes v'236: "((((a_vhash_primea :: c)) = (v)))"
assumes v'237: "((((a_Mhash_primea :: c)) = (M)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'240: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'241: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
assumes v'254: "((([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k)))))))))))))]) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k)))))))))))))])))"
shows "(((((fapply ((a_ca), (''sigma''))) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply ((pc), (q))) = (''E2''))) \<and> (((fapply ((i), (q))) = (fapply ((seq), (k)))))))))))))]))) = (((fapply ((a_ca), (''sigma''))) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (k)))))))))))))])))))"(is "PROP ?ob'497")
proof -
ML_command {* writeln "*** TLAPS ENTER 497"; *}
show "PROP ?ob'497"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_08879c.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_08879c.znn.out
;; obligation #497
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'228" (= (TLA.fapply pc p) "D1")
$hyp "v'229" (= a_pchash_primea
(TLA.except pc p "D2"))
$hyp "v'230" (= a_lhash_primea
(TLA.except l p X))
$hyp "v'231" (= a_Xhash_primea X)
$hyp "v'232" (= a_Qhash_primea Q)
$hyp "v'233" (= a_ihash_primea i)
$hyp "v'234" (= a_jhash_primea j)
$hyp "v'235" (= a_xhash_primea x)
$hyp "v'236" (= a_vhash_primea v)
$hyp "v'237" (= a_Mhash_primea
M)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'240" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'241" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'254" (= (TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k)))))))))
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k))))))))))
$goal (= (= (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply pc q)
"E2") (= (TLA.fapply i q) (TLA.fapply seq k))))))))))
(= (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq k)))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hs:"(Fcn(DOMAIN(seq), (\<lambda>k. (CASE ((Q[(seq[k])])~=BOT) -> (Q[(seq[k])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k])))))]))))=Fcn(DOMAIN(seq), (\<lambda>k. (CASE ((a_Qhash_primea[(seq[k])])~=BOT) -> (a_Qhash_primea[(seq[k])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k])))))])))))" (is "?z_hu=?z_hbt")
 using v'254 by blast
 assume z_Ht:"(((a_ca[''sigma''])=?z_hu)~=((a_ca[''sigma''])=?z_hbt))" (is "?z_hck~=?z_hco")
 show FALSE
 proof (rule zenon_noteq [of "?z_hco"])
  have z_Hcp: "(?z_hco~=?z_hco)"
  by (rule subst [where P="(\<lambda>zenon_Vcb. (((a_ca[''sigma''])=zenon_Vcb)~=?z_hco))", OF z_Hs], fact z_Ht)
  thus "(?z_hco~=?z_hco)" .
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 497"; *} qed
lemma ob'470:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'228: "(((fapply ((pc), (p))) = (''E3'')))"
assumes v'229: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''L0'')])))"
assumes v'230: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'231: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'232: "((((a_ihash_primea :: c)) = (i)))"
assumes v'233: "((((a_jhash_primea :: c)) = (j)))"
assumes v'234: "((((a_lhash_primea :: c)) = (l)))"
assumes v'235: "((((a_xhash_primea :: c)) = (x)))"
assumes v'236: "((((a_vhash_primea :: c)) = (v)))"
assumes v'237: "((((a_Mhash_primea :: c)) = ((Filter ((p), (ACK))))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'240: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'241: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
fixes d
assumes d_in : "(d \<in> (M))"
assumes v'258: "((\<And> k :: c. k \<in> ((DOMAIN (seq))) \<Longrightarrow> (((fapply (([ k_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k_1)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k_1)))))))))))))]), (k))) = (fapply (([ k_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k_1))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k_1)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k_1)))))))))))))]), (k)))))))"
shows "((([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k)))))))))))))]) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k)))))))))))))])))"(is "PROP ?ob'470")
proof -
ML_command {* writeln "*** TLAPS ENTER 470"; *}
show "PROP ?ob'470"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_e7b627.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_e7b627.znn.out
;; obligation #470
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'228" (= (TLA.fapply pc p) "E3")
$hyp "v'229" (= a_pchash_primea
(TLA.except pc p "L0"))
$hyp "v'230" (= a_Xhash_primea X)
$hyp "v'231" (= a_Qhash_primea Q)
$hyp "v'232" (= a_ihash_primea i)
$hyp "v'233" (= a_jhash_primea j)
$hyp "v'234" (= a_lhash_primea l)
$hyp "v'235" (= a_xhash_primea x)
$hyp "v'236" (= a_vhash_primea v)
$hyp "v'237" (= a_Mhash_primea (Filter p
ACK))
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'240" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'241" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "d_in" (TLA.in d M)
$hyp "v'258" (TLA.bAll (TLA.DOMAIN seq) ((k) (= (TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((k_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k_1))
BOT)) (TLA.fapply Q (TLA.fapply seq k_1)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k_1))))))))) k)
(TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((k_1) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k_1))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k_1)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k_1))))))))) k))))
$goal (= (TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k)))))))))
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hs:"bAll(DOMAIN(seq), (\<lambda>k. ((Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))]))))[k])=(Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))]))))[k]))))" (is "?z_hs")
 using v'258 by blast
 assume z_Ht:"(Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))]))))~=Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))))" (is "?z_hz~=?z_hby")
 have z_Hcp: "(~(((isAFcn(?z_hz)&isAFcn(?z_hby))&(DOMAIN(?z_hz)=DOMAIN(?z_hby)))&(\\A zenon_Vi:((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi]))))))" (is "~(?z_hcr&?z_hcy)")
 by (rule zenon_notfunequal_0 [of "?z_hz" "?z_hby", OF z_Ht])
 show FALSE
 proof (rule zenon_notand [OF z_Hcp])
  assume z_Hdf:"(~?z_hcr)" (is "~(?z_hcs&?z_hcv)")
  show FALSE
  proof (rule zenon_notand [OF z_Hdf])
   assume z_Hdg:"(~?z_hcs)" (is "~(?z_hct&?z_hcu)")
   show FALSE
   proof (rule zenon_notand [OF z_Hdg])
    assume z_Hdh:"(~?z_hct)"
    show FALSE
    by (rule zenon_notisafcn_fcn [of "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))])))", OF z_Hdh])
   next
    assume z_Hdi:"(~?z_hcu)"
    show FALSE
    by (rule zenon_notisafcn_fcn [of "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdi])
   qed
  next
   assume z_Hdj:"(DOMAIN(?z_hz)~=DOMAIN(?z_hby))" (is "?z_hcw~=?z_hcx")
   have z_Hdk: "(DOMAIN(seq)~=?z_hcx)" (is "?z_hu~=_")
   by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vrl. (zenon_Vrl~=?z_hcx))" "?z_hu" "(\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))])))", OF z_Hdj])
   have z_Hdo: "(?z_hu~=?z_hu)"
   by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vzk. (?z_hu~=zenon_Vzk))" "?z_hu" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdk])
   show FALSE
   by (rule zenon_noteq [OF z_Hdo])
  qed
 next
  assume z_Hds:"(~?z_hcy)" (is "~(\\A x : ?z_hdt(x))")
  have z_Hdu: "(\\E zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi])))))" (is "\\E x : ?z_hdw(x)")
  by (rule zenon_notallex_0 [of "?z_hdt", OF z_Hds])
  have z_Hdx: "?z_hdw((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi]))))))" (is "~(?z_hdz=>?z_hea)")
  by (rule zenon_ex_choose_0 [of "?z_hdw", OF z_Hdu])
  have z_Hdz: "?z_hdz"
  by (rule zenon_notimply_0 [OF z_Hdx])
  have z_Heb: "((?z_hz[(CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi])))))])~=(?z_hby[(CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi])))))]))" (is "?z_hec~=?z_hed")
  by (rule zenon_notimply_1 [OF z_Hdx])
  have z_Hee: "((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi]))))) \\in DOMAIN(seq))" (is "?z_hee")
  by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vxf. ((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi]))))) \\in zenon_Vxf))" "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdz])
  have z_Hea: "?z_hea"
  by (rule zenon_all_in_0 [of "DOMAIN(seq)" "(\<lambda>k. ((?z_hz[k])=(?z_hby[k])))", OF z_Hs z_Hee])
  show FALSE
  by (rule notE [OF z_Heb z_Hea])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 470"; *} qed
lemma ob'463:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'227: "(((fapply ((pc), (p))) = (''E3'')))"
assumes v'228: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''L0'')])))"
assumes v'229: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'230: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'231: "((((a_ihash_primea :: c)) = (i)))"
assumes v'232: "((((a_jhash_primea :: c)) = (j)))"
assumes v'233: "((((a_lhash_primea :: c)) = (l)))"
assumes v'234: "((((a_xhash_primea :: c)) = (x)))"
assumes v'235: "((((a_vhash_primea :: c)) = (v)))"
assumes v'236: "((((a_Mhash_primea :: c)) = ((Filter ((p), (ACK))))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'239: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'240: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
fixes d
assumes d_in : "(d \<in> (M))"
assumes v'257: "((GoodRes ((A), (fapply ((d), (''fres''))))))"
assumes v'258: "(((fapply ((d), (''sigma''))) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply ((pc), (q))) = (''E2''))) \<and> (((fapply ((i), (q))) = (fapply ((seq), (k)))))))))))))])))"
assumes v'259: "((([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k)))))))))))))]) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k)))))))))))))])))"
shows "(((fapply ((((''sigma'' :> (fapply ((d), (''sigma'')))) @@ (''fres'' :> ([(fapply ((d), (''fres''))) EXCEPT ![(p)] = (BOT)])))), (''sigma''))) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (k)))))))))))))])))"(is "PROP ?ob'463")
proof -
ML_command {* writeln "*** TLAPS ENTER 463"; *}
show "PROP ?ob'463"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_531fbb.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_531fbb.znn.out
;; obligation #463
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'227" (= (TLA.fapply pc p) "E3")
$hyp "v'228" (= a_pchash_primea
(TLA.except pc p "L0"))
$hyp "v'229" (= a_Xhash_primea X)
$hyp "v'230" (= a_Qhash_primea Q)
$hyp "v'231" (= a_ihash_primea i)
$hyp "v'232" (= a_jhash_primea j)
$hyp "v'233" (= a_lhash_primea l)
$hyp "v'234" (= a_xhash_primea x)
$hyp "v'235" (= a_vhash_primea v)
$hyp "v'236" (= a_Mhash_primea (Filter p
ACK))
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'239" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'240" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "d_in" (TLA.in d M)
$hyp "v'257" (GoodRes A
(TLA.fapply d "fres"))
$hyp "v'258" (= (TLA.fapply d "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply pc q)
"E2") (= (TLA.fapply i q)
(TLA.fapply seq k))))))))))
$hyp "v'259" (= (TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k)))))))))
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k))))))))))
$goal (= (TLA.fapply (TLA.record "sigma" (TLA.fapply d "sigma") "fres" (TLA.except (TLA.fapply d "fres") p BOT)) "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq k))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hu:"(Fcn(DOMAIN(seq), (\<lambda>k. (CASE ((Q[(seq[k])])~=BOT) -> (Q[(seq[k])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((pc[q])=''E2'')&((i[q])=(seq[k])))))]))))=Fcn(DOMAIN(seq), (\<lambda>k. (CASE ((a_Qhash_primea[(seq[k])])~=BOT) -> (a_Qhash_primea[(seq[k])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k])))))])))))" (is "?z_hw=?z_hbv")
 using v'259 by blast
 have z_Ht:"((d[''sigma''])=?z_hw)" (is "?z_hcn=_")
 using v'258 by blast
 assume z_Hv:"(((''sigma'' :> (?z_hcn) @@ ''fres'' :> (except((d[''fres'']), p, BOT)))[''sigma''])~=?z_hbv)" (is "?z_hcq~=_")
 show FALSE
 proof (rule notE [OF z_Hv])
  have z_Hcw: "(?z_hw=?z_hcq)"
  proof (rule zenon_nnpp [of "(?z_hw=?z_hcq)"])
   assume z_Hcx:"(?z_hw~=?z_hcq)"
   show FALSE
   proof (rule zenon_em [of "(?z_hcq=?z_hcq)"])
    assume z_Hcy:"(?z_hcq=?z_hcq)"
    show FALSE
    proof (rule notE [OF z_Hcx])
     have z_Hcz: "(?z_hcq=?z_hw)"
     proof (rule zenon_nnpp [of "(?z_hcq=?z_hw)"])
      assume z_Hda:"(?z_hcq~=?z_hw)"
      have z_Hdb: "((''sigma'' \\in DOMAIN((''sigma'' :> (?z_hcn) @@ ''fres'' :> (except((d[''fres'']), p, BOT)))))&(?z_hcq=?z_hcn))" (is "?z_hdc&?z_hde")
      by ((rule zenon_recfield_1)+, rule zenon_recfield_2b)
      have z_Hde: "?z_hde"
      by (rule conjD2 [OF z_Hdb])
      have z_Hdf: "(?z_hcn~=?z_hw)"
      by (rule subst [where P="(\<lambda>zenon_Vkb. (zenon_Vkb~=?z_hw))", OF z_Hde z_Hda])
      show FALSE
      by (rule notE [OF z_Hdf z_Ht])
     qed
     have z_Hcw: "(?z_hw=?z_hcq)"
     by (rule subst [where P="(\<lambda>zenon_Vob. (zenon_Vob=?z_hcq))", OF z_Hcz], fact z_Hcy)
     thus "(?z_hw=?z_hcq)" .
    qed
   next
    assume z_Hdm:"(?z_hcq~=?z_hcq)"
    show FALSE
    by (rule zenon_noteq [OF z_Hdm])
   qed
  qed
  have z_Hdn: "(?z_hcq=?z_hbv)"
  by (rule subst [where P="(\<lambda>zenon_Vh. (zenon_Vh=?z_hbv))", OF z_Hcw], fact z_Hu)
  thus "(?z_hcq=?z_hbv)" .
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 463"; *} qed
lemma ob'459:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'201: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'207: "(((((((pc) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & (((X) \<in> (((Nat) \\ ({((0))}))))) & (((Q) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((i) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((j) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((l) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((x) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((v) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((M) \<in> ((SUBSET (subsetOf(([''sigma'' : ((Seqs ((((Nat) \\ ({((0))})))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %a_ca. ((CFTypeOK ((a_ca))))))))))) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'225: "(((fapply ((pc), (p))) = (''E3'')))"
assumes v'226: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''L0'')])))"
assumes v'227: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'228: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'229: "((((a_ihash_primea :: c)) = (i)))"
assumes v'230: "((((a_jhash_primea :: c)) = (j)))"
assumes v'231: "((((a_lhash_primea :: c)) = (l)))"
assumes v'232: "((((a_xhash_primea :: c)) = (x)))"
assumes v'233: "((((a_vhash_primea :: c)) = (v)))"
assumes v'234: "((((a_Mhash_primea :: c)) = (subsetOf(([''sigma'' : ((Seqs ((((Nat) \\ ({((0))})))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %d. (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((a_ca), (''fres''))), (p))) = (ACK))) & (((fapply ((fapply ((d), (''fres''))), (p))) = (BOT))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = (fapply ((a_ca), (''sigma'')))))))))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'237: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'238: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
fixes d
assumes d_in : "(d \<in> (M))"
assumes v'253: "(((fapply ((fapply ((d), (''fres''))), (p))) = (ACK)))"
assumes v'254: "(((((''sigma'' :> (fapply ((d), (''sigma'')))) @@ (''fres'' :> ([(fapply ((d), (''fres''))) EXCEPT ![(p)] = (BOT)])))) \<in> ([''sigma'' : ((Seqs ((((Nat) \\ ({((0))})))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])])))"
shows "(((((''sigma'' :> (fapply ((d), (''sigma'')))) @@ (''fres'' :> ([(fapply ((d), (''fres''))) EXCEPT ![(p)] = (BOT)])))) \<in> ((a_Mhash_primea :: c))))"(is "PROP ?ob'459")
proof -
ML_command {* writeln "*** TLAPS ENTER 459"; *}
show "PROP ?ob'459"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_709803.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_709803.znn.out
;; obligation #459
$hyp "v'201" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'207" (/\ (/\ (/\ (TLA.in pc
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in X (TLA.setminus arith.N (TLA.set 0))) (TLA.in Q
(TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in i (TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in j
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in l
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in x
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in v (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in M
(TLA.SUBSET (TLA.subsetOf (TLA.recordset "sigma" (Seqs (TLA.setminus arith.N
(TLA.set 0))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0)) (TLA.set ACK BOT)))) ((a_ca) (CFTypeOK a_ca)))))) a_Invunde_E2a
a_Invunde_E3a a_Invunde_D2a a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina)
(\/ Next (= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'225" (= (TLA.fapply pc p) "E3")
$hyp "v'226" (= a_pchash_primea
(TLA.except pc p "L0"))
$hyp "v'227" (= a_Xhash_primea X)
$hyp "v'228" (= a_Qhash_primea Q)
$hyp "v'229" (= a_ihash_primea i)
$hyp "v'230" (= a_jhash_primea j)
$hyp "v'231" (= a_lhash_primea l)
$hyp "v'232" (= a_xhash_primea x)
$hyp "v'233" (= a_vhash_primea v)
$hyp "v'234" (= a_Mhash_primea
(TLA.subsetOf (TLA.recordset "sigma" (Seqs (TLA.setminus arith.N
(TLA.set 0))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))) ((d) (TLA.bEx M ((a_ca) (/\ (= (TLA.fapply (TLA.fapply a_ca "fres") p)
ACK) (= (TLA.fapply (TLA.fapply d "fres") p) BOT)
(TLA.bAll ProcSet ((q) (=> (-. (= q p))
(= (TLA.fapply (TLA.fapply d "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))) (= (TLA.fapply d "sigma")
(TLA.fapply a_ca "sigma"))))))))
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'237" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'238" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "d_in" (TLA.in d M)
$hyp "v'253" (= (TLA.fapply (TLA.fapply d "fres") p)
ACK)
$hyp "v'254" (TLA.in (TLA.record "sigma" (TLA.fapply d "sigma") "fres" (TLA.except (TLA.fapply d "fres") p BOT))
(TLA.recordset "sigma" (Seqs (TLA.setminus arith.N
(TLA.set 0))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))))
$goal (TLA.in (TLA.record "sigma" (TLA.fapply d "sigma") "fres" (TLA.except (TLA.fapply d "fres") p BOT))
a_Mhash_primea)
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hm:"(a_Mhash_primea=subsetOf([''sigma'' : (Seqs((Nat \\ {0}))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. bEx(M, (\<lambda>a_ca. ((((a_ca[''fres''])[p])=ACK)&((((d[''fres''])[p])=BOT)&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=(a_ca[''sigma'']))))))))))" (is "_=?z_hw")
 using v'234 by blast
 have z_Hs:"(((d[''fres''])[p])=ACK)" (is "?z_hbx=_")
 using v'253 by blast
 have z_Ht:"((''sigma'' :> ((d[''sigma''])) @@ ''fres'' :> (except((d[''fres'']), p, BOT))) \\in [''sigma'' : (Seqs((Nat \\ {0}))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))])" (is "?z_ht")
 using v'254 by blast
 have z_Hc:"(p \\in ProcSet)" (is "?z_hc")
 using p_in by blast
 have z_Hr:"(d \\in M)" (is "?z_hr")
 using d_in by blast
 assume z_Hu:"(~((''sigma'' :> ((d[''sigma''])) @@ ''fres'' :> (except((d[''fres'']), p, BOT))) \\in a_Mhash_primea))" (is "~?z_hco")
 let ?z_hcm = "(''sigma'' :> ((d[''sigma''])) @@ ''fres'' :> (except((d[''fres'']), p, BOT)))"
 let ?z_hcp = "<<''sigma'', ''fres''>>"
 let ?z_hcq = "<<Seqs((Nat \\ {0})), FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT}))>>"
 have z_Hcr: "(2 \\in DOMAIN(?z_hcp))" by auto
 have z_Hcu: "((?z_hcm[(?z_hcp[2])]) \\in (?z_hcq[2]))" (is "?z_hcu")
 by (rule zenon_in_recordset_field [OF z_Ht z_Hcr])
 have z_Hcy: "((?z_hcm[''fres'']) \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))" (is "?z_hcy")
 using z_Hcu by auto
 have z_Hda: "((''fres'' \\in DOMAIN(?z_hcm))&((?z_hcm[''fres''])=except((d[''fres'']), p, BOT)))" (is "?z_hdb&?z_hdd")
 by (rule zenon_recfield_2, ((rule zenon_recfield_3)+)?, rule zenon_recfield_3b, auto)
 have z_Hdd: "?z_hdd" (is "?z_hcz=?z_hcn")
 by (rule conjD2 [OF z_Hda])
 have z_Hde: "(?z_hcn \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))" (is "?z_hde")
 by (rule subst [where P="(\<lambda>zenon_Vrb. (zenon_Vrb \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT}))))", OF z_Hdd z_Hcy])
 have z_Hdi: "(?z_hcn \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {?z_hbx, BOT})))" (is "?z_hdi")
 by (rule ssubst [where P="(\<lambda>zenon_Veja. (?z_hcn \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {zenon_Veja, BOT}))))", OF z_Hs z_Hde])
 have z_Hds: "(DOMAIN(?z_hcn)=ProcSet)" (is "?z_hdt=_")
 by (rule zenon_in_funcset_1 [of "?z_hcn" "ProcSet" "((Nat \\ {0}) \\cup {?z_hbx, BOT})", OF z_Hdi])
 have z_Hdu: "(~(?z_hcm \\in ?z_hw))" (is "~?z_hdv")
 by (rule subst [where P="(\<lambda>zenon_Vgja. (~(?z_hcm \\in zenon_Vgja)))", OF z_Hm z_Hu])
 show FALSE
 proof (rule zenon_notin_subsetof [of "?z_hcm" "[''sigma'' : (Seqs((Nat \\ {0}))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))]" "(\<lambda>d. bEx(M, (\<lambda>a_ca. ((((a_ca[''fres''])[p])=ACK)&((((d[''fres''])[p])=BOT)&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=(a_ca[''sigma'']))))))))", OF z_Hdu])
  assume z_Hea:"(~?z_ht)"
  show FALSE
  by (rule notE [OF z_Hea z_Ht])
 next
  assume z_Heb:"(~bEx(M, (\<lambda>a_ca. ((((a_ca[''fres''])[p])=ACK)&(((?z_hcz[p])=BOT)&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>((?z_hcz[q])=((a_ca[''fres''])[q])))))&((?z_hcm[''sigma''])=(a_ca[''sigma'']))))))))" (is "~?z_hec")
  have z_Heq_z_Heb: "(~(\\E x:((x \\in M)&((((x[''fres''])[p])=ACK)&(((?z_hcz[p])=BOT)&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>((?z_hcz[q])=((x[''fres''])[q])))))&((?z_hcm[''sigma''])=(x[''sigma''])))))))) == (~?z_hec)" (is "?z_heq == ?z_heb")
  by (unfold bEx_def)
  have z_Heq: "?z_heq" (is "~(\\E x : ?z_hfi(x))")
  by (unfold z_Heq_z_Heb, fact z_Heb)
  have z_Hfj: "~?z_hfi(d)" (is "~(_&?z_hfk)")
  by (rule zenon_notex_0 [of "?z_hfi" "d", OF z_Heq])
  show FALSE
  proof (rule zenon_notand [OF z_Hfj])
   assume z_Hfl:"(~?z_hr)"
   show FALSE
   by (rule notE [OF z_Hfl z_Hr])
  next
   assume z_Hfm:"(~?z_hfk)" (is "~(?z_hs&?z_hfn)")
   show FALSE
   proof (rule zenon_notand [OF z_Hfm])
    assume z_Hfo:"(?z_hbx~=ACK)"
    show FALSE
    by (rule notE [OF z_Hfo z_Hs])
   next
    assume z_Hfp:"(~?z_hfn)" (is "~(?z_heg&?z_hfq)")
    show FALSE
    proof (rule zenon_notand [OF z_Hfp])
     assume z_Hfr:"((?z_hcz[p])~=BOT)" (is "?z_heh~=_")
     have z_Hda: "(?z_hdb&?z_hdd)"
     by (rule zenon_recfield_2, ((rule zenon_recfield_3)+)?, rule zenon_recfield_3b, auto)
     have z_Hdd: "?z_hdd"
     by (rule conjD2 [OF z_Hda])
     have z_Hfs: "((?z_hcn[p])~=BOT)" (is "?z_hft~=_")
     by (rule subst [where P="(\<lambda>zenon_Vz. ((zenon_Vz[p])~=BOT))", OF z_Hdd z_Hfr])
     show FALSE
     proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vy. (zenon_Vy~=BOT))" "(d[''fres''])" "p" "BOT" "p", OF z_Hfs])
      assume z_Hgb:"(p \\in DOMAIN((d[''fres''])))" (is "?z_hgb")
      assume z_Hgd:"(p=p)"
      assume z_Hge:"(BOT~=BOT)"
      show FALSE
      by (rule zenon_noteq [OF z_Hge])
     next
      assume z_Hgb:"(p \\in DOMAIN((d[''fres''])))" (is "?z_hgb")
      assume z_Hgf:"(p~=p)"
      assume z_Hgg:"(?z_hbx~=BOT)"
      show FALSE
      by (rule zenon_noteq [OF z_Hgf])
     next
      assume z_Hgh:"(~(p \\in DOMAIN((d[''fres'']))))" (is "~?z_hgb")
      have z_Hgi: "(\\A zenon_Vkc:((zenon_Vkc \\in ?z_hdt)<=>(zenon_Vkc \\in ProcSet)))" (is "\\A x : ?z_hgn(x)")
      by (rule zenon_setequal_0 [of "?z_hdt" "ProcSet", OF z_Hds])
      have z_Hgo: "?z_hgn(p)" (is "?z_hgp<=>_")
      by (rule zenon_all_0 [of "?z_hgn" "p", OF z_Hgi])
      show FALSE
      proof (rule zenon_equiv [OF z_Hgo])
       assume z_Hgq:"(~?z_hgp)"
       assume z_Hgr:"(~?z_hc)"
       show FALSE
       by (rule notE [OF z_Hgr z_Hc])
      next
       assume z_Hgp:"?z_hgp"
       assume z_Hc:"?z_hc"
       have z_Hgb: "?z_hgb"
       by (rule zenon_domain_except_0 [of "(\<lambda>zenon_Vuia. (p \\in zenon_Vuia))" "(d[''fres''])" "p" "BOT", OF z_Hgp])
       show FALSE
       by (rule notE [OF z_Hgh z_Hgb])
      qed
     qed
    next
     assume z_Hgv:"(~?z_hfq)" (is "~(?z_hgw&?z_hgx)")
     show FALSE
     proof (rule zenon_notand [OF z_Hgv])
      assume z_Hgy:"(~?z_hgw)"
      have z_Hgz_z_Hgy: "(~(\\A x:((x \\in ProcSet)=>((x~=p)=>((?z_hcz[x])=((d[''fres''])[x])))))) == (~?z_hgw)" (is "?z_hgz == ?z_hgy")
      by (unfold bAll_def)
      have z_Hgz: "?z_hgz" (is "~(\\A x : ?z_hhi(x))")
      by (unfold z_Hgz_z_Hgy, fact z_Hgy)
      have z_Hhj: "(\\E x:(~((x \\in ProcSet)=>((x~=p)=>((?z_hcz[x])=((d[''fres''])[x]))))))" (is "\\E x : ?z_hhl(x)")
      by (rule zenon_notallex_0 [of "?z_hhi", OF z_Hgz])
      have z_Hhm: "?z_hhl((CHOOSE x:(~((x \\in ProcSet)=>((x~=p)=>((?z_hcz[x])=((d[''fres''])[x])))))))" (is "~(?z_hho=>?z_hhp)")
      by (rule zenon_ex_choose_0 [of "?z_hhl", OF z_Hhj])
      have z_Hho: "?z_hho"
      by (rule zenon_notimply_0 [OF z_Hhm])
      have z_Hhq: "(~?z_hhp)" (is "~(?z_hhr=>?z_hhs)")
      by (rule zenon_notimply_1 [OF z_Hhm])
      have z_Hhr: "?z_hhr" (is "?z_hhn~=_")
      by (rule zenon_notimply_0 [OF z_Hhq])
      have z_Hht: "((?z_hcz[?z_hhn])~=((d[''fres''])[?z_hhn]))" (is "?z_hhu~=?z_hhv")
      by (rule zenon_notimply_1 [OF z_Hhq])
      have z_Hhw: "(?z_hhn \\in ?z_hdt)" (is "?z_hhw")
      by (rule ssubst [where P="(\<lambda>zenon_Vjh. (?z_hhn \\in zenon_Vjh))", OF z_Hds z_Hho])
      have z_Hia: "(?z_hhn \\in DOMAIN((d[''fres''])))" (is "?z_hia")
      by (rule zenon_domain_except_0 [of "(\<lambda>zenon_Vjh. (?z_hhn \\in zenon_Vjh))" "(d[''fres''])" "p" "BOT", OF z_Hhw])
      have z_Hda: "(?z_hdb&?z_hdd)"
      by (rule zenon_recfield_2, ((rule zenon_recfield_3)+)?, rule zenon_recfield_3b, auto)
      have z_Hdd: "?z_hdd"
      by (rule conjD2 [OF z_Hda])
      have z_Hib: "((?z_hcn[?z_hhn])~=?z_hhv)" (is "?z_hic~=_")
      by (rule subst [where P="(\<lambda>zenon_Vgh. ((zenon_Vgh[?z_hhn])~=?z_hhv))", OF z_Hdd z_Hht])
      show FALSE
      proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vgh. (zenon_Vgh~=?z_hhv))" "(d[''fres''])" "p" "BOT" "?z_hhn", OF z_Hib])
       assume z_Hia:"?z_hia"
       assume z_Hij:"(p=?z_hhn)"
       assume z_Hik:"(BOT~=?z_hhv)"
       show FALSE
       by (rule zenon_eqsym [OF z_Hij z_Hhr])
      next
       assume z_Hia:"?z_hia"
       assume z_Hil:"(p~=?z_hhn)"
       assume z_Him:"(?z_hhv~=?z_hhv)"
       show FALSE
       by (rule zenon_noteq [OF z_Him])
      next
       assume z_Hin:"(~?z_hia)"
       show FALSE
       by (rule notE [OF z_Hin z_Hia])
      qed
     next
      assume z_Hio:"((?z_hcm[''sigma''])~=(d[''sigma'']))" (is "?z_hep~=?z_hck")
      have z_Hip: "((''sigma'' \\in DOMAIN(?z_hcm))&?z_hgx)" (is "?z_hiq&_")
      by ((rule zenon_recfield_1)+, rule zenon_recfield_2b)
      have z_Hgx: "?z_hgx"
      by (rule conjD2 [OF z_Hip])
      have z_Hir: "(?z_hck~=?z_hck)"
      by (rule subst [where P="(\<lambda>zenon_Vug. (zenon_Vug~=?z_hck))", OF z_Hgx z_Hio])
      show FALSE
      by (rule zenon_noteq [OF z_Hir])
     qed
    qed
   qed
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 459"; *} qed
lemma ob'559:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'229: "(cond((((fapply ((l), (p))) = ((Succ[0])))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & ((((a_jhash_primea :: c)) = (j)))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D3'')]))) & ((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((Succ[0]))]))))))"
assumes v'230: "(((fapply ((pc), (p))) = (''D2'')))"
assumes v'231: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'232: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'233: "((((a_ihash_primea :: c)) = (i)))"
assumes v'234: "((((a_lhash_primea :: c)) = (l)))"
assumes v'235: "((((a_xhash_primea :: c)) = (x)))"
assumes v'236: "((((a_vhash_primea :: c)) = (v)))"
assumes v'237: "((((a_Mhash_primea :: c)) = (M)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'240: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'241: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
assumes v'257: "((GoodRes ((A), (fapply ((a_ca), (''fres''))))))"
assumes v'258: "(((fapply ((a_ca), (''sigma''))) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply ((pc), (q))) = (''E2''))) \<and> (((fapply ((i), (q))) = (fapply ((seq), (k)))))))))))))])))"
assumes v'259: "((([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k)))))))))))))]) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k)))))))))))))])))"
shows "(((fapply ((a_ca), (''sigma''))) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (k)))))))))))))])))"(is "PROP ?ob'559")
proof -
ML_command {* writeln "*** TLAPS ENTER 559"; *}
show "PROP ?ob'559"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_a26609.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_a26609.znn.out
;; obligation #559
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'229" (TLA.cond (= (TLA.fapply l p)
(TLA.fapply TLA.Succ 0)) (/\ (= a_pchash_primea (TLA.except pc p "D1"))
(= a_jhash_primea j)) (/\ (= a_pchash_primea (TLA.except pc p "D3"))
(= a_jhash_primea
(TLA.except j p (TLA.fapply TLA.Succ 0)))))
$hyp "v'230" (= (TLA.fapply pc p) "D2")
$hyp "v'231" (= a_Xhash_primea X)
$hyp "v'232" (= a_Qhash_primea Q)
$hyp "v'233" (= a_ihash_primea i)
$hyp "v'234" (= a_lhash_primea l)
$hyp "v'235" (= a_xhash_primea x)
$hyp "v'236" (= a_vhash_primea v)
$hyp "v'237" (= a_Mhash_primea
M)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'240" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'241" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'257" (GoodRes A
(TLA.fapply a_ca "fres"))
$hyp "v'258" (= (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply pc q)
"E2") (= (TLA.fapply i q)
(TLA.fapply seq k))))))))))
$hyp "v'259" (= (TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k)))))))))
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k))))))))))
$goal (= (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq k))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Ht:"(Fcn(DOMAIN(seq), (\<lambda>k. (CASE ((Q[(seq[k])])~=BOT) -> (Q[(seq[k])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((pc[q])=''E2'')&((i[q])=(seq[k])))))]))))=Fcn(DOMAIN(seq), (\<lambda>k. (CASE ((a_Qhash_primea[(seq[k])])~=BOT) -> (a_Qhash_primea[(seq[k])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k])))))])))))" (is "?z_hv=?z_hbu")
 using v'259 by blast
 have z_Hs:"((a_ca[''sigma''])=?z_hv)" (is "?z_hcm=_")
 using v'258 by blast
 assume z_Hu:"(?z_hcm~=?z_hbu)"
 show FALSE
 proof (rule notE [OF z_Hu])
  have z_Hcp: "(?z_hv=?z_hcm)"
  by (rule sym [OF z_Hs])
  have z_Hcq: "(?z_hcm=?z_hbu)"
  by (rule subst [where P="(\<lambda>zenon_Vi. (zenon_Vi=?z_hbu))", OF z_Hcp], fact z_Ht)
  thus "(?z_hcm=?z_hbu)" .
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 559"; *} qed
lemma ob'553:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'230: "(cond((((fapply ((l), (p))) = ((Succ[0])))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & ((((a_jhash_primea :: c)) = (j)))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D3'')]))) & ((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((Succ[0]))]))))))"
assumes v'231: "(((fapply ((pc), (p))) = (''D2'')))"
assumes v'232: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'233: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'234: "((((a_ihash_primea :: c)) = (i)))"
assumes v'235: "((((a_lhash_primea :: c)) = (l)))"
assumes v'236: "((((a_xhash_primea :: c)) = (x)))"
assumes v'237: "((((a_vhash_primea :: c)) = (v)))"
assumes v'238: "((((a_Mhash_primea :: c)) = (M)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'241: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'242: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
fixes m
assumes m_in : "(m \<in> ((isa_peri_peri_a (((Succ[0])), ((a_Lena ((seq))))))))"
fixes n
assumes n_in : "(n \<in> ((isa_peri_peri_a (((Succ[0])), ((a_Lena ((seq))))))))"
assumes v'252: "((less ((n), (m))))"
assumes v'253: "((greater ((fapply ((seq), (n))), (fapply ((seq), (m))))))"
assumes v'254: "(((fapply ((Q), (fapply ((seq), (m))))) \<noteq> (BOT)))"
fixes q
assumes q_in : "(q \<in> (ProcSet))"
assumes v'271: "(((fapply ((l), (p))) \<noteq> ((Succ[0]))))"
assumes v'278: "(((fapply ((seq), (m))) \<in> (A)))"
shows "(((fapply ((seq), (m))) \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0])))))))))))))"(is "PROP ?ob'553")
proof -
ML_command {* writeln "*** TLAPS ENTER 553"; *}
show "PROP ?ob'553"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_11ac48.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_11ac48.znn.out
;; obligation #553
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'230" (TLA.cond (= (TLA.fapply l p)
(TLA.fapply TLA.Succ 0)) (/\ (= a_pchash_primea (TLA.except pc p "D1"))
(= a_jhash_primea j)) (/\ (= a_pchash_primea (TLA.except pc p "D3"))
(= a_jhash_primea
(TLA.except j p (TLA.fapply TLA.Succ 0)))))
$hyp "v'231" (= (TLA.fapply pc p) "D2")
$hyp "v'232" (= a_Xhash_primea X)
$hyp "v'233" (= a_Qhash_primea Q)
$hyp "v'234" (= a_ihash_primea i)
$hyp "v'235" (= a_lhash_primea l)
$hyp "v'236" (= a_xhash_primea x)
$hyp "v'237" (= a_vhash_primea v)
$hyp "v'238" (= a_Mhash_primea
M)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'241" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'242" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "m_in" (TLA.in m (arith.intrange (TLA.fapply TLA.Succ 0)
(a_Lena seq)))
$hyp "n_in" (TLA.in n (arith.intrange (TLA.fapply TLA.Succ 0)
(a_Lena seq)))
$hyp "v'252" (arith.lt n m)
$hyp "v'253" (arith.lt (TLA.fapply seq m)
(TLA.fapply seq n))
$hyp "v'254" (-. (= (TLA.fapply Q (TLA.fapply seq m))
BOT))
$hyp "q_in" (TLA.in q ProcSet)
$hyp "v'271" (-. (= (TLA.fapply l p)
(TLA.fapply TLA.Succ 0)))
$hyp "v'278" (TLA.in (TLA.fapply seq m) A)
$goal (TLA.in (TLA.fapply seq m) (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add X
(arith.minus (TLA.fapply TLA.Succ 0)))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hf:"(a_Xhash_primea=X)"
 using v'232 by blast
 have z_Hm:"(A \\in SUBSET(isa'dotdot(1, (a_Xhash_primea +  -.(1)))))" (is "?z_hm")
 using A_in by blast
 have z_Hx:"((seq[m]) \\in A)" (is "?z_hx")
 using v'278 by blast
 assume z_Hy:"(~((seq[m]) \\in isa'dotdot(1, (X +  -.(1)))))" (is "~?z_hbk")
 have z_Hbn: "(A \\subseteq isa'dotdot(1, (a_Xhash_primea +  -.(1))))" (is "?z_hbn")
 by (rule zenon_in_SUBSET_0 [of "A" "isa'dotdot(1, (a_Xhash_primea +  -.(1)))", OF z_Hm])
 have z_Hbo: "(A \\subseteq isa'dotdot(1, (X +  -.(1))))" (is "?z_hbo")
 by (rule subst [where P="(\<lambda>zenon_Vqa. (A \\subseteq isa'dotdot(1, (zenon_Vqa +  -.(1)))))", OF z_Hf z_Hbn])
 have z_Hbu_z_Hbo: "bAll(A, (\<lambda>zenon_Vya. (zenon_Vya \\in isa'dotdot(1, (X +  -.(1)))))) == ?z_hbo" (is "?z_hbu == _")
 by (unfold subset_def)
 have z_Hbu: "?z_hbu"
 by (unfold z_Hbu_z_Hbo, fact z_Hbo)
 have z_Hby_z_Hbu: "(\\A x:((x \\in A)=>(x \\in isa'dotdot(1, (X +  -.(1)))))) == ?z_hbu" (is "?z_hby == _")
 by (unfold bAll_def)
 have z_Hby: "?z_hby" (is "\\A x : ?z_hcd(x)")
 by (unfold z_Hby_z_Hbu, fact z_Hbu)
 have z_Hce: "?z_hcd((seq[m]))"
 by (rule zenon_all_0 [of "?z_hcd" "(seq[m])", OF z_Hby])
 show FALSE
 proof (rule zenon_imply [OF z_Hce])
  assume z_Hcf:"(~?z_hx)"
  show FALSE
  by (rule notE [OF z_Hcf z_Hx])
 next
  assume z_Hbk:"?z_hbk"
  show FALSE
  by (rule notE [OF z_Hy z_Hbk])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 553"; *} qed
lemma ob'521:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'230: "(cond((((fapply ((l), (p))) = ((Succ[0])))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & ((((a_jhash_primea :: c)) = (j)))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D3'')]))) & ((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((Succ[0]))]))))))"
assumes v'231: "(((fapply ((pc), (p))) = (''D2'')))"
assumes v'232: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'233: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'234: "((((a_ihash_primea :: c)) = (i)))"
assumes v'235: "((((a_lhash_primea :: c)) = (l)))"
assumes v'236: "((((a_xhash_primea :: c)) = (x)))"
assumes v'237: "((((a_vhash_primea :: c)) = (v)))"
assumes v'238: "((((a_Mhash_primea :: c)) = (M)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'241: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'242: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'253: "((IsFiniteSet (((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0]))))))))))))))"
assumes v'254: "((\<And> S :: c. (((IsFiniteSet ((S)))) \<Longrightarrow> (\<And> T :: c. T \<in> ((SUBSET (S))) \<Longrightarrow> (((IsFiniteSet ((T)))) & ((leq (((Cardinality ((T)))), ((Cardinality ((S))))))) & ((((((Cardinality ((S)))) = ((Cardinality ((T)))))) \<Rightarrow> (((S) = (T))))))))))"
shows "((IsFiniteSet ((A))))"(is "PROP ?ob'521")
proof -
ML_command {* writeln "*** TLAPS ENTER 521"; *}
show "PROP ?ob'521"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_e2ba96.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_e2ba96.znn.out
;; obligation #521
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'230" (TLA.cond (= (TLA.fapply l p)
(TLA.fapply TLA.Succ 0)) (/\ (= a_pchash_primea (TLA.except pc p "D1"))
(= a_jhash_primea j)) (/\ (= a_pchash_primea (TLA.except pc p "D3"))
(= a_jhash_primea
(TLA.except j p (TLA.fapply TLA.Succ 0)))))
$hyp "v'231" (= (TLA.fapply pc p) "D2")
$hyp "v'232" (= a_Xhash_primea X)
$hyp "v'233" (= a_Qhash_primea Q)
$hyp "v'234" (= a_ihash_primea i)
$hyp "v'235" (= a_lhash_primea l)
$hyp "v'236" (= a_xhash_primea x)
$hyp "v'237" (= a_vhash_primea v)
$hyp "v'238" (= a_Mhash_primea
M)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'241" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'242" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'253" (IsFiniteSet (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add X
(arith.minus (TLA.fapply TLA.Succ 0)))))
$hyp "v'254" (A. ((S) (=> (IsFiniteSet S) (TLA.bAll (TLA.SUBSET S) ((T) (/\ (IsFiniteSet T)
(arith.le (Cardinality T) (Cardinality S)) (=> (= (Cardinality S)
(Cardinality T)) (= S
T))))))))
$goal (IsFiniteSet A)
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hf:"(a_Xhash_primea=X)"
 using v'232 by blast
 have z_Hm:"(A \\in SUBSET(isa'dotdot(1, (a_Xhash_primea +  -.(1)))))" (is "?z_hm")
 using A_in by blast
 have z_Hr:"(\\A S:(IsFiniteSet(S)=>bAll(SUBSET(S), (\<lambda>T. (IsFiniteSet(T)&((Cardinality(T) <= Cardinality(S))&((Cardinality(S)=Cardinality(T))=>(S=T))))))))" (is "\\A x : ?z_hbr(x)")
 using v'254 by blast
 have z_Hq:"IsFiniteSet(isa'dotdot(1, (X +  -.(1))))" (is "?z_hq")
 using v'253 by blast
 assume z_Hs:"(~IsFiniteSet(A))" (is "~?z_hbu")
 have z_Hbv: "(A \\in SUBSET(isa'dotdot(1, (X +  -.(1)))))" (is "?z_hbv")
 by (rule subst [where P="(\<lambda>zenon_Vm. (A \\in SUBSET(isa'dotdot(1, (zenon_Vm +  -.(1))))))", OF z_Hf z_Hm])
 have z_Hcd: "?z_hbr(isa'dotdot(1, (X +  -.(1))))" (is "_=>?z_hce")
 by (rule zenon_all_0 [of "?z_hbr" "isa'dotdot(1, (X +  -.(1)))", OF z_Hr])
 show FALSE
 proof (rule zenon_imply [OF z_Hcd])
  assume z_Hcf:"(~?z_hq)"
  show FALSE
  by (rule notE [OF z_Hcf z_Hq])
 next
  assume z_Hce:"?z_hce"
  have z_Hcg_z_Hce: "(\\A x:((x \\in SUBSET(isa'dotdot(1, (X +  -.(1)))))=>(IsFiniteSet(x)&((Cardinality(x) <= Cardinality(isa'dotdot(1, (X +  -.(1)))))&((Cardinality(isa'dotdot(1, (X +  -.(1))))=Cardinality(x))=>(isa'dotdot(1, (X +  -.(1)))=x)))))) == ?z_hce" (is "?z_hcg == _")
  by (unfold bAll_def)
  have z_Hcg: "?z_hcg" (is "\\A x : ?z_hct(x)")
  by (unfold z_Hcg_z_Hce, fact z_Hce)
  have z_Hcu: "?z_hct(A)" (is "_=>?z_hcv")
  by (rule zenon_all_0 [of "?z_hct" "A", OF z_Hcg])
  show FALSE
  proof (rule zenon_imply [OF z_Hcu])
   assume z_Hcw:"(~?z_hbv)"
   show FALSE
   by (rule notE [OF z_Hcw z_Hbv])
  next
   assume z_Hcv:"?z_hcv" (is "_&?z_hcx")
   have z_Hbu: "?z_hbu"
   by (rule zenon_and_0 [OF z_Hcv])
   show FALSE
   by (rule notE [OF z_Hs z_Hbu])
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 521"; *} qed
lemma ob'503:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'229: "(((fapply ((pc), (p))) = (''D1'')))"
assumes v'230: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D2'')])))"
assumes v'231: "((((a_lhash_primea :: c)) = ([(l) EXCEPT ![(p)] = (X)])))"
assumes v'232: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'233: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'234: "((((a_ihash_primea :: c)) = (i)))"
assumes v'235: "((((a_jhash_primea :: c)) = (j)))"
assumes v'236: "((((a_xhash_primea :: c)) = (x)))"
assumes v'237: "((((a_vhash_primea :: c)) = (v)))"
assumes v'238: "((((a_Mhash_primea :: c)) = (M)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'241: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'242: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
assumes v'255: "((\<And> k :: c. k \<in> ((DOMAIN (seq))) \<Longrightarrow> (((fapply (([ k_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k_1)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k_1)))))))))))))]), (k))) = (fapply (([ k_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k_1))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k_1)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k_1)))))))))))))]), (k)))))))"
shows "((([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k)))))))))))))]) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k)))))))))))))])))"(is "PROP ?ob'503")
proof -
ML_command {* writeln "*** TLAPS ENTER 503"; *}
show "PROP ?ob'503"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_c40c49.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_c40c49.znn.out
;; obligation #503
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'229" (= (TLA.fapply pc p) "D1")
$hyp "v'230" (= a_pchash_primea
(TLA.except pc p "D2"))
$hyp "v'231" (= a_lhash_primea
(TLA.except l p X))
$hyp "v'232" (= a_Xhash_primea X)
$hyp "v'233" (= a_Qhash_primea Q)
$hyp "v'234" (= a_ihash_primea i)
$hyp "v'235" (= a_jhash_primea j)
$hyp "v'236" (= a_xhash_primea x)
$hyp "v'237" (= a_vhash_primea v)
$hyp "v'238" (= a_Mhash_primea
M)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'241" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'242" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'255" (TLA.bAll (TLA.DOMAIN seq) ((k) (= (TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((k_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k_1))
BOT)) (TLA.fapply Q (TLA.fapply seq k_1)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k_1))))))))) k)
(TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((k_1) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k_1))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k_1)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k_1))))))))) k))))
$goal (= (TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k)))))))))
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hs:"bAll(DOMAIN(seq), (\<lambda>k. ((Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))]))))[k])=(Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))]))))[k]))))" (is "?z_hs")
 using v'255 by blast
 assume z_Ht:"(Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))]))))~=Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))))" (is "?z_hz~=?z_hby")
 have z_Hcp: "(~(((isAFcn(?z_hz)&isAFcn(?z_hby))&(DOMAIN(?z_hz)=DOMAIN(?z_hby)))&(\\A zenon_Vi:((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi]))))))" (is "~(?z_hcr&?z_hcy)")
 by (rule zenon_notfunequal_0 [of "?z_hz" "?z_hby", OF z_Ht])
 show FALSE
 proof (rule zenon_notand [OF z_Hcp])
  assume z_Hdf:"(~?z_hcr)" (is "~(?z_hcs&?z_hcv)")
  show FALSE
  proof (rule zenon_notand [OF z_Hdf])
   assume z_Hdg:"(~?z_hcs)" (is "~(?z_hct&?z_hcu)")
   show FALSE
   proof (rule zenon_notand [OF z_Hdg])
    assume z_Hdh:"(~?z_hct)"
    show FALSE
    by (rule zenon_notisafcn_fcn [of "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))])))", OF z_Hdh])
   next
    assume z_Hdi:"(~?z_hcu)"
    show FALSE
    by (rule zenon_notisafcn_fcn [of "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdi])
   qed
  next
   assume z_Hdj:"(DOMAIN(?z_hz)~=DOMAIN(?z_hby))" (is "?z_hcw~=?z_hcx")
   have z_Hdk: "(DOMAIN(seq)~=?z_hcx)" (is "?z_hu~=_")
   by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vrl. (zenon_Vrl~=?z_hcx))" "?z_hu" "(\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))])))", OF z_Hdj])
   have z_Hdo: "(?z_hu~=?z_hu)"
   by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vzk. (?z_hu~=zenon_Vzk))" "?z_hu" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdk])
   show FALSE
   by (rule zenon_noteq [OF z_Hdo])
  qed
 next
  assume z_Hds:"(~?z_hcy)" (is "~(\\A x : ?z_hdt(x))")
  have z_Hdu: "(\\E zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi])))))" (is "\\E x : ?z_hdw(x)")
  by (rule zenon_notallex_0 [of "?z_hdt", OF z_Hds])
  have z_Hdx: "?z_hdw((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi]))))))" (is "~(?z_hdz=>?z_hea)")
  by (rule zenon_ex_choose_0 [of "?z_hdw", OF z_Hdu])
  have z_Hdz: "?z_hdz"
  by (rule zenon_notimply_0 [OF z_Hdx])
  have z_Heb: "((?z_hz[(CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi])))))])~=(?z_hby[(CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi])))))]))" (is "?z_hec~=?z_hed")
  by (rule zenon_notimply_1 [OF z_Hdx])
  have z_Hee: "((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi]))))) \\in DOMAIN(seq))" (is "?z_hee")
  by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vxf. ((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi]))))) \\in zenon_Vxf))" "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdz])
  have z_Hea: "?z_hea"
  by (rule zenon_all_in_0 [of "DOMAIN(seq)" "(\<lambda>k. ((?z_hz[k])=(?z_hby[k])))", OF z_Hs z_Hee])
  show FALSE
  by (rule notE [OF z_Heb z_Hea])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 503"; *} qed
lemma ob'600:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'231: "(((fapply ((pc), (p))) = (''D4'')))"
assumes v'232: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''L0'')])))"
assumes v'233: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'234: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'235: "((((a_ihash_primea :: c)) = (i)))"
assumes v'236: "((((a_jhash_primea :: c)) = (j)))"
assumes v'237: "((((a_lhash_primea :: c)) = (l)))"
assumes v'238: "((((a_xhash_primea :: c)) = (x)))"
assumes v'239: "((((a_vhash_primea :: c)) = (v)))"
assumes v'240: "((((a_Mhash_primea :: c)) = ((Filter ((p), (fapply ((x), (p))))))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'243: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'244: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
fixes d
assumes d_in : "(d \<in> (M))"
assumes v'261: "((\<And> k :: c. k \<in> ((DOMAIN (seq))) \<Longrightarrow> (((fapply (([ k_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k_1)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k_1)))))))))))))]), (k))) = (fapply (([ k_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k_1))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k_1)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k_1)))))))))))))]), (k)))))))"
shows "((([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k)))))))))))))]) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k)))))))))))))])))"(is "PROP ?ob'600")
proof -
ML_command {* writeln "*** TLAPS ENTER 600"; *}
show "PROP ?ob'600"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_2b9028.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_2b9028.znn.out
;; obligation #600
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'231" (= (TLA.fapply pc p) "D4")
$hyp "v'232" (= a_pchash_primea
(TLA.except pc p "L0"))
$hyp "v'233" (= a_Xhash_primea X)
$hyp "v'234" (= a_Qhash_primea Q)
$hyp "v'235" (= a_ihash_primea i)
$hyp "v'236" (= a_jhash_primea j)
$hyp "v'237" (= a_lhash_primea l)
$hyp "v'238" (= a_xhash_primea x)
$hyp "v'239" (= a_vhash_primea v)
$hyp "v'240" (= a_Mhash_primea (Filter p
(TLA.fapply x p)))
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'243" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'244" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "d_in" (TLA.in d M)
$hyp "v'261" (TLA.bAll (TLA.DOMAIN seq) ((k) (= (TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((k_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k_1))
BOT)) (TLA.fapply Q (TLA.fapply seq k_1)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k_1))))))))) k)
(TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((k_1) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k_1))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k_1)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k_1))))))))) k))))
$goal (= (TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k)))))))))
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hs:"bAll(DOMAIN(seq), (\<lambda>k. ((Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))]))))[k])=(Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))]))))[k]))))" (is "?z_hs")
 using v'261 by blast
 assume z_Ht:"(Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))]))))~=Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))))" (is "?z_hz~=?z_hby")
 have z_Hcp: "(~(((isAFcn(?z_hz)&isAFcn(?z_hby))&(DOMAIN(?z_hz)=DOMAIN(?z_hby)))&(\\A zenon_Vi:((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi]))))))" (is "~(?z_hcr&?z_hcy)")
 by (rule zenon_notfunequal_0 [of "?z_hz" "?z_hby", OF z_Ht])
 show FALSE
 proof (rule zenon_notand [OF z_Hcp])
  assume z_Hdf:"(~?z_hcr)" (is "~(?z_hcs&?z_hcv)")
  show FALSE
  proof (rule zenon_notand [OF z_Hdf])
   assume z_Hdg:"(~?z_hcs)" (is "~(?z_hct&?z_hcu)")
   show FALSE
   proof (rule zenon_notand [OF z_Hdg])
    assume z_Hdh:"(~?z_hct)"
    show FALSE
    by (rule zenon_notisafcn_fcn [of "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))])))", OF z_Hdh])
   next
    assume z_Hdi:"(~?z_hcu)"
    show FALSE
    by (rule zenon_notisafcn_fcn [of "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdi])
   qed
  next
   assume z_Hdj:"(DOMAIN(?z_hz)~=DOMAIN(?z_hby))" (is "?z_hcw~=?z_hcx")
   have z_Hdk: "(DOMAIN(seq)~=?z_hcx)" (is "?z_hu~=_")
   by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vrl. (zenon_Vrl~=?z_hcx))" "?z_hu" "(\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))])))", OF z_Hdj])
   have z_Hdo: "(?z_hu~=?z_hu)"
   by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vzk. (?z_hu~=zenon_Vzk))" "?z_hu" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdk])
   show FALSE
   by (rule zenon_noteq [OF z_Hdo])
  qed
 next
  assume z_Hds:"(~?z_hcy)" (is "~(\\A x : ?z_hdt(x))")
  have z_Hdu: "(\\E zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi])))))" (is "\\E x : ?z_hdw(x)")
  by (rule zenon_notallex_0 [of "?z_hdt", OF z_Hds])
  have z_Hdx: "?z_hdw((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi]))))))" (is "~(?z_hdz=>?z_hea)")
  by (rule zenon_ex_choose_0 [of "?z_hdw", OF z_Hdu])
  have z_Hdz: "?z_hdz"
  by (rule zenon_notimply_0 [OF z_Hdx])
  have z_Heb: "((?z_hz[(CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi])))))])~=(?z_hby[(CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi])))))]))" (is "?z_hec~=?z_hed")
  by (rule zenon_notimply_1 [OF z_Hdx])
  have z_Hee: "((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi]))))) \\in DOMAIN(seq))" (is "?z_hee")
  by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vxf. ((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hby))=>((?z_hz[zenon_Vi])=(?z_hby[zenon_Vi]))))) \\in zenon_Vxf))" "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdz])
  have z_Hea: "?z_hea"
  by (rule zenon_all_in_0 [of "DOMAIN(seq)" "(\<lambda>k. ((?z_hz[k])=(?z_hby[k])))", OF z_Hs z_Hee])
  show FALSE
  by (rule notE [OF z_Heb z_Hea])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 600"; *} qed
lemma ob'593:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'230: "(((fapply ((pc), (p))) = (''D4'')))"
assumes v'231: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''L0'')])))"
assumes v'232: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'233: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'234: "((((a_ihash_primea :: c)) = (i)))"
assumes v'235: "((((a_jhash_primea :: c)) = (j)))"
assumes v'236: "((((a_lhash_primea :: c)) = (l)))"
assumes v'237: "((((a_xhash_primea :: c)) = (x)))"
assumes v'238: "((((a_vhash_primea :: c)) = (v)))"
assumes v'239: "((((a_Mhash_primea :: c)) = ((Filter ((p), (fapply ((x), (p))))))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'242: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'243: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
fixes d
assumes d_in : "(d \<in> (M))"
assumes v'260: "((GoodRes ((A), (fapply ((d), (''fres''))))))"
assumes v'261: "(((fapply ((d), (''sigma''))) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply ((pc), (q))) = (''E2''))) \<and> (((fapply ((i), (q))) = (fapply ((seq), (k)))))))))))))])))"
assumes v'262: "((([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k)))))))))))))]) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k)))))))))))))])))"
shows "(((fapply ((((''sigma'' :> (fapply ((d), (''sigma'')))) @@ (''fres'' :> ([(fapply ((d), (''fres''))) EXCEPT ![(p)] = (BOT)])))), (''sigma''))) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (k)))))))))))))])))"(is "PROP ?ob'593")
proof -
ML_command {* writeln "*** TLAPS ENTER 593"; *}
show "PROP ?ob'593"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_3e4b1c.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_3e4b1c.znn.out
;; obligation #593
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'230" (= (TLA.fapply pc p) "D4")
$hyp "v'231" (= a_pchash_primea
(TLA.except pc p "L0"))
$hyp "v'232" (= a_Xhash_primea X)
$hyp "v'233" (= a_Qhash_primea Q)
$hyp "v'234" (= a_ihash_primea i)
$hyp "v'235" (= a_jhash_primea j)
$hyp "v'236" (= a_lhash_primea l)
$hyp "v'237" (= a_xhash_primea x)
$hyp "v'238" (= a_vhash_primea v)
$hyp "v'239" (= a_Mhash_primea (Filter p
(TLA.fapply x p)))
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'242" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'243" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "d_in" (TLA.in d M)
$hyp "v'260" (GoodRes A
(TLA.fapply d "fres"))
$hyp "v'261" (= (TLA.fapply d "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply pc q)
"E2") (= (TLA.fapply i q)
(TLA.fapply seq k))))))))))
$hyp "v'262" (= (TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k)))))))))
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k))))))))))
$goal (= (TLA.fapply (TLA.record "sigma" (TLA.fapply d "sigma") "fres" (TLA.except (TLA.fapply d "fres") p BOT)) "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq k))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hu:"(Fcn(DOMAIN(seq), (\<lambda>k. (CASE ((Q[(seq[k])])~=BOT) -> (Q[(seq[k])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((pc[q])=''E2'')&((i[q])=(seq[k])))))]))))=Fcn(DOMAIN(seq), (\<lambda>k. (CASE ((a_Qhash_primea[(seq[k])])~=BOT) -> (a_Qhash_primea[(seq[k])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k])))))])))))" (is "?z_hw=?z_hbv")
 using v'262 by blast
 have z_Ht:"((d[''sigma''])=?z_hw)" (is "?z_hcn=_")
 using v'261 by blast
 assume z_Hv:"(((''sigma'' :> (?z_hcn) @@ ''fres'' :> (except((d[''fres'']), p, BOT)))[''sigma''])~=?z_hbv)" (is "?z_hcq~=_")
 show FALSE
 proof (rule notE [OF z_Hv])
  have z_Hcw: "(?z_hw=?z_hcq)"
  proof (rule zenon_nnpp [of "(?z_hw=?z_hcq)"])
   assume z_Hcx:"(?z_hw~=?z_hcq)"
   show FALSE
   proof (rule zenon_em [of "(?z_hcq=?z_hcq)"])
    assume z_Hcy:"(?z_hcq=?z_hcq)"
    show FALSE
    proof (rule notE [OF z_Hcx])
     have z_Hcz: "(?z_hcq=?z_hw)"
     proof (rule zenon_nnpp [of "(?z_hcq=?z_hw)"])
      assume z_Hda:"(?z_hcq~=?z_hw)"
      have z_Hdb: "((''sigma'' \\in DOMAIN((''sigma'' :> (?z_hcn) @@ ''fres'' :> (except((d[''fres'']), p, BOT)))))&(?z_hcq=?z_hcn))" (is "?z_hdc&?z_hde")
      by ((rule zenon_recfield_1)+, rule zenon_recfield_2b)
      have z_Hde: "?z_hde"
      by (rule conjD2 [OF z_Hdb])
      have z_Hdf: "(?z_hcn~=?z_hw)"
      by (rule subst [where P="(\<lambda>zenon_Vkb. (zenon_Vkb~=?z_hw))", OF z_Hde z_Hda])
      show FALSE
      by (rule notE [OF z_Hdf z_Ht])
     qed
     have z_Hcw: "(?z_hw=?z_hcq)"
     by (rule subst [where P="(\<lambda>zenon_Vob. (zenon_Vob=?z_hcq))", OF z_Hcz], fact z_Hcy)
     thus "(?z_hw=?z_hcq)" .
    qed
   next
    assume z_Hdm:"(?z_hcq~=?z_hcq)"
    show FALSE
    by (rule zenon_noteq [OF z_Hdm])
   qed
  qed
  have z_Hdn: "(?z_hcq=?z_hbv)"
  by (rule subst [where P="(\<lambda>zenon_Vh. (zenon_Vh=?z_hbv))", OF z_Hcw], fact z_Hu)
  thus "(?z_hcq=?z_hbv)" .
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 593"; *} qed
lemma ob'589:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'201: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'207: "(((((((pc) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & (((X) \<in> (((Nat) \\ ({((0))}))))) & (((Q) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((i) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((j) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((l) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((x) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((v) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((M) \<in> ((SUBSET (subsetOf(([''sigma'' : ((Seqs ((((Nat) \\ ({((0))})))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %a_ca. ((CFTypeOK ((a_ca))))))))))) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'228: "(((fapply ((pc), (p))) = (''D4'')))"
assumes v'229: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''L0'')])))"
assumes v'230: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'231: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'232: "((((a_ihash_primea :: c)) = (i)))"
assumes v'233: "((((a_jhash_primea :: c)) = (j)))"
assumes v'234: "((((a_lhash_primea :: c)) = (l)))"
assumes v'235: "((((a_xhash_primea :: c)) = (x)))"
assumes v'236: "((((a_vhash_primea :: c)) = (v)))"
assumes v'237: "((((a_Mhash_primea :: c)) = (subsetOf(([''sigma'' : ((Seqs ((((Nat) \\ ({((0))})))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])]), %d. (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((a_ca), (''fres''))), (p))) = (fapply ((x), (p))))) & (((fapply ((fapply ((d), (''fres''))), (p))) = (BOT))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = (fapply ((a_ca), (''sigma'')))))))))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'240: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'241: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
fixes d
assumes d_in : "(d \<in> (M))"
assumes v'256: "(((fapply ((fapply ((d), (''fres''))), (p))) = (fapply ((x), (p)))))"
assumes v'257: "(((((''sigma'' :> (fapply ((d), (''sigma'')))) @@ (''fres'' :> ([(fapply ((d), (''fres''))) EXCEPT ![(p)] = (BOT)])))) \<in> ([''sigma'' : ((Seqs ((((Nat) \\ ({((0))})))))), ''fres'' : ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(ACK), (BOT)})))])])))"
shows "(((((''sigma'' :> (fapply ((d), (''sigma'')))) @@ (''fres'' :> ([(fapply ((d), (''fres''))) EXCEPT ![(p)] = (BOT)])))) \<in> ((a_Mhash_primea :: c))))"(is "PROP ?ob'589")
proof -
ML_command {* writeln "*** TLAPS ENTER 589"; *}
show "PROP ?ob'589"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_039933.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_039933.znn.out
;; obligation #589
$hyp "v'201" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'207" (/\ (/\ (/\ (TLA.in pc
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in X (TLA.setminus arith.N (TLA.set 0))) (TLA.in Q
(TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in i (TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in j
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in l
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in x
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in v (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in M
(TLA.SUBSET (TLA.subsetOf (TLA.recordset "sigma" (Seqs (TLA.setminus arith.N
(TLA.set 0))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0)) (TLA.set ACK BOT)))) ((a_ca) (CFTypeOK a_ca)))))) a_Invunde_E2a
a_Invunde_E3a a_Invunde_D2a a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina)
(\/ Next (= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'228" (= (TLA.fapply pc p) "D4")
$hyp "v'229" (= a_pchash_primea
(TLA.except pc p "L0"))
$hyp "v'230" (= a_Xhash_primea X)
$hyp "v'231" (= a_Qhash_primea Q)
$hyp "v'232" (= a_ihash_primea i)
$hyp "v'233" (= a_jhash_primea j)
$hyp "v'234" (= a_lhash_primea l)
$hyp "v'235" (= a_xhash_primea x)
$hyp "v'236" (= a_vhash_primea v)
$hyp "v'237" (= a_Mhash_primea
(TLA.subsetOf (TLA.recordset "sigma" (Seqs (TLA.setminus arith.N
(TLA.set 0))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))) ((d) (TLA.bEx M ((a_ca) (/\ (= (TLA.fapply (TLA.fapply a_ca "fres") p)
(TLA.fapply x p)) (= (TLA.fapply (TLA.fapply d "fres") p) BOT)
(TLA.bAll ProcSet ((q) (=> (-. (= q p))
(= (TLA.fapply (TLA.fapply d "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))) (= (TLA.fapply d "sigma")
(TLA.fapply a_ca "sigma"))))))))
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'240" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'241" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "d_in" (TLA.in d M)
$hyp "v'256" (= (TLA.fapply (TLA.fapply d "fres") p)
(TLA.fapply x p))
$hyp "v'257" (TLA.in (TLA.record "sigma" (TLA.fapply d "sigma") "fres" (TLA.except (TLA.fapply d "fres") p BOT))
(TLA.recordset "sigma" (Seqs (TLA.setminus arith.N
(TLA.set 0))) "fres" (TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N
(TLA.set 0))
(TLA.set ACK BOT)))))
$goal (TLA.in (TLA.record "sigma" (TLA.fapply d "sigma") "fres" (TLA.except (TLA.fapply d "fres") p BOT))
a_Mhash_primea)
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hm:"(a_Mhash_primea=subsetOf([''sigma'' : (Seqs((Nat \\ {0}))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))], (\<lambda>d. bEx(M, (\<lambda>a_ca. ((((a_ca[''fres''])[p])=(x[p]))&((((d[''fres''])[p])=BOT)&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=(a_ca[''sigma'']))))))))))" (is "_=?z_hw")
 using v'237 by blast
 have z_Hr:"(d \\in M)" (is "?z_hr")
 using d_in by blast
 have z_Hs:"(((d[''fres''])[p])=(x[p]))" (is "?z_hbz=?z_hbv")
 using v'256 by blast
 have z_Hc:"(p \\in ProcSet)" (is "?z_hc")
 using p_in by blast
 have z_Ht:"((''sigma'' :> ((d[''sigma''])) @@ ''fres'' :> (except((d[''fres'']), p, BOT))) \\in [''sigma'' : (Seqs((Nat \\ {0}))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))])" (is "?z_ht")
 using v'257 by blast
 assume z_Hu:"(~((''sigma'' :> ((d[''sigma''])) @@ ''fres'' :> (except((d[''fres'']), p, BOT))) \\in a_Mhash_primea))" (is "~?z_hcq")
 let ?z_hco = "(''sigma'' :> ((d[''sigma''])) @@ ''fres'' :> (except((d[''fres'']), p, BOT)))"
 let ?z_hcr = "<<''sigma'', ''fres''>>"
 let ?z_hcs = "<<Seqs((Nat \\ {0})), FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT}))>>"
 have z_Hct: "(2 \\in DOMAIN(?z_hcr))" by auto
 have z_Hcw: "((?z_hco[(?z_hcr[2])]) \\in (?z_hcs[2]))" (is "?z_hcw")
 by (rule zenon_in_recordset_field [OF z_Ht z_Hct])
 have z_Hda: "((?z_hco[''fres'']) \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))" (is "?z_hda")
 using z_Hcw by auto
 have z_Hdc: "((''fres'' \\in DOMAIN(?z_hco))&((?z_hco[''fres''])=except((d[''fres'']), p, BOT)))" (is "?z_hdd&?z_hdf")
 by (rule zenon_recfield_2, ((rule zenon_recfield_3)+)?, rule zenon_recfield_3b, auto)
 have z_Hdf: "?z_hdf" (is "?z_hdb=?z_hcp")
 by (rule conjD2 [OF z_Hdc])
 have z_Hdg: "(?z_hcp \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))" (is "?z_hdg")
 by (rule subst [where P="(\<lambda>zenon_Vrb. (zenon_Vrb \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT}))))", OF z_Hdf z_Hda])
 have z_Hdk: "(DOMAIN(?z_hcp)=ProcSet)" (is "?z_hdl=_")
 by (rule zenon_in_funcset_1 [of "?z_hcp" "ProcSet" "((Nat \\ {0}) \\cup {ACK, BOT})", OF z_Hdg])
 have z_Hdm: "(~(?z_hco \\in ?z_hw))" (is "~?z_hdn")
 by (rule subst [where P="(\<lambda>zenon_Vgfa. (~(?z_hco \\in zenon_Vgfa)))", OF z_Hm z_Hu])
 show FALSE
 proof (rule zenon_notin_subsetof [of "?z_hco" "[''sigma'' : (Seqs((Nat \\ {0}))), ''fres'' : (FuncSet(ProcSet, ((Nat \\ {0}) \\cup {ACK, BOT})))]" "(\<lambda>d. bEx(M, (\<lambda>a_ca. ((((a_ca[''fres''])[p])=?z_hbv)&((((d[''fres''])[p])=BOT)&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=(a_ca[''sigma'']))))))))", OF z_Hdm])
  assume z_Hds:"(~?z_ht)"
  show FALSE
  by (rule notE [OF z_Hds z_Ht])
 next
  assume z_Hdt:"(~bEx(M, (\<lambda>a_ca. ((((a_ca[''fres''])[p])=?z_hbv)&(((?z_hdb[p])=BOT)&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>((?z_hdb[q])=((a_ca[''fres''])[q])))))&((?z_hco[''sigma''])=(a_ca[''sigma'']))))))))" (is "~?z_hdu")
  have z_Hei_z_Hdt: "(~(\\E zenon_Vbf:((zenon_Vbf \\in M)&((((zenon_Vbf[''fres''])[p])=?z_hbv)&(((?z_hdb[p])=BOT)&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>((?z_hdb[q])=((zenon_Vbf[''fres''])[q])))))&((?z_hco[''sigma''])=(zenon_Vbf[''sigma''])))))))) == (~?z_hdu)" (is "?z_hei == ?z_hdt")
  by (unfold bEx_def)
  have z_Hei: "?z_hei" (is "~(\\E x : ?z_hfa(x))")
  by (unfold z_Hei_z_Hdt, fact z_Hdt)
  have z_Hfb: "~?z_hfa(d)" (is "~(_&?z_hfc)")
  by (rule zenon_notex_0 [of "?z_hfa" "d", OF z_Hei])
  show FALSE
  proof (rule zenon_notand [OF z_Hfb])
   assume z_Hfd:"(~?z_hr)"
   show FALSE
   by (rule notE [OF z_Hfd z_Hr])
  next
   assume z_Hfe:"(~?z_hfc)" (is "~(?z_hs&?z_hff)")
   show FALSE
   proof (rule zenon_notand [OF z_Hfe])
    assume z_Hfg:"(?z_hbz~=?z_hbv)"
    show FALSE
    by (rule notE [OF z_Hfg z_Hs])
   next
    assume z_Hfh:"(~?z_hff)" (is "~(?z_hdy&?z_hfi)")
    show FALSE
    proof (rule zenon_notand [OF z_Hfh])
     assume z_Hfj:"((?z_hdb[p])~=BOT)" (is "?z_hdz~=_")
     have z_Hdc: "(?z_hdd&?z_hdf)"
     by (rule zenon_recfield_2, ((rule zenon_recfield_3)+)?, rule zenon_recfield_3b, auto)
     have z_Hdf: "?z_hdf"
     by (rule conjD2 [OF z_Hdc])
     have z_Hfk: "((?z_hcp[p])~=BOT)" (is "?z_hfl~=_")
     by (rule subst [where P="(\<lambda>zenon_Vih. ((zenon_Vih[p])~=BOT))", OF z_Hdf z_Hfj])
     show FALSE
     proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vz. (zenon_Vz~=BOT))" "(d[''fres''])" "p" "BOT" "p", OF z_Hfk])
      assume z_Hft:"(p \\in DOMAIN((d[''fres''])))" (is "?z_hft")
      assume z_Hfv:"(p=p)"
      assume z_Hfw:"(BOT~=BOT)"
      show FALSE
      by (rule zenon_noteq [OF z_Hfw])
     next
      assume z_Hft:"(p \\in DOMAIN((d[''fres''])))" (is "?z_hft")
      assume z_Hfx:"(p~=p)"
      assume z_Hfy:"(?z_hbz~=BOT)"
      show FALSE
      by (rule zenon_noteq [OF z_Hfx])
     next
      assume z_Hfz:"(~(p \\in DOMAIN((d[''fres'']))))" (is "~?z_hft")
      have z_Hga: "(\\A zenon_Vhc:((zenon_Vhc \\in ?z_hdl)<=>(zenon_Vhc \\in ProcSet)))" (is "\\A x : ?z_hgf(x)")
      by (rule zenon_setequal_0 [of "?z_hdl" "ProcSet", OF z_Hdk])
      have z_Hgg: "?z_hgf(p)" (is "?z_hgh<=>_")
      by (rule zenon_all_0 [of "?z_hgf" "p", OF z_Hga])
      show FALSE
      proof (rule zenon_equiv [OF z_Hgg])
       assume z_Hgi:"(~?z_hgh)"
       assume z_Hgj:"(~?z_hc)"
       show FALSE
       by (rule notE [OF z_Hgj z_Hc])
      next
       assume z_Hgh:"?z_hgh"
       assume z_Hc:"?z_hc"
       have z_Hft: "?z_hft"
       by (rule zenon_domain_except_0 [of "(\<lambda>zenon_Vvea. (p \\in zenon_Vvea))" "(d[''fres''])" "p" "BOT", OF z_Hgh])
       show FALSE
       by (rule notE [OF z_Hfz z_Hft])
      qed
     qed
    next
     assume z_Hgn:"(~?z_hfi)" (is "~(?z_hgo&?z_hgp)")
     show FALSE
     proof (rule zenon_notand [OF z_Hgn])
      assume z_Hgq:"(~?z_hgo)"
      have z_Hgr_z_Hgq: "(~(\\A x:((x \\in ProcSet)=>((x~=p)=>((?z_hdb[x])=((d[''fres''])[x])))))) == (~?z_hgo)" (is "?z_hgr == ?z_hgq")
      by (unfold bAll_def)
      have z_Hgr: "?z_hgr" (is "~(\\A x : ?z_hha(x))")
      by (unfold z_Hgr_z_Hgq, fact z_Hgq)
      have z_Hhb: "(\\E x:(~((x \\in ProcSet)=>((x~=p)=>((?z_hdb[x])=((d[''fres''])[x]))))))" (is "\\E x : ?z_hhd(x)")
      by (rule zenon_notallex_0 [of "?z_hha", OF z_Hgr])
      have z_Hhe: "?z_hhd((CHOOSE x:(~((x \\in ProcSet)=>((x~=p)=>((?z_hdb[x])=((d[''fres''])[x])))))))" (is "~(?z_hhg=>?z_hhh)")
      by (rule zenon_ex_choose_0 [of "?z_hhd", OF z_Hhb])
      have z_Hhg: "?z_hhg"
      by (rule zenon_notimply_0 [OF z_Hhe])
      have z_Hhi: "(~?z_hhh)" (is "~(?z_hhj=>?z_hhk)")
      by (rule zenon_notimply_1 [OF z_Hhe])
      have z_Hhj: "?z_hhj" (is "?z_hhf~=_")
      by (rule zenon_notimply_0 [OF z_Hhi])
      have z_Hhl: "((?z_hdb[?z_hhf])~=((d[''fres''])[?z_hhf]))" (is "?z_hhm~=?z_hhn")
      by (rule zenon_notimply_1 [OF z_Hhi])
      have z_Hho: "(?z_hhf \\in ?z_hdl)" (is "?z_hho")
      by (rule ssubst [where P="(\<lambda>zenon_Vbg. (?z_hhf \\in zenon_Vbg))", OF z_Hdk z_Hhg])
      have z_Hhs: "(?z_hhf \\in DOMAIN((d[''fres''])))" (is "?z_hhs")
      by (rule zenon_domain_except_0 [of "(\<lambda>zenon_Vbg. (?z_hhf \\in zenon_Vbg))" "(d[''fres''])" "p" "BOT", OF z_Hho])
      have z_Hdc: "(?z_hdd&?z_hdf)"
      by (rule zenon_recfield_2, ((rule zenon_recfield_3)+)?, rule zenon_recfield_3b, auto)
      have z_Hdf: "?z_hdf"
      by (rule conjD2 [OF z_Hdc])
      have z_Hht: "((?z_hcp[?z_hhf])~=?z_hhn)" (is "?z_hhu~=_")
      by (rule subst [where P="(\<lambda>zenon_Vyf. ((zenon_Vyf[?z_hhf])~=?z_hhn))", OF z_Hdf z_Hhl])
      show FALSE
      proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vyf. (zenon_Vyf~=?z_hhn))" "(d[''fres''])" "p" "BOT" "?z_hhf", OF z_Hht])
       assume z_Hhs:"?z_hhs"
       assume z_Hib:"(p=?z_hhf)"
       assume z_Hic:"(BOT~=?z_hhn)"
       show FALSE
       by (rule zenon_eqsym [OF z_Hib z_Hhj])
      next
       assume z_Hhs:"?z_hhs"
       assume z_Hid:"(p~=?z_hhf)"
       assume z_Hie:"(?z_hhn~=?z_hhn)"
       show FALSE
       by (rule zenon_noteq [OF z_Hie])
      next
       assume z_Hif:"(~?z_hhs)"
       show FALSE
       by (rule notE [OF z_Hif z_Hhs])
      qed
     next
      assume z_Hig:"((?z_hco[''sigma''])~=(d[''sigma'']))" (is "?z_heh~=?z_hcm")
      have z_Hih: "((''sigma'' \\in DOMAIN(?z_hco))&?z_hgp)" (is "?z_hii&_")
      by ((rule zenon_recfield_1)+, rule zenon_recfield_2b)
      have z_Hgp: "?z_hgp"
      by (rule conjD2 [OF z_Hih])
      have z_Hij: "(?z_hcm~=?z_hcm)"
      by (rule subst [where P="(\<lambda>zenon_Vpf. (zenon_Vpf~=?z_hcm))", OF z_Hgp z_Hig])
      show FALSE
      by (rule zenon_noteq [OF z_Hij])
     qed
    qed
   qed
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 589"; *} qed
lemma ob'566:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'230: "(cond((((fapply ((l), (p))) = ((Succ[0])))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & ((((a_jhash_primea :: c)) = (j)))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D3'')]))) & ((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((Succ[0]))]))))))"
assumes v'231: "(((fapply ((pc), (p))) = (''D2'')))"
assumes v'232: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'233: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'234: "((((a_ihash_primea :: c)) = (i)))"
assumes v'235: "((((a_lhash_primea :: c)) = (l)))"
assumes v'236: "((((a_xhash_primea :: c)) = (x)))"
assumes v'237: "((((a_vhash_primea :: c)) = (v)))"
assumes v'238: "((((a_Mhash_primea :: c)) = (M)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'241: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'242: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
assumes v'258: "((\<And> k :: c. k \<in> ((DOMAIN (seq))) \<Longrightarrow> (((fapply (([ k_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k_1)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k_1)))))))))))))]), (k))) = (fapply (([ k_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k_1))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k_1)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k_1)))))))))))))]), (k)))))))"
shows "((([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k)))))))))))))]) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k)))))))))))))])))"(is "PROP ?ob'566")
proof -
ML_command {* writeln "*** TLAPS ENTER 566"; *}
show "PROP ?ob'566"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_36663e.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_36663e.znn.out
;; obligation #566
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'230" (TLA.cond (= (TLA.fapply l p)
(TLA.fapply TLA.Succ 0)) (/\ (= a_pchash_primea (TLA.except pc p "D1"))
(= a_jhash_primea j)) (/\ (= a_pchash_primea (TLA.except pc p "D3"))
(= a_jhash_primea
(TLA.except j p (TLA.fapply TLA.Succ 0)))))
$hyp "v'231" (= (TLA.fapply pc p) "D2")
$hyp "v'232" (= a_Xhash_primea X)
$hyp "v'233" (= a_Qhash_primea Q)
$hyp "v'234" (= a_ihash_primea i)
$hyp "v'235" (= a_lhash_primea l)
$hyp "v'236" (= a_xhash_primea x)
$hyp "v'237" (= a_vhash_primea v)
$hyp "v'238" (= a_Mhash_primea
M)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'241" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'242" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'258" (TLA.bAll (TLA.DOMAIN seq) ((k) (= (TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((k_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k_1))
BOT)) (TLA.fapply Q (TLA.fapply seq k_1)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k_1))))))))) k)
(TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((k_1) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k_1))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k_1)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k_1))))))))) k))))
$goal (= (TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k)))))))))
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hr:"bAll(DOMAIN(seq), (\<lambda>k. ((Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))]))))[k])=(Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))]))))[k]))))" (is "?z_hr")
 using v'258 by blast
 assume z_Hs:"(Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))]))))~=Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))))" (is "?z_hy~=?z_hbx")
 have z_Hco: "(~(((isAFcn(?z_hy)&isAFcn(?z_hbx))&(DOMAIN(?z_hy)=DOMAIN(?z_hbx)))&(\\A zenon_Vi:((zenon_Vi \\in DOMAIN(?z_hbx))=>((?z_hy[zenon_Vi])=(?z_hbx[zenon_Vi]))))))" (is "~(?z_hcq&?z_hcx)")
 by (rule zenon_notfunequal_0 [of "?z_hy" "?z_hbx", OF z_Hs])
 show FALSE
 proof (rule zenon_notand [OF z_Hco])
  assume z_Hde:"(~?z_hcq)" (is "~(?z_hcr&?z_hcu)")
  show FALSE
  proof (rule zenon_notand [OF z_Hde])
   assume z_Hdf:"(~?z_hcr)" (is "~(?z_hcs&?z_hct)")
   show FALSE
   proof (rule zenon_notand [OF z_Hdf])
    assume z_Hdg:"(~?z_hcs)"
    show FALSE
    by (rule zenon_notisafcn_fcn [of "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))])))", OF z_Hdg])
   next
    assume z_Hdh:"(~?z_hct)"
    show FALSE
    by (rule zenon_notisafcn_fcn [of "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdh])
   qed
  next
   assume z_Hdi:"(DOMAIN(?z_hy)~=DOMAIN(?z_hbx))" (is "?z_hcv~=?z_hcw")
   have z_Hdj: "(DOMAIN(seq)~=?z_hcw)" (is "?z_ht~=_")
   by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vsp. (zenon_Vsp~=?z_hcw))" "?z_ht" "(\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))])))", OF z_Hdi])
   have z_Hdn: "(?z_ht~=?z_ht)"
   by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vjp. (?z_ht~=zenon_Vjp))" "?z_ht" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdj])
   show FALSE
   by (rule zenon_noteq [OF z_Hdn])
  qed
 next
  assume z_Hdr:"(~?z_hcx)" (is "~(\\A x : ?z_hds(x))")
  have z_Hdt: "(\\E zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbx))=>((?z_hy[zenon_Vi])=(?z_hbx[zenon_Vi])))))" (is "\\E x : ?z_hdv(x)")
  by (rule zenon_notallex_0 [of "?z_hds", OF z_Hdr])
  have z_Hdw: "?z_hdv((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbx))=>((?z_hy[zenon_Vi])=(?z_hbx[zenon_Vi]))))))" (is "~(?z_hdy=>?z_hdz)")
  by (rule zenon_ex_choose_0 [of "?z_hdv", OF z_Hdt])
  have z_Hdy: "?z_hdy"
  by (rule zenon_notimply_0 [OF z_Hdw])
  have z_Hea: "((?z_hy[(CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbx))=>((?z_hy[zenon_Vi])=(?z_hbx[zenon_Vi])))))])~=(?z_hbx[(CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbx))=>((?z_hy[zenon_Vi])=(?z_hbx[zenon_Vi])))))]))" (is "?z_heb~=?z_hec")
  by (rule zenon_notimply_1 [OF z_Hdw])
  have z_Hed: "((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbx))=>((?z_hy[zenon_Vi])=(?z_hbx[zenon_Vi]))))) \\in DOMAIN(seq))" (is "?z_hed")
  by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vvh. ((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbx))=>((?z_hy[zenon_Vi])=(?z_hbx[zenon_Vi]))))) \\in zenon_Vvh))" "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdy])
  have z_Hdz: "?z_hdz"
  by (rule zenon_all_in_0 [of "DOMAIN(seq)" "(\<lambda>k. ((?z_hy[k])=(?z_hbx[k])))", OF z_Hr z_Hed])
  show FALSE
  by (rule notE [OF z_Hea z_Hdz])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 566"; *} qed
lemma ob'675:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'231: "(cond((((fapply ((Q), (fapply ((j), (p))))) = (BOT))), (cond((((fapply ((j), (p))) = ((arith_add ((fapply ((l), (p))), ((minus (((Succ[0])))))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & (((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (M))))), (((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((arith_add ((fapply ((j), (p))), ((Succ[0])))))]))) & (((((a_pchash_primea :: c)) = (pc))) & ((((a_Mhash_primea :: c)) = (M))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D4'')]))) & ((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %d. (((a_h022c5783954683bdcbcacced356fd6a ((d)) :: c)) & (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((d), (''fres''))), (p))) = ((Head ((fapply ((a_ca), (''sigma'')))))))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = ((Tail ((fapply ((a_ca), (''sigma''))))))))))))))))))"
assumes v'232: "(((fapply ((pc), (p))) = (''D3'')))"
assumes v'233: "((((a_xhash_primea :: c)) = ([(x) EXCEPT ![(p)] = (fapply ((Q), (fapply ((j), (p)))))])))"
assumes v'234: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((j), (p)))] = (BOT)])))"
assumes v'235: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'236: "((((a_ihash_primea :: c)) = (i)))"
assumes v'237: "((((a_lhash_primea :: c)) = (l)))"
assumes v'238: "((((a_vhash_primea :: c)) = (v)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'241: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'242: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'250: "(((fapply ((Q), (fapply ((j), (p))))) = (BOT)))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
assumes v'262: "((GoodRes ((A), (fapply ((a_ca), (''fres''))))))"
assumes v'263: "(((fapply ((a_ca), (''sigma''))) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply ((pc), (q))) = (''E2''))) \<and> (((fapply ((i), (q))) = (fapply ((seq), (k)))))))))))))])))"
assumes v'264: "((([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k)))))))))))))]) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k)))))))))))))])))"
shows "(((fapply ((a_ca), (''sigma''))) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (k)))))))))))))])))"(is "PROP ?ob'675")
proof -
ML_command {* writeln "*** TLAPS ENTER 675"; *}
show "PROP ?ob'675"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_25f19a.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_25f19a.znn.out
;; obligation #675
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'231" (TLA.cond (= (TLA.fapply Q (TLA.fapply j p))
BOT) (TLA.cond (= (TLA.fapply j p) (arith.add (TLA.fapply l p)
(arith.minus (TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea
(TLA.except pc p "D1")) (/\ (= a_jhash_primea j) (= a_Mhash_primea
M))) (/\ (= a_jhash_primea (TLA.except j p (arith.add (TLA.fapply j p)
(TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea pc) (= a_Mhash_primea
M)))) (/\ (= a_pchash_primea (TLA.except pc p "D4")) (= a_jhash_primea j)
(= a_Mhash_primea
(TLA.subsetOf CDomain ((d) (/\ (a_h022c5783954683bdcbcacced356fd6a d)
(TLA.bEx M ((a_ca) (/\ (= (TLA.fapply (TLA.fapply d "fres") p)
(Head (TLA.fapply a_ca "sigma"))) (TLA.bAll ProcSet ((q) (=> (-. (= q p))
(= (TLA.fapply (TLA.fapply d "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))) (= (TLA.fapply d "sigma")
(Tail (TLA.fapply a_ca "sigma"))))))))))))
$hyp "v'232" (= (TLA.fapply pc p) "D3")
$hyp "v'233" (= a_xhash_primea
(TLA.except x p (TLA.fapply Q (TLA.fapply j p))))
$hyp "v'234" (= a_Qhash_primea
(TLA.except Q (TLA.fapply j p) BOT))
$hyp "v'235" (= a_Xhash_primea X)
$hyp "v'236" (= a_ihash_primea i)
$hyp "v'237" (= a_lhash_primea l)
$hyp "v'238" (= a_vhash_primea
v)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'241" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'242" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'250" (= (TLA.fapply Q (TLA.fapply j p))
BOT)
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'262" (GoodRes A
(TLA.fapply a_ca "fres"))
$hyp "v'263" (= (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply pc q)
"E2") (= (TLA.fapply i q)
(TLA.fapply seq k))))))))))
$hyp "v'264" (= (TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k)))))))))
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k))))))))))
$goal (= (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq k))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Ht:"(Fcn(DOMAIN(seq), (\<lambda>k. (CASE ((Q[(seq[k])])~=BOT) -> (Q[(seq[k])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((pc[q])=''E2'')&((i[q])=(seq[k])))))]))))=Fcn(DOMAIN(seq), (\<lambda>k. (CASE ((a_Qhash_primea[(seq[k])])~=BOT) -> (a_Qhash_primea[(seq[k])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k])))))])))))" (is "?z_hv=?z_hbu")
 using v'264 by blast
 have z_Hs:"((a_ca[''sigma''])=?z_hv)" (is "?z_hcm=_")
 using v'263 by blast
 assume z_Hu:"(?z_hcm~=?z_hbu)"
 show FALSE
 proof (rule notE [OF z_Hu])
  have z_Hcp: "(?z_hv=?z_hcm)"
  by (rule sym [OF z_Hs])
  have z_Hcq: "(?z_hcm=?z_hbu)"
  by (rule subst [where P="(\<lambda>zenon_Vi. (zenon_Vi=?z_hbu))", OF z_Hcp], fact z_Ht)
  thus "(?z_hcm=?z_hbu)" .
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 675"; *} qed
lemma ob'666:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'231: "(cond((((fapply ((Q), (fapply ((j), (p))))) = (BOT))), (cond((((fapply ((j), (p))) = ((arith_add ((fapply ((l), (p))), ((minus (((Succ[0])))))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & (((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (M))))), (((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((arith_add ((fapply ((j), (p))), ((Succ[0])))))]))) & (((((a_pchash_primea :: c)) = (pc))) & ((((a_Mhash_primea :: c)) = (M))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D4'')]))) & ((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %d. (((a_h022c5783954683bdcbcacced356fd6a ((d)) :: c)) & (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((d), (''fres''))), (p))) = ((Head ((fapply ((a_ca), (''sigma'')))))))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = ((Tail ((fapply ((a_ca), (''sigma''))))))))))))))))))"
assumes v'232: "(((fapply ((pc), (p))) = (''D3'')))"
assumes v'233: "((((a_xhash_primea :: c)) = ([(x) EXCEPT ![(p)] = (fapply ((Q), (fapply ((j), (p)))))])))"
assumes v'234: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((j), (p)))] = (BOT)])))"
assumes v'235: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'236: "((((a_ihash_primea :: c)) = (i)))"
assumes v'237: "((((a_lhash_primea :: c)) = (l)))"
assumes v'238: "((((a_vhash_primea :: c)) = (v)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> (subsetOf(([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) \<rightarrow> (A)]), %f. (\<forall> w \<in> (A) : (\<exists> q \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) : (((fapply ((f), (q))) = (w))))))))"
assumes v'241: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'242: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'250: "(((fapply ((Q), (fapply ((j), (p))))) = (BOT)))"
fixes m
assumes m_in : "(m \<in> ((isa_peri_peri_a (((Succ[0])), ((a_Lena ((seq))))))))"
fixes n
assumes n_in : "(n \<in> ((isa_peri_peri_a (((Succ[0])), ((a_Lena ((seq))))))))"
assumes v'256: "((less ((n), (m))))"
assumes v'257: "((greater ((fapply ((seq), (n))), (fapply ((seq), (m))))))"
assumes v'258: "(((fapply ((Q), (fapply ((seq), (m))))) \<noteq> (BOT)))"
fixes q
assumes q_in : "(q \<in> (ProcSet))"
assumes v'270: "(((q) = (p)))"
assumes v'275: "(((fapply ((j), (p))) \<noteq> ((arith_add ((fapply ((l), (p))), ((minus (((Succ[0]))))))))))"
assumes v'283: "(((m) \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A)))))))))"
shows "(((fapply ((seq), (m))) \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0])))))))))))))"(is "PROP ?ob'666")
proof -
ML_command {* writeln "*** TLAPS ENTER 666"; *}
show "PROP ?ob'666"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_84d996.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_84d996.znn.out
;; obligation #666
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'231" (TLA.cond (= (TLA.fapply Q (TLA.fapply j p))
BOT) (TLA.cond (= (TLA.fapply j p) (arith.add (TLA.fapply l p)
(arith.minus (TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea
(TLA.except pc p "D1")) (/\ (= a_jhash_primea j) (= a_Mhash_primea
M))) (/\ (= a_jhash_primea (TLA.except j p (arith.add (TLA.fapply j p)
(TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea pc) (= a_Mhash_primea
M)))) (/\ (= a_pchash_primea (TLA.except pc p "D4")) (= a_jhash_primea j)
(= a_Mhash_primea
(TLA.subsetOf CDomain ((d) (/\ (a_h022c5783954683bdcbcacced356fd6a d)
(TLA.bEx M ((a_ca) (/\ (= (TLA.fapply (TLA.fapply d "fres") p)
(Head (TLA.fapply a_ca "sigma"))) (TLA.bAll ProcSet ((q) (=> (-. (= q p))
(= (TLA.fapply (TLA.fapply d "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))) (= (TLA.fapply d "sigma")
(Tail (TLA.fapply a_ca "sigma"))))))))))))
$hyp "v'232" (= (TLA.fapply pc p) "D3")
$hyp "v'233" (= a_xhash_primea
(TLA.except x p (TLA.fapply Q (TLA.fapply j p))))
$hyp "v'234" (= a_Qhash_primea
(TLA.except Q (TLA.fapply j p) BOT))
$hyp "v'235" (= a_Xhash_primea X)
$hyp "v'236" (= a_ihash_primea i)
$hyp "v'237" (= a_lhash_primea l)
$hyp "v'238" (= a_vhash_primea
v)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (TLA.subsetOf (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) A) ((f) (TLA.bAll A ((w) (TLA.bEx (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) ((q) (= (TLA.fapply f q)
w))))))))
$hyp "v'241" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'242" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'250" (= (TLA.fapply Q (TLA.fapply j p))
BOT)
$hyp "m_in" (TLA.in m (arith.intrange (TLA.fapply TLA.Succ 0)
(a_Lena seq)))
$hyp "n_in" (TLA.in n (arith.intrange (TLA.fapply TLA.Succ 0)
(a_Lena seq)))
$hyp "v'256" (arith.lt n m)
$hyp "v'257" (arith.lt (TLA.fapply seq m)
(TLA.fapply seq n))
$hyp "v'258" (-. (= (TLA.fapply Q (TLA.fapply seq m))
BOT))
$hyp "q_in" (TLA.in q ProcSet)
$hyp "v'270" (= q p)
$hyp "v'275" (-. (= (TLA.fapply j p) (arith.add (TLA.fapply l p)
(arith.minus (TLA.fapply TLA.Succ 0)))))
$hyp "v'283" (TLA.in m (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$goal (TLA.in (TLA.fapply seq m) (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0)))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hl:"(A \\in SUBSET(isa'dotdot(1, (a_Xhash_primea +  -.(1)))))" (is "?z_hl")
 using A_in by blast
 have z_Hy:"(m \\in isa'dotdot(1, Cardinality(A)))" (is "?z_hy")
 using v'283 by blast
 have z_Hm:"(seq \\in subsetOf(FuncSet(isa'dotdot(1, Cardinality(A)), A), (\<lambda>f. bAll(A, (\<lambda>w. bEx(isa'dotdot(1, Cardinality(A)), (\<lambda>q. ((f[q])=w))))))))" (is "?z_hm")
 using seq_in by blast
 assume z_Hz:"(~((seq[m]) \\in isa'dotdot(1, (a_Xhash_primea +  -.(1)))))" (is "~?z_hbx")
 have z_Hbz: "(A \\subseteq isa'dotdot(1, (a_Xhash_primea +  -.(1))))" (is "?z_hbz")
 by (rule zenon_in_SUBSET_0 [of "A" "isa'dotdot(1, (a_Xhash_primea +  -.(1)))", OF z_Hl])
 have z_Hca_z_Hbz: "bAll(A, (\<lambda>x. (x \\in isa'dotdot(1, (a_Xhash_primea +  -.(1)))))) == ?z_hbz" (is "?z_hca == _")
 by (unfold subset_def)
 have z_Hca: "?z_hca"
 by (unfold z_Hca_z_Hbz, fact z_Hbz)
 have z_Hce_z_Hca: "(\\A x:((x \\in A)=>(x \\in isa'dotdot(1, (a_Xhash_primea +  -.(1)))))) == ?z_hca" (is "?z_hce == _")
 by (unfold bAll_def)
 have z_Hce: "?z_hce" (is "\\A x : ?z_hch(x)")
 by (unfold z_Hce_z_Hca, fact z_Hca)
 have z_Hci: "(seq \\in FuncSet(isa'dotdot(1, Cardinality(A)), A))" (is "?z_hci")
 by (rule zenon_in_subsetof_0 [of "seq" "FuncSet(isa'dotdot(1, Cardinality(A)), A)" "(\<lambda>f. bAll(A, (\<lambda>w. bEx(isa'dotdot(1, Cardinality(A)), (\<lambda>q. ((f[q])=w))))))", OF z_Hm])
 have z_Hcj: "?z_hch((seq[m]))" (is "?z_hck=>_")
 by (rule zenon_all_0 [of "?z_hch" "(seq[m])", OF z_Hce])
 show FALSE
 proof (rule zenon_imply [OF z_Hcj])
  assume z_Hcl:"(~?z_hck)"
  have z_Hcm: "(\\A zenon_Vxa:((zenon_Vxa \\in isa'dotdot(1, Cardinality(A)))=>((seq[zenon_Vxa]) \\in A)))" (is "\\A x : ?z_hcs(x)")
  by (rule zenon_in_funcset_2 [of "seq" "isa'dotdot(1, Cardinality(A))" "A", OF z_Hci])
  have z_Hct: "?z_hcs(m)"
  by (rule zenon_all_0 [of "?z_hcs" "m", OF z_Hcm])
  show FALSE
  proof (rule zenon_imply [OF z_Hct])
   assume z_Hcu:"(~?z_hy)"
   show FALSE
   by (rule notE [OF z_Hcu z_Hy])
  next
   assume z_Hck:"?z_hck"
   show FALSE
   by (rule notE [OF z_Hcl z_Hck])
  qed
 next
  assume z_Hbx:"?z_hbx"
  show FALSE
  by (rule notE [OF z_Hz z_Hbx])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 666"; *} qed
lemma ob'629:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'232: "(cond((((fapply ((Q), (fapply ((j), (p))))) = (BOT))), (cond((((fapply ((j), (p))) = ((arith_add ((fapply ((l), (p))), ((minus (((Succ[0])))))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & (((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (M))))), (((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((arith_add ((fapply ((j), (p))), ((Succ[0])))))]))) & (((((a_pchash_primea :: c)) = (pc))) & ((((a_Mhash_primea :: c)) = (M))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D4'')]))) & ((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %d. (((a_h022c5783954683bdcbcacced356fd6a ((d)) :: c)) & (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((d), (''fres''))), (p))) = ((Head ((fapply ((a_ca), (''sigma'')))))))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = ((Tail ((fapply ((a_ca), (''sigma''))))))))))))))))))"
assumes v'233: "(((fapply ((pc), (p))) = (''D3'')))"
assumes v'234: "((((a_xhash_primea :: c)) = ([(x) EXCEPT ![(p)] = (fapply ((Q), (fapply ((j), (p)))))])))"
assumes v'235: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((j), (p)))] = (BOT)])))"
assumes v'236: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'237: "((((a_ihash_primea :: c)) = (i)))"
assumes v'238: "((((a_lhash_primea :: c)) = (l)))"
assumes v'239: "((((a_vhash_primea :: c)) = (v)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'242: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'243: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'253: "((IsFiniteSet (((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0]))))))))))))))"
assumes v'254: "((\<And> S :: c. (((IsFiniteSet ((S)))) \<Longrightarrow> (\<And> T :: c. T \<in> ((SUBSET (S))) \<Longrightarrow> (((IsFiniteSet ((T)))) & ((leq (((Cardinality ((T)))), ((Cardinality ((S))))))) & ((((((Cardinality ((S)))) = ((Cardinality ((T)))))) \<Rightarrow> (((S) = (T))))))))))"
shows "((IsFiniteSet ((A))))"(is "PROP ?ob'629")
proof -
ML_command {* writeln "*** TLAPS ENTER 629"; *}
show "PROP ?ob'629"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_175052.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_175052.znn.out
;; obligation #629
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'232" (TLA.cond (= (TLA.fapply Q (TLA.fapply j p))
BOT) (TLA.cond (= (TLA.fapply j p) (arith.add (TLA.fapply l p)
(arith.minus (TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea
(TLA.except pc p "D1")) (/\ (= a_jhash_primea j) (= a_Mhash_primea
M))) (/\ (= a_jhash_primea (TLA.except j p (arith.add (TLA.fapply j p)
(TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea pc) (= a_Mhash_primea
M)))) (/\ (= a_pchash_primea (TLA.except pc p "D4")) (= a_jhash_primea j)
(= a_Mhash_primea
(TLA.subsetOf CDomain ((d) (/\ (a_h022c5783954683bdcbcacced356fd6a d)
(TLA.bEx M ((a_ca) (/\ (= (TLA.fapply (TLA.fapply d "fres") p)
(Head (TLA.fapply a_ca "sigma"))) (TLA.bAll ProcSet ((q) (=> (-. (= q p))
(= (TLA.fapply (TLA.fapply d "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))) (= (TLA.fapply d "sigma")
(Tail (TLA.fapply a_ca "sigma"))))))))))))
$hyp "v'233" (= (TLA.fapply pc p) "D3")
$hyp "v'234" (= a_xhash_primea
(TLA.except x p (TLA.fapply Q (TLA.fapply j p))))
$hyp "v'235" (= a_Qhash_primea
(TLA.except Q (TLA.fapply j p) BOT))
$hyp "v'236" (= a_Xhash_primea X)
$hyp "v'237" (= a_ihash_primea i)
$hyp "v'238" (= a_lhash_primea l)
$hyp "v'239" (= a_vhash_primea
v)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'242" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'243" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'253" (IsFiniteSet (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add X
(arith.minus (TLA.fapply TLA.Succ 0)))))
$hyp "v'254" (A. ((S) (=> (IsFiniteSet S) (TLA.bAll (TLA.SUBSET S) ((T) (/\ (IsFiniteSet T)
(arith.le (Cardinality T) (Cardinality S)) (=> (= (Cardinality S)
(Cardinality T)) (= S
T))))))))
$goal (IsFiniteSet A)
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hh:"(a_Xhash_primea=X)"
 using v'236 by blast
 have z_Hl:"(A \\in SUBSET(isa'dotdot(1, (a_Xhash_primea +  -.(1)))))" (is "?z_hl")
 using A_in by blast
 have z_Hq:"(\\A S:(IsFiniteSet(S)=>bAll(SUBSET(S), (\<lambda>T. (IsFiniteSet(T)&((Cardinality(T) <= Cardinality(S))&((Cardinality(S)=Cardinality(T))=>(S=T))))))))" (is "\\A x : ?z_hbq(x)")
 using v'254 by blast
 have z_Hp:"IsFiniteSet(isa'dotdot(1, (X +  -.(1))))" (is "?z_hp")
 using v'253 by blast
 assume z_Hr:"(~IsFiniteSet(A))" (is "~?z_hbt")
 have z_Hbu: "(A \\in SUBSET(isa'dotdot(1, (X +  -.(1)))))" (is "?z_hbu")
 by (rule subst [where P="(\<lambda>zenon_Vm. (A \\in SUBSET(isa'dotdot(1, (zenon_Vm +  -.(1))))))", OF z_Hh z_Hl])
 have z_Hcc: "?z_hbq(isa'dotdot(1, (X +  -.(1))))" (is "_=>?z_hcd")
 by (rule zenon_all_0 [of "?z_hbq" "isa'dotdot(1, (X +  -.(1)))", OF z_Hq])
 show FALSE
 proof (rule zenon_imply [OF z_Hcc])
  assume z_Hce:"(~?z_hp)"
  show FALSE
  by (rule notE [OF z_Hce z_Hp])
 next
  assume z_Hcd:"?z_hcd"
  have z_Hcf_z_Hcd: "(\\A x:((x \\in SUBSET(isa'dotdot(1, (X +  -.(1)))))=>(IsFiniteSet(x)&((Cardinality(x) <= Cardinality(isa'dotdot(1, (X +  -.(1)))))&((Cardinality(isa'dotdot(1, (X +  -.(1))))=Cardinality(x))=>(isa'dotdot(1, (X +  -.(1)))=x)))))) == ?z_hcd" (is "?z_hcf == _")
  by (unfold bAll_def)
  have z_Hcf: "?z_hcf" (is "\\A x : ?z_hcs(x)")
  by (unfold z_Hcf_z_Hcd, fact z_Hcd)
  have z_Hct: "?z_hcs(A)" (is "_=>?z_hcu")
  by (rule zenon_all_0 [of "?z_hcs" "A", OF z_Hcf])
  show FALSE
  proof (rule zenon_imply [OF z_Hct])
   assume z_Hcv:"(~?z_hbu)"
   show FALSE
   by (rule notE [OF z_Hcv z_Hbu])
  next
   assume z_Hcu:"?z_hcu" (is "_&?z_hcw")
   have z_Hbt: "?z_hbt"
   by (rule zenon_and_0 [OF z_Hcu])
   show FALSE
   by (rule notE [OF z_Hr z_Hbt])
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 629"; *} qed
lemma ob'716:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'232: "(cond((((fapply ((Q), (fapply ((j), (p))))) = (BOT))), (cond((((fapply ((j), (p))) = ((arith_add ((fapply ((l), (p))), ((minus (((Succ[0])))))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & (((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (M))))), (((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((arith_add ((fapply ((j), (p))), ((Succ[0])))))]))) & (((((a_pchash_primea :: c)) = (pc))) & ((((a_Mhash_primea :: c)) = (M))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D4'')]))) & ((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %d. (((a_h022c5783954683bdcbcacced356fd6a ((d)) :: c)) & (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((d), (''fres''))), (p))) = ((Head ((fapply ((a_ca), (''sigma'')))))))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = ((Tail ((fapply ((a_ca), (''sigma''))))))))))))))))))"
assumes v'233: "(((fapply ((pc), (p))) = (''D3'')))"
assumes v'234: "((((a_xhash_primea :: c)) = ([(x) EXCEPT ![(p)] = (fapply ((Q), (fapply ((j), (p)))))])))"
assumes v'235: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((j), (p)))] = (BOT)])))"
assumes v'236: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'237: "((((a_ihash_primea :: c)) = (i)))"
assumes v'238: "((((a_lhash_primea :: c)) = (l)))"
assumes v'239: "((((a_vhash_primea :: c)) = (v)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'242: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'243: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'252: "(((fapply ((Q), (fapply ((j), (p))))) \<noteq> (BOT)))"
assumes v'263: "((((Concat ((<<(fapply ((j), (p)))>>), (seq)))) = ([ k \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Succ[0])), ((a_Lena ((seq))))))))))  \<mapsto> (cond(((leq ((k), ((Succ[0]))))), (fapply ((<<(fapply ((j), (p)))>>), (k))), (fapply ((seq), ((arith_add ((k), ((minus (((a_Lena ((<<(fapply ((j), (p)))>>))))))))))))))])))"
assumes v'264: "((((a_Lena ((<<(fapply ((j), (p)))>>)))) = ((Succ[0]))))"
shows "((((Concat ((<<(fapply ((j), (p)))>>), (seq)))) = ([ k \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Succ[0])), ((a_Lena ((seq))))))))))  \<mapsto> (cond(((leq ((k), ((Succ[0]))))), (fapply ((<<(fapply ((j), (p)))>>), (k))), (fapply ((seq), ((arith_add ((k), ((minus (((Succ[0]))))))))))))])))"(is "PROP ?ob'716")
proof -
ML_command {* writeln "*** TLAPS ENTER 716"; *}
show "PROP ?ob'716"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_bc35ac.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_bc35ac.znn.out
;; obligation #716
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'232" (TLA.cond (= (TLA.fapply Q (TLA.fapply j p))
BOT) (TLA.cond (= (TLA.fapply j p) (arith.add (TLA.fapply l p)
(arith.minus (TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea
(TLA.except pc p "D1")) (/\ (= a_jhash_primea j) (= a_Mhash_primea
M))) (/\ (= a_jhash_primea (TLA.except j p (arith.add (TLA.fapply j p)
(TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea pc) (= a_Mhash_primea
M)))) (/\ (= a_pchash_primea (TLA.except pc p "D4")) (= a_jhash_primea j)
(= a_Mhash_primea
(TLA.subsetOf CDomain ((d) (/\ (a_h022c5783954683bdcbcacced356fd6a d)
(TLA.bEx M ((a_ca) (/\ (= (TLA.fapply (TLA.fapply d "fres") p)
(Head (TLA.fapply a_ca "sigma"))) (TLA.bAll ProcSet ((q) (=> (-. (= q p))
(= (TLA.fapply (TLA.fapply d "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))) (= (TLA.fapply d "sigma")
(Tail (TLA.fapply a_ca "sigma"))))))))))))
$hyp "v'233" (= (TLA.fapply pc p) "D3")
$hyp "v'234" (= a_xhash_primea
(TLA.except x p (TLA.fapply Q (TLA.fapply j p))))
$hyp "v'235" (= a_Qhash_primea
(TLA.except Q (TLA.fapply j p) BOT))
$hyp "v'236" (= a_Xhash_primea X)
$hyp "v'237" (= a_ihash_primea i)
$hyp "v'238" (= a_lhash_primea l)
$hyp "v'239" (= a_vhash_primea
v)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'242" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'243" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'252" (-. (= (TLA.fapply Q (TLA.fapply j p))
BOT))
$hyp "v'263" (= (Concat (TLA.tuple (TLA.fapply j p)) seq)
(TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (TLA.fapply TLA.Succ 0) (a_Lena seq))) ((k) (TLA.cond (arith.le k
(TLA.fapply TLA.Succ 0)) (TLA.fapply (TLA.tuple (TLA.fapply j p)) k) (TLA.fapply seq (arith.add k
(arith.minus (a_Lena (TLA.tuple (TLA.fapply j p))))))))))
$hyp "v'264" (= (a_Lena (TLA.tuple (TLA.fapply j p)))
(TLA.fapply TLA.Succ 0))
$goal (= (Concat (TLA.tuple (TLA.fapply j p)) seq)
(TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (TLA.fapply TLA.Succ 0) (a_Lena seq))) ((k) (TLA.cond (arith.le k
(TLA.fapply TLA.Succ 0)) (TLA.fapply (TLA.tuple (TLA.fapply j p)) k) (TLA.fapply seq (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hq:"(Concat(<<(j[p])>>, seq)=Fcn(isa'dotdot(1, (1 + a_Lena(seq))), (\<lambda>k. cond((k <= 1), (<<(j[p])>>[k]), (seq[(k +  -.(a_Lena(<<(j[p])>>)))])))))" (is "?z_ht=?z_hz")
 using v'263 by blast
 have z_Hr:"(a_Lena(<<(j[p])>>)=1)" (is "?z_hbm=?z_hbb")
 using v'264 by blast
 have zenon_L1_: "( -.(?z_hbm)~= -.(?z_hbb)) ==> (?z_hbm=?z_hbb) ==> FALSE" (is "?z_hbn ==> ?z_hr ==> FALSE")
 proof -
  assume z_Hbn:"?z_hbn" (is "?z_hbl~=?z_hbo")
  assume z_Hr:"?z_hr"
  show FALSE
  proof (rule zenon_noteq [of "?z_hbo"])
   have z_Hbp: "(?z_hbo~=?z_hbo)"
   by (rule subst [where P="(\<lambda>zenon_Vyj. ( -.(zenon_Vyj)~=?z_hbo))", OF z_Hr], fact z_Hbn)
   thus "(?z_hbo~=?z_hbo)" .
  qed
 qed
 assume z_Hs:"(?z_ht~=Fcn(isa'dotdot(?z_hbb, (?z_hbb + a_Lena(seq))), (\<lambda>k. cond((k <= ?z_hbb), (<<(j[p])>>[k]), (seq[(k +  -.(?z_hbb))])))))" (is "_~=?z_hbu")
 show FALSE
 proof (rule notE [OF z_Hs])
  have z_Hbz: "(?z_hz=?z_hbu)"
  proof (rule zenon_nnpp [of "(?z_hz=?z_hbu)"])
   assume z_Hca:"(?z_hz~=?z_hbu)"
   have z_Hcb: "(((isAFcn(?z_ht)<=>isAFcn(?z_hz))&(DOMAIN(?z_ht)=DOMAIN(?z_hz)))&(\\A zenon_Vj:((?z_ht[zenon_Vj])=(?z_hz[zenon_Vj]))))" (is "?z_hcc&?z_hcj")
   by (rule zenon_funequal_0 [of "?z_ht" "?z_hz", OF z_Hq])
   have z_Hcc: "?z_hcc" (is "?z_hcd&?z_hcg")
   by (rule zenon_and_0 [OF z_Hcb])
   have z_Hcd: "?z_hcd" (is "?z_hce<=>?z_hcf")
   by (rule zenon_and_0 [OF z_Hcc])
   show FALSE
   proof (rule zenon_equiv [OF z_Hcd])
    assume z_Hco:"(~?z_hce)"
    assume z_Hcp:"(~?z_hcf)"
    show FALSE
    by (rule zenon_notisafcn_fcn [of "isa'dotdot(?z_hbb, (?z_hbb + a_Lena(seq)))" "(\<lambda>k. cond((k <= ?z_hbb), (<<(j[p])>>[k]), (seq[(k +  -.(?z_hbm))])))", OF z_Hcp])
   next
    assume z_Hce:"?z_hce"
    assume z_Hcf:"?z_hcf"
    have z_Hcq: "(~(((?z_hcf&isAFcn(?z_hbu))&(DOMAIN(?z_hz)=DOMAIN(?z_hbu)))&(\\A zenon_Vjb:((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb]))))))" (is "~(?z_hcs&?z_hcx)")
    by (rule zenon_notfunequal_0 [of "?z_hz" "?z_hbu", OF z_Hca])
    show FALSE
    proof (rule zenon_notand [OF z_Hcq])
     assume z_Hde:"(~?z_hcs)" (is "~(?z_hct&?z_hcv)")
     show FALSE
     proof (rule zenon_notand [OF z_Hde])
      assume z_Hdf:"(~?z_hct)" (is "~(_&?z_hcu)")
      show FALSE
      proof (rule zenon_notand [OF z_Hdf])
       assume z_Hcp:"(~?z_hcf)"
       show FALSE
       by (rule notE [OF z_Hcp z_Hcf])
      next
       assume z_Hdg:"(~?z_hcu)"
       show FALSE
       by (rule zenon_notisafcn_fcn [of "isa'dotdot(?z_hbb, (?z_hbb + a_Lena(seq)))" "(\<lambda>k. cond((k <= ?z_hbb), (<<(j[p])>>[k]), (seq[(k +  -.(?z_hbb))])))", OF z_Hdg])
      qed
     next
      assume z_Hdh:"(DOMAIN(?z_hz)~=DOMAIN(?z_hbu))" (is "?z_hci~=?z_hcw")
      have z_Hdi: "(isa'dotdot(?z_hbb, (?z_hbb + a_Lena(seq)))~=?z_hcw)" (is "?z_hba~=_")
      by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Voj. (zenon_Voj~=?z_hcw))" "?z_hba" "(\<lambda>k. cond((k <= ?z_hbb), (<<(j[p])>>[k]), (seq[(k +  -.(?z_hbm))])))", OF z_Hdh])
      have z_Hdm: "(?z_hba~=?z_hba)"
      by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vji. (?z_hba~=zenon_Vji))" "?z_hba" "(\<lambda>k. cond((k <= ?z_hbb), (<<(j[p])>>[k]), (seq[(k +  -.(?z_hbb))])))", OF z_Hdi])
      show FALSE
      by (rule zenon_noteq [OF z_Hdm])
     qed
    next
     assume z_Hdq:"(~?z_hcx)" (is "~(\\A x : ?z_hdr(x))")
     have z_Hds: "(\\E zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb])))))" (is "\\E x : ?z_hdu(x)")
     by (rule zenon_notallex_0 [of "?z_hdr", OF z_Hdq])
     have z_Hdv: "?z_hdu((CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb]))))))" (is "~(?z_hdx=>?z_hdy)")
     by (rule zenon_ex_choose_0 [of "?z_hdu", OF z_Hds])
     have z_Hdx: "?z_hdx"
     by (rule zenon_notimply_0 [OF z_Hdv])
     have z_Hdz: "((?z_hz[(CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb])))))])~=(?z_hbu[(CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb])))))]))" (is "?z_hea~=?z_heb")
     by (rule zenon_notimply_1 [OF z_Hdv])
     have z_Hec: "((CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb]))))) \\in isa'dotdot(?z_hbb, (?z_hbb + a_Lena(seq))))" (is "?z_hec")
     by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vti. ((CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb]))))) \\in zenon_Vti))" "isa'dotdot(?z_hbb, (?z_hbb + a_Lena(seq)))" "(\<lambda>k. cond((k <= ?z_hbb), (<<(j[p])>>[k]), (seq[(k +  -.(?z_hbb))])))", OF z_Hdx])
     show FALSE
     proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vri. (zenon_Vri~=?z_heb))" "isa'dotdot(?z_hbb, (?z_hbb + a_Lena(seq)))" "(\<lambda>k. cond((k <= ?z_hbb), (<<(j[p])>>[k]), (seq[(k +  -.(?z_hbm))])))" "(CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb])))))", OF z_Hdz])
      assume z_Hej:"(~?z_hec)"
      show FALSE
      by (rule notE [OF z_Hej z_Hec])
     next
      assume z_Hek:"(cond(((CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb]))))) <= ?z_hbb), (<<(j[p])>>[(CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb])))))]), (seq[((CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb]))))) +  -.(?z_hbm))]))~=?z_heb)" (is "?z_hel~=_")
      show FALSE
      proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vri. (zenon_Vri~=?z_heb))" "((CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb]))))) <= ?z_hbb)" "(<<(j[p])>>[(CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb])))))])" "(seq[((CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb]))))) +  -.(?z_hbm))])", OF z_Hek])
       assume z_Hem:"((CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb]))))) <= ?z_hbb)" (is "?z_hem")
       assume z_Heq:"((<<(j[p])>>[(CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb])))))])~=?z_heb)" (is "?z_hen~=_")
       show FALSE
       proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vfj. (?z_hen~=zenon_Vfj))" "isa'dotdot(?z_hbb, (?z_hbb + a_Lena(seq)))" "(\<lambda>k. cond((k <= ?z_hbb), (<<(j[p])>>[k]), (seq[(k +  -.(?z_hbb))])))" "(CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb])))))", OF z_Heq])
        assume z_Hej:"(~?z_hec)"
        show FALSE
        by (rule notE [OF z_Hej z_Hec])
       next
        assume z_Heu:"(?z_hen~=cond(?z_hem, ?z_hen, (seq[((CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb]))))) +  -.(?z_hbb))])))" (is "_~=?z_hev")
        show FALSE
        proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vfj. (?z_hen~=zenon_Vfj))" "?z_hem" "?z_hen" "(seq[((CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb]))))) +  -.(?z_hbb))])", OF z_Heu])
         assume z_Hem:"?z_hem"
         assume z_Hey:"(?z_hen~=?z_hen)"
         show FALSE
         by (rule zenon_noteq [OF z_Hey])
        next
         assume z_Hez:"(~?z_hem)"
         assume z_Hfa:"(?z_hen~=(seq[((CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb]))))) +  -.(?z_hbb))]))" (is "_~=?z_hew")
         show FALSE
         by (rule notE [OF z_Hez z_Hem])
        qed
       qed
      next
       assume z_Hez:"(~((CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb]))))) <= ?z_hbb))" (is "~?z_hem")
       assume z_Hfb:"((seq[((CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb]))))) +  -.(?z_hbm))])~=?z_heb)" (is "?z_heo~=_")
       show FALSE
       proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vxi. (?z_heo~=zenon_Vxi))" "isa'dotdot(?z_hbb, (?z_hbb + a_Lena(seq)))" "(\<lambda>k. cond((k <= ?z_hbb), (<<(j[p])>>[k]), (seq[(k +  -.(?z_hbb))])))" "(CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb])))))", OF z_Hfb])
        assume z_Hej:"(~?z_hec)"
        show FALSE
        by (rule notE [OF z_Hej z_Hec])
       next
        assume z_Hff:"(?z_heo~=cond(?z_hem, (<<(j[p])>>[(CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb])))))]), (seq[((CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb]))))) +  -.(?z_hbb))])))" (is "_~=?z_hev")
        show FALSE
        proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vxi. (?z_heo~=zenon_Vxi))" "?z_hem" "(<<(j[p])>>[(CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb])))))])" "(seq[((CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb]))))) +  -.(?z_hbb))])", OF z_Hff])
         assume z_Hem:"?z_hem"
         assume z_Hfg:"(?z_heo~=(<<(j[p])>>[(CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb])))))]))" (is "_~=?z_hen")
         show FALSE
         by (rule notE [OF z_Hez z_Hem])
        next
         assume z_Hez:"(~?z_hem)"
         assume z_Hfh:"(?z_heo~=(seq[((CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb]))))) +  -.(?z_hbb))]))" (is "_~=?z_hew")
         show FALSE
         proof (rule zenon_noteq [of "?z_hew"])
          have z_Hfi: "(((CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb]))))) +  -.(?z_hbm))=((CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb]))))) +  -.(?z_hbb)))" (is "?z_hep=?z_hex")
          proof (rule zenon_nnpp [of "(?z_hep=?z_hex)"])
           assume z_Hfj:"(?z_hep~=?z_hex)"
           show FALSE
           proof (rule zenon_noteq [of "?z_hex"])
            have z_Hfk: "( -.(?z_hbm)= -.(?z_hbb))" (is "?z_hbl=?z_hbo")
            proof (rule zenon_nnpp [of "(?z_hbl=?z_hbo)"])
             assume z_Hbn:"(?z_hbl~=?z_hbo)"
             show FALSE
             by (rule zenon_L1_ [OF z_Hbn z_Hr])
            qed
            have z_Hfl: "(?z_hex~=?z_hex)"
            by (rule subst [where P="(\<lambda>zenon_Vzj. (((CHOOSE zenon_Vjb:(~((zenon_Vjb \\in DOMAIN(?z_hbu))=>((?z_hz[zenon_Vjb])=(?z_hbu[zenon_Vjb]))))) + zenon_Vzj)~=?z_hex))", OF z_Hfk], fact z_Hfj)
            thus "(?z_hex~=?z_hex)" .
           qed
          qed
          have z_Hfq: "(?z_hew~=?z_hew)"
          by (rule subst [where P="(\<lambda>zenon_Vak. ((seq[zenon_Vak])~=?z_hew))", OF z_Hfi], fact z_Hfh)
          thus "(?z_hew~=?z_hew)" .
         qed
        qed
       qed
      qed
     qed
    qed
   qed
  qed
  have z_Hfv: "(?z_ht=?z_hbu)"
  by (rule subst [where P="(\<lambda>zenon_Vbk. (?z_ht=zenon_Vbk))", OF z_Hbz], fact z_Hq)
  thus "(?z_ht=?z_hbu)" .
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 716"; *} qed
lemma ob'705:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'232: "(cond((((fapply ((Q), (fapply ((j), (p))))) = (BOT))), (cond((((fapply ((j), (p))) = ((arith_add ((fapply ((l), (p))), ((minus (((Succ[0])))))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & (((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (M))))), (((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((arith_add ((fapply ((j), (p))), ((Succ[0])))))]))) & (((((a_pchash_primea :: c)) = (pc))) & ((((a_Mhash_primea :: c)) = (M))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D4'')]))) & ((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %d. (((a_h022c5783954683bdcbcacced356fd6a ((d)) :: c)) & (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((d), (''fres''))), (p))) = ((Head ((fapply ((a_ca), (''sigma'')))))))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = ((Tail ((fapply ((a_ca), (''sigma''))))))))))))))))))"
assumes v'233: "(((fapply ((pc), (p))) = (''D3'')))"
assumes v'234: "((((a_xhash_primea :: c)) = ([(x) EXCEPT ![(p)] = (fapply ((Q), (fapply ((j), (p)))))])))"
assumes v'235: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((j), (p)))] = (BOT)])))"
assumes v'236: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'237: "((((a_ihash_primea :: c)) = (i)))"
assumes v'238: "((((a_lhash_primea :: c)) = (l)))"
assumes v'239: "((((a_vhash_primea :: c)) = (v)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'242: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'243: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'252: "(((fapply ((Q), (fapply ((j), (p))))) \<noteq> (BOT)))"
assumes v'258: "((\<And> S :: c. (((IsFiniteSet ((S)))) \<Longrightarrow> (\<And> T :: c. T \<in> ((SUBSET (S))) \<Longrightarrow> (((IsFiniteSet ((T)))) & ((leq (((Cardinality ((T)))), ((Cardinality ((S))))))) & ((((((Cardinality ((S)))) = ((Cardinality ((T)))))) \<Rightarrow> (((S) = (T))))))))))"
assumes v'259: "((IsFiniteSet (((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
shows "((IsFiniteSet ((A))))"(is "PROP ?ob'705")
proof -
ML_command {* writeln "*** TLAPS ENTER 705"; *}
show "PROP ?ob'705"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_ad5498.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_ad5498.znn.out
;; obligation #705
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'232" (TLA.cond (= (TLA.fapply Q (TLA.fapply j p))
BOT) (TLA.cond (= (TLA.fapply j p) (arith.add (TLA.fapply l p)
(arith.minus (TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea
(TLA.except pc p "D1")) (/\ (= a_jhash_primea j) (= a_Mhash_primea
M))) (/\ (= a_jhash_primea (TLA.except j p (arith.add (TLA.fapply j p)
(TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea pc) (= a_Mhash_primea
M)))) (/\ (= a_pchash_primea (TLA.except pc p "D4")) (= a_jhash_primea j)
(= a_Mhash_primea
(TLA.subsetOf CDomain ((d) (/\ (a_h022c5783954683bdcbcacced356fd6a d)
(TLA.bEx M ((a_ca) (/\ (= (TLA.fapply (TLA.fapply d "fres") p)
(Head (TLA.fapply a_ca "sigma"))) (TLA.bAll ProcSet ((q) (=> (-. (= q p))
(= (TLA.fapply (TLA.fapply d "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))) (= (TLA.fapply d "sigma")
(Tail (TLA.fapply a_ca "sigma"))))))))))))
$hyp "v'233" (= (TLA.fapply pc p) "D3")
$hyp "v'234" (= a_xhash_primea
(TLA.except x p (TLA.fapply Q (TLA.fapply j p))))
$hyp "v'235" (= a_Qhash_primea
(TLA.except Q (TLA.fapply j p) BOT))
$hyp "v'236" (= a_Xhash_primea X)
$hyp "v'237" (= a_ihash_primea i)
$hyp "v'238" (= a_lhash_primea l)
$hyp "v'239" (= a_vhash_primea
v)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'242" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'243" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'252" (-. (= (TLA.fapply Q (TLA.fapply j p))
BOT))
$hyp "v'258" (A. ((S) (=> (IsFiniteSet S) (TLA.bAll (TLA.SUBSET S) ((T) (/\ (IsFiniteSet T)
(arith.le (Cardinality T) (Cardinality S)) (=> (= (Cardinality S)
(Cardinality T)) (= S
T))))))))
$hyp "v'259" (IsFiniteSet (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0)))))
$goal (IsFiniteSet A)
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hh:"(a_Xhash_primea=X)"
 using v'236 by blast
 have z_Hl:"(A \\in SUBSET(isa'dotdot(1, (a_Xhash_primea +  -.(1)))))" (is "?z_hl")
 using A_in by blast
 have z_Hr:"IsFiniteSet(isa'dotdot(1, (a_Xhash_primea +  -.(1))))" (is "?z_hr")
 using v'259 by blast
 have z_Hq:"(\\A S:(IsFiniteSet(S)=>bAll(SUBSET(S), (\<lambda>T. (IsFiniteSet(T)&((Cardinality(T) <= Cardinality(S))&((Cardinality(S)=Cardinality(T))=>(S=T))))))))" (is "\\A x : ?z_hbr(x)")
 using v'258 by blast
 assume z_Hs:"(~IsFiniteSet(A))" (is "~?z_hbs")
 have z_Hbt: "(A \\in SUBSET(isa'dotdot(1, (X +  -.(1)))))" (is "?z_hbt")
 by (rule subst [where P="(\<lambda>zenon_Vn. (A \\in SUBSET(isa'dotdot(1, (zenon_Vn +  -.(1))))))", OF z_Hh z_Hl])
 have z_Hcd: "IsFiniteSet(isa'dotdot(1, (X +  -.(1))))" (is "?z_hcd")
 by (rule subst [where P="(\<lambda>zenon_Vg. IsFiniteSet(isa'dotdot(1, (zenon_Vg +  -.(1)))))", OF z_Hh z_Hr])
 have z_Hcj: "?z_hbr(isa'dotdot(1, (X +  -.(1))))" (is "_=>?z_hck")
 by (rule zenon_all_0 [of "?z_hbr" "isa'dotdot(1, (X +  -.(1)))", OF z_Hq])
 show FALSE
 proof (rule zenon_imply [OF z_Hcj])
  assume z_Hcl:"(~?z_hcd)"
  show FALSE
  by (rule notE [OF z_Hcl z_Hcd])
 next
  assume z_Hck:"?z_hck"
  have z_Hcm_z_Hck: "(\\A x:((x \\in SUBSET(isa'dotdot(1, (X +  -.(1)))))=>(IsFiniteSet(x)&((Cardinality(x) <= Cardinality(isa'dotdot(1, (X +  -.(1)))))&((Cardinality(isa'dotdot(1, (X +  -.(1))))=Cardinality(x))=>(isa'dotdot(1, (X +  -.(1)))=x)))))) == ?z_hck" (is "?z_hcm == _")
  by (unfold bAll_def)
  have z_Hcm: "?z_hcm" (is "\\A x : ?z_hcz(x)")
  by (unfold z_Hcm_z_Hck, fact z_Hck)
  have z_Hda: "?z_hcz(A)" (is "_=>?z_hdb")
  by (rule zenon_all_0 [of "?z_hcz" "A", OF z_Hcm])
  show FALSE
  proof (rule zenon_imply [OF z_Hda])
   assume z_Hdc:"(~?z_hbt)"
   show FALSE
   by (rule notE [OF z_Hdc z_Hbt])
  next
   assume z_Hdb:"?z_hdb" (is "_&?z_hdd")
   have z_Hbs: "?z_hbs"
   by (rule zenon_and_0 [OF z_Hdb])
   show FALSE
   by (rule notE [OF z_Hs z_Hbs])
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 705"; *} qed
lemma ob'699:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'231: "(cond((((fapply ((Q), (fapply ((j), (p))))) = (BOT))), (cond((((fapply ((j), (p))) = ((arith_add ((fapply ((l), (p))), ((minus (((Succ[0])))))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & (((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (M))))), (((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((arith_add ((fapply ((j), (p))), ((Succ[0])))))]))) & (((((a_pchash_primea :: c)) = (pc))) & ((((a_Mhash_primea :: c)) = (M))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D4'')]))) & ((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %d. (((a_h022c5783954683bdcbcacced356fd6a ((d)) :: c)) & (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((d), (''fres''))), (p))) = ((Head ((fapply ((a_ca), (''sigma'')))))))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = ((Tail ((fapply ((a_ca), (''sigma''))))))))))))))))))"
assumes v'232: "(((fapply ((pc), (p))) = (''D3'')))"
assumes v'233: "((((a_xhash_primea :: c)) = ([(x) EXCEPT ![(p)] = (fapply ((Q), (fapply ((j), (p)))))])))"
assumes v'234: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((j), (p)))] = (BOT)])))"
assumes v'235: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'236: "((((a_ihash_primea :: c)) = (i)))"
assumes v'237: "((((a_lhash_primea :: c)) = (l)))"
assumes v'238: "((((a_vhash_primea :: c)) = (v)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'241: "(\<forall> k \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))) : ((((((fapply (((a_Qhash_primea :: c)), (k))) \<noteq> (BOT))) \<Rightarrow> (((k) \<in> (A))))) & (((((((k) \<in> (A))) \<and> (((fapply (((a_Qhash_primea :: c)), (k))) = (BOT))))) \<Rightarrow> (\<exists> q \<in> (ProcSet) : (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (k))))))))))"
assumes v'242: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'251: "(((fapply ((Q), (fapply ((j), (p))))) \<noteq> (BOT)))"
assumes v'258: "(((fapply (((a_Qhash_primea :: c)), (fapply ((j), (p))))) = (BOT)))"
shows "(((((fapply ((j), (p))) \<in> (A))) \<Rightarrow> (\<exists> r \<in> (ProcSet) : (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((j), (p))))))))))"(is "PROP ?ob'699")
proof -
ML_command {* writeln "*** TLAPS ENTER 699"; *}
show "PROP ?ob'699"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_64a0ec.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_64a0ec.znn.out
;; obligation #699
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'231" (TLA.cond (= (TLA.fapply Q (TLA.fapply j p))
BOT) (TLA.cond (= (TLA.fapply j p) (arith.add (TLA.fapply l p)
(arith.minus (TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea
(TLA.except pc p "D1")) (/\ (= a_jhash_primea j) (= a_Mhash_primea
M))) (/\ (= a_jhash_primea (TLA.except j p (arith.add (TLA.fapply j p)
(TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea pc) (= a_Mhash_primea
M)))) (/\ (= a_pchash_primea (TLA.except pc p "D4")) (= a_jhash_primea j)
(= a_Mhash_primea
(TLA.subsetOf CDomain ((d) (/\ (a_h022c5783954683bdcbcacced356fd6a d)
(TLA.bEx M ((a_ca) (/\ (= (TLA.fapply (TLA.fapply d "fres") p)
(Head (TLA.fapply a_ca "sigma"))) (TLA.bAll ProcSet ((q) (=> (-. (= q p))
(= (TLA.fapply (TLA.fapply d "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))) (= (TLA.fapply d "sigma")
(Tail (TLA.fapply a_ca "sigma"))))))))))))
$hyp "v'232" (= (TLA.fapply pc p) "D3")
$hyp "v'233" (= a_xhash_primea
(TLA.except x p (TLA.fapply Q (TLA.fapply j p))))
$hyp "v'234" (= a_Qhash_primea
(TLA.except Q (TLA.fapply j p) BOT))
$hyp "v'235" (= a_Xhash_primea X)
$hyp "v'236" (= a_ihash_primea i)
$hyp "v'237" (= a_lhash_primea l)
$hyp "v'238" (= a_vhash_primea
v)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'241" (TLA.bAll (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0)))) ((k) (/\ (=> (-. (= (TLA.fapply a_Qhash_primea k)
BOT)) (TLA.in k A)) (=> (/\ (TLA.in k A) (= (TLA.fapply a_Qhash_primea k)
BOT)) (TLA.bEx ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q) "E2")
(= (TLA.fapply a_ihash_primea q)
k))))))))
$hyp "v'242" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'251" (-. (= (TLA.fapply Q (TLA.fapply j p))
BOT))
$hyp "v'258" (= (TLA.fapply a_Qhash_primea (TLA.fapply j p))
BOT)
$goal (=> (TLA.in (TLA.fapply j p) A)
(TLA.bEx ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r) "E2")
(= (TLA.fapply a_ihash_primea r)
(TLA.fapply j p))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hl:"(A \\in SUBSET(isa'dotdot(1, (a_Xhash_primea +  -.(1)))))" (is "?z_hl")
 using A_in by blast
 have z_Hq:"((a_Qhash_primea[(j[p])])=BOT)" (is "?z_hz=_")
 using v'258 by blast
 have z_Hn:"bAll(isa'dotdot(1, (a_Xhash_primea +  -.(1))), (\<lambda>k. ((((a_Qhash_primea[k])~=BOT)=>(k \\in A))&(((k \\in A)&((a_Qhash_primea[k])=BOT))=>bEx(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=k))))))))" (is "?z_hn")
 using v'241 by blast
 assume z_Hr:"(~(((j[p]) \\in A)=>bEx(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(j[p])))))))" (is "~(?z_hcc=>?z_hcd)")
 have z_Hcl: "(A \\subseteq isa'dotdot(1, (a_Xhash_primea +  -.(1))))" (is "?z_hcl")
 by (rule zenon_in_SUBSET_0 [of "A" "isa'dotdot(1, (a_Xhash_primea +  -.(1)))", OF z_Hl])
 have z_Hcm_z_Hcl: "bAll(A, (\<lambda>x. (x \\in isa'dotdot(1, (a_Xhash_primea +  -.(1)))))) == ?z_hcl" (is "?z_hcm == _")
 by (unfold subset_def)
 have z_Hcm: "?z_hcm"
 by (unfold z_Hcm_z_Hcl, fact z_Hcl)
 have z_Hcq_z_Hcm: "(\\A x:((x \\in A)=>(x \\in isa'dotdot(1, (a_Xhash_primea +  -.(1)))))) == ?z_hcm" (is "?z_hcq == _")
 by (unfold bAll_def)
 have z_Hcq: "?z_hcq" (is "\\A x : ?z_hct(x)")
 by (unfold z_Hcq_z_Hcm, fact z_Hcm)
 have z_Hcu_z_Hn: "(\\A x:((x \\in isa'dotdot(1, (a_Xhash_primea +  -.(1))))=>((((a_Qhash_primea[x])~=BOT)=>(x \\in A))&(((x \\in A)&((a_Qhash_primea[x])=BOT))=>bEx(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=x)))))))) == ?z_hn" (is "?z_hcu == _")
 by (unfold bAll_def)
 have z_Hcu: "?z_hcu" (is "\\A x : ?z_hdh(x)")
 by (unfold z_Hcu_z_Hn, fact z_Hn)
 have z_Hcc: "?z_hcc"
 by (rule zenon_notimply_0 [OF z_Hr])
 have z_Hdi: "(~?z_hcd)"
 by (rule zenon_notimply_1 [OF z_Hr])
 have z_Hdj: "?z_hdh((j[p]))" (is "?z_hdk=>?z_hdl")
 by (rule zenon_all_0 [of "?z_hdh" "(j[p])", OF z_Hcu])
 show FALSE
 proof (rule zenon_imply [OF z_Hdj])
  assume z_Hdm:"(~?z_hdk)"
  have z_Hdn: "?z_hct((j[p]))"
  by (rule zenon_all_0 [of "?z_hct" "(j[p])", OF z_Hcq])
  show FALSE
  proof (rule zenon_imply [OF z_Hdn])
   assume z_Hdo:"(~?z_hcc)"
   show FALSE
   by (rule notE [OF z_Hdo z_Hcc])
  next
   assume z_Hdk:"?z_hdk"
   show FALSE
   by (rule notE [OF z_Hdm z_Hdk])
  qed
 next
  assume z_Hdl:"?z_hdl" (is "?z_hdp&?z_hdq")
  have z_Hdq: "?z_hdq" (is "?z_hdr=>_")
  by (rule zenon_and_1 [OF z_Hdl])
  show FALSE
  proof (rule zenon_imply [OF z_Hdq])
   assume z_Hds:"(~?z_hdr)" (is "~(_&?z_hq)")
   show FALSE
   proof (rule zenon_notand [OF z_Hds])
    assume z_Hdo:"(~?z_hcc)"
    show FALSE
    by (rule notE [OF z_Hdo z_Hcc])
   next
    assume z_Hdt:"(?z_hz~=BOT)"
    show FALSE
    by (rule notE [OF z_Hdt z_Hq])
   qed
  next
   assume z_Hcd:"?z_hcd"
   show FALSE
   by (rule notE [OF z_Hdi z_Hcd])
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 699"; *} qed
lemma ob'682:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'232: "(cond((((fapply ((Q), (fapply ((j), (p))))) = (BOT))), (cond((((fapply ((j), (p))) = ((arith_add ((fapply ((l), (p))), ((minus (((Succ[0])))))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & (((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (M))))), (((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((arith_add ((fapply ((j), (p))), ((Succ[0])))))]))) & (((((a_pchash_primea :: c)) = (pc))) & ((((a_Mhash_primea :: c)) = (M))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D4'')]))) & ((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %d. (((a_h022c5783954683bdcbcacced356fd6a ((d)) :: c)) & (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((d), (''fres''))), (p))) = ((Head ((fapply ((a_ca), (''sigma'')))))))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = ((Tail ((fapply ((a_ca), (''sigma''))))))))))))))))))"
assumes v'233: "(((fapply ((pc), (p))) = (''D3'')))"
assumes v'234: "((((a_xhash_primea :: c)) = ([(x) EXCEPT ![(p)] = (fapply ((Q), (fapply ((j), (p)))))])))"
assumes v'235: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((j), (p)))] = (BOT)])))"
assumes v'236: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'237: "((((a_ihash_primea :: c)) = (i)))"
assumes v'238: "((((a_lhash_primea :: c)) = (l)))"
assumes v'239: "((((a_vhash_primea :: c)) = (v)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'242: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'243: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'251: "(((fapply ((Q), (fapply ((j), (p))))) = (BOT)))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
assumes v'263: "((\<And> k :: c. k \<in> ((DOMAIN (seq))) \<Longrightarrow> (((fapply (([ k_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k_1)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k_1)))))))))))))]), (k))) = (fapply (([ k_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k_1))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k_1)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k_1)))))))))))))]), (k)))))))"
shows "((([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k)))))))))))))]) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k)))))))))))))])))"(is "PROP ?ob'682")
proof -
ML_command {* writeln "*** TLAPS ENTER 682"; *}
show "PROP ?ob'682"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_34d383.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_34d383.znn.out
;; obligation #682
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'232" (TLA.cond (= (TLA.fapply Q (TLA.fapply j p))
BOT) (TLA.cond (= (TLA.fapply j p) (arith.add (TLA.fapply l p)
(arith.minus (TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea
(TLA.except pc p "D1")) (/\ (= a_jhash_primea j) (= a_Mhash_primea
M))) (/\ (= a_jhash_primea (TLA.except j p (arith.add (TLA.fapply j p)
(TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea pc) (= a_Mhash_primea
M)))) (/\ (= a_pchash_primea (TLA.except pc p "D4")) (= a_jhash_primea j)
(= a_Mhash_primea
(TLA.subsetOf CDomain ((d) (/\ (a_h022c5783954683bdcbcacced356fd6a d)
(TLA.bEx M ((a_ca) (/\ (= (TLA.fapply (TLA.fapply d "fres") p)
(Head (TLA.fapply a_ca "sigma"))) (TLA.bAll ProcSet ((q) (=> (-. (= q p))
(= (TLA.fapply (TLA.fapply d "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))) (= (TLA.fapply d "sigma")
(Tail (TLA.fapply a_ca "sigma"))))))))))))
$hyp "v'233" (= (TLA.fapply pc p) "D3")
$hyp "v'234" (= a_xhash_primea
(TLA.except x p (TLA.fapply Q (TLA.fapply j p))))
$hyp "v'235" (= a_Qhash_primea
(TLA.except Q (TLA.fapply j p) BOT))
$hyp "v'236" (= a_Xhash_primea X)
$hyp "v'237" (= a_ihash_primea i)
$hyp "v'238" (= a_lhash_primea l)
$hyp "v'239" (= a_vhash_primea
v)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'242" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'243" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'251" (= (TLA.fapply Q (TLA.fapply j p))
BOT)
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'263" (TLA.bAll (TLA.DOMAIN seq) ((k) (= (TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((k_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k_1))
BOT)) (TLA.fapply Q (TLA.fapply seq k_1)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k_1))))))))) k)
(TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((k_1) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k_1))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k_1)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k_1))))))))) k))))
$goal (= (TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k)))))))))
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hr:"bAll(DOMAIN(seq), (\<lambda>k. ((Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))]))))[k])=(Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))]))))[k]))))" (is "?z_hr")
 using v'263 by blast
 assume z_Hs:"(Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))]))))~=Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))))" (is "?z_hy~=?z_hbx")
 have z_Hco: "(~(((isAFcn(?z_hy)&isAFcn(?z_hbx))&(DOMAIN(?z_hy)=DOMAIN(?z_hbx)))&(\\A zenon_Vi:((zenon_Vi \\in DOMAIN(?z_hbx))=>((?z_hy[zenon_Vi])=(?z_hbx[zenon_Vi]))))))" (is "~(?z_hcq&?z_hcx)")
 by (rule zenon_notfunequal_0 [of "?z_hy" "?z_hbx", OF z_Hs])
 show FALSE
 proof (rule zenon_notand [OF z_Hco])
  assume z_Hde:"(~?z_hcq)" (is "~(?z_hcr&?z_hcu)")
  show FALSE
  proof (rule zenon_notand [OF z_Hde])
   assume z_Hdf:"(~?z_hcr)" (is "~(?z_hcs&?z_hct)")
   show FALSE
   proof (rule zenon_notand [OF z_Hdf])
    assume z_Hdg:"(~?z_hcs)"
    show FALSE
    by (rule zenon_notisafcn_fcn [of "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))])))", OF z_Hdg])
   next
    assume z_Hdh:"(~?z_hct)"
    show FALSE
    by (rule zenon_notisafcn_fcn [of "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdh])
   qed
  next
   assume z_Hdi:"(DOMAIN(?z_hy)~=DOMAIN(?z_hbx))" (is "?z_hcv~=?z_hcw")
   have z_Hdj: "(DOMAIN(seq)~=?z_hcw)" (is "?z_ht~=_")
   by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vsfa. (zenon_Vsfa~=?z_hcw))" "?z_ht" "(\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))])))", OF z_Hdi])
   have z_Hdn: "(?z_ht~=?z_ht)"
   by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vdfa. (?z_ht~=zenon_Vdfa))" "?z_ht" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdj])
   show FALSE
   by (rule zenon_noteq [OF z_Hdn])
  qed
 next
  assume z_Hdr:"(~?z_hcx)" (is "~(\\A x : ?z_hds(x))")
  have z_Hdt: "(\\E zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbx))=>((?z_hy[zenon_Vi])=(?z_hbx[zenon_Vi])))))" (is "\\E x : ?z_hdv(x)")
  by (rule zenon_notallex_0 [of "?z_hds", OF z_Hdr])
  have z_Hdw: "?z_hdv((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbx))=>((?z_hy[zenon_Vi])=(?z_hbx[zenon_Vi]))))))" (is "~(?z_hdy=>?z_hdz)")
  by (rule zenon_ex_choose_0 [of "?z_hdv", OF z_Hdt])
  have z_Hdy: "?z_hdy"
  by (rule zenon_notimply_0 [OF z_Hdw])
  have z_Hea: "((?z_hy[(CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbx))=>((?z_hy[zenon_Vi])=(?z_hbx[zenon_Vi])))))])~=(?z_hbx[(CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbx))=>((?z_hy[zenon_Vi])=(?z_hbx[zenon_Vi])))))]))" (is "?z_heb~=?z_hec")
  by (rule zenon_notimply_1 [OF z_Hdw])
  have z_Hed: "((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbx))=>((?z_hy[zenon_Vi])=(?z_hbx[zenon_Vi]))))) \\in DOMAIN(seq))" (is "?z_hed")
  by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vkh. ((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbx))=>((?z_hy[zenon_Vi])=(?z_hbx[zenon_Vi]))))) \\in zenon_Vkh))" "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdy])
  have z_Hdz: "?z_hdz"
  by (rule zenon_all_in_0 [of "DOMAIN(seq)" "(\<lambda>k. ((?z_hy[k])=(?z_hbx[k])))", OF z_Hr z_Hed])
  show FALSE
  by (rule notE [OF z_Hea z_Hdz])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 682"; *} qed
lemma ob'749:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'232: "(cond((((fapply ((Q), (fapply ((j), (p))))) = (BOT))), (cond((((fapply ((j), (p))) = ((arith_add ((fapply ((l), (p))), ((minus (((Succ[0])))))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & (((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (M))))), (((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((arith_add ((fapply ((j), (p))), ((Succ[0])))))]))) & (((((a_pchash_primea :: c)) = (pc))) & ((((a_Mhash_primea :: c)) = (M))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D4'')]))) & ((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %d. (((a_h022c5783954683bdcbcacced356fd6a ((d)) :: c)) & (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((d), (''fres''))), (p))) = ((Head ((fapply ((a_ca), (''sigma'')))))))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = ((Tail ((fapply ((a_ca), (''sigma''))))))))))))))))))"
assumes v'233: "(((fapply ((pc), (p))) = (''D3'')))"
assumes v'234: "((((a_xhash_primea :: c)) = ([(x) EXCEPT ![(p)] = (fapply ((Q), (fapply ((j), (p)))))])))"
assumes v'235: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((j), (p)))] = (BOT)])))"
assumes v'236: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'237: "((((a_ihash_primea :: c)) = (i)))"
assumes v'238: "((((a_lhash_primea :: c)) = (l)))"
assumes v'239: "((((a_vhash_primea :: c)) = (v)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'242: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'243: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'252: "(((fapply ((Q), (fapply ((j), (p))))) \<noteq> (BOT)))"
assumes v'272: "(((fapply ((j), (p))) \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0])))))))))))))"
shows "(((((A) \<union> ({(fapply ((j), (p)))}))) \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0])))))))))))))))"(is "PROP ?ob'749")
proof -
ML_command {* writeln "*** TLAPS ENTER 749"; *}
show "PROP ?ob'749"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_3597c8.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_3597c8.znn.out
;; obligation #749
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'232" (TLA.cond (= (TLA.fapply Q (TLA.fapply j p))
BOT) (TLA.cond (= (TLA.fapply j p) (arith.add (TLA.fapply l p)
(arith.minus (TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea
(TLA.except pc p "D1")) (/\ (= a_jhash_primea j) (= a_Mhash_primea
M))) (/\ (= a_jhash_primea (TLA.except j p (arith.add (TLA.fapply j p)
(TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea pc) (= a_Mhash_primea
M)))) (/\ (= a_pchash_primea (TLA.except pc p "D4")) (= a_jhash_primea j)
(= a_Mhash_primea
(TLA.subsetOf CDomain ((d) (/\ (a_h022c5783954683bdcbcacced356fd6a d)
(TLA.bEx M ((a_ca) (/\ (= (TLA.fapply (TLA.fapply d "fres") p)
(Head (TLA.fapply a_ca "sigma"))) (TLA.bAll ProcSet ((q) (=> (-. (= q p))
(= (TLA.fapply (TLA.fapply d "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))) (= (TLA.fapply d "sigma")
(Tail (TLA.fapply a_ca "sigma"))))))))))))
$hyp "v'233" (= (TLA.fapply pc p) "D3")
$hyp "v'234" (= a_xhash_primea
(TLA.except x p (TLA.fapply Q (TLA.fapply j p))))
$hyp "v'235" (= a_Qhash_primea
(TLA.except Q (TLA.fapply j p) BOT))
$hyp "v'236" (= a_Xhash_primea X)
$hyp "v'237" (= a_ihash_primea i)
$hyp "v'238" (= a_lhash_primea l)
$hyp "v'239" (= a_vhash_primea
v)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'242" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'243" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'252" (-. (= (TLA.fapply Q (TLA.fapply j p))
BOT))
$hyp "v'272" (TLA.in (TLA.fapply j p) (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add X (arith.minus (TLA.fapply TLA.Succ 0)))))
$goal (TLA.in (TLA.cup A (TLA.set (TLA.fapply j p)))
(TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0) (arith.add X
(arith.minus (TLA.fapply TLA.Succ 0))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hh:"(a_Xhash_primea=X)"
 using v'236 by blast
 have z_Hl:"(A \\in SUBSET(isa'dotdot(1, (a_Xhash_primea +  -.(1)))))" (is "?z_hl")
 using A_in by blast
 have z_Hq:"((j[p]) \\in isa'dotdot(1, (X +  -.(1))))" (is "?z_hq")
 using v'272 by blast
 assume z_Hr:"(~((A \\cup {(j[p])}) \\in SUBSET(isa'dotdot(1, (X +  -.(1))))))" (is "~?z_hbf")
 have z_Hbj: "(A \\subseteq isa'dotdot(1, (a_Xhash_primea +  -.(1))))" (is "?z_hbj")
 by (rule zenon_in_SUBSET_0 [of "A" "isa'dotdot(1, (a_Xhash_primea +  -.(1)))", OF z_Hl])
 have z_Hbk: "(~((A \\cup {(j[p])}) \\subseteq isa'dotdot(1, (X +  -.(1)))))" (is "~?z_hbl")
 by (rule zenon_notin_SUBSET_0 [of "(A \\cup {(j[p])})" "isa'dotdot(1, (X +  -.(1)))", OF z_Hr])
 have z_Hbm_z_Hbk: "(~bAll((A \\cup {(j[p])}), (\<lambda>zenon_Vh. (zenon_Vh \\in isa'dotdot(1, (X +  -.(1))))))) == (~?z_hbl)" (is "?z_hbm == ?z_hbk")
 by (unfold subset_def)
 have z_Hbm: "?z_hbm" (is "~?z_hbn")
 by (unfold z_Hbm_z_Hbk, fact z_Hbk)
 have z_Hbr_z_Hbm: "(~(\\A x:((x \\in (A \\cup {(j[p])}))=>(x \\in isa'dotdot(1, (X +  -.(1))))))) == ?z_hbm" (is "?z_hbr == _")
 by (unfold bAll_def)
 have z_Hbr: "?z_hbr" (is "~(\\A x : ?z_hbx(x))")
 by (unfold z_Hbr_z_Hbm, fact z_Hbm)
 have z_Hby: "(\\E x:(~((x \\in (A \\cup {(j[p])}))=>(x \\in isa'dotdot(1, (X +  -.(1)))))))" (is "\\E x : ?z_hca(x)")
 by (rule zenon_notallex_0 [of "?z_hbx", OF z_Hbr])
 have z_Hcb: "?z_hca((CHOOSE x:(~((x \\in (A \\cup {(j[p])}))=>(x \\in isa'dotdot(1, (X +  -.(1))))))))" (is "~(?z_hcd=>?z_hce)")
 by (rule zenon_ex_choose_0 [of "?z_hca", OF z_Hby])
 have z_Hcd: "?z_hcd"
 by (rule zenon_notimply_0 [OF z_Hcb])
 have z_Hcf: "(~?z_hce)"
 by (rule zenon_notimply_1 [OF z_Hcb])
 show FALSE
 proof (rule zenon_in_cup [of "(CHOOSE x:(~((x \\in (A \\cup {(j[p])}))=>(x \\in isa'dotdot(1, (X +  -.(1)))))))" "A" "{(j[p])}", OF z_Hcd])
  assume z_Hcg:"((CHOOSE x:(~((x \\in (A \\cup {(j[p])}))=>(x \\in isa'dotdot(1, (X +  -.(1))))))) \\in A)" (is "?z_hcg")
  have z_Hch: "(A \\subseteq isa'dotdot(1, (X +  -.(1))))" (is "?z_hch")
  by (rule subst [where P="(\<lambda>zenon_Vha. (A \\subseteq isa'dotdot(1, (zenon_Vha +  -.(1)))))", OF z_Hh z_Hbj])
  have z_Hcn_z_Hch: "bAll(A, (\<lambda>zenon_Vh. (zenon_Vh \\in isa'dotdot(1, (X +  -.(1)))))) == ?z_hch" (is "?z_hcn == _")
  by (unfold subset_def)
  have z_Hcn: "?z_hcn"
  by (unfold z_Hcn_z_Hch, fact z_Hch)
  have z_Hco_z_Hcn: "(\\A x:((x \\in A)=>(x \\in isa'dotdot(1, (X +  -.(1)))))) == ?z_hcn" (is "?z_hco == _")
  by (unfold bAll_def)
  have z_Hco: "?z_hco" (is "\\A x : ?z_hcr(x)")
  by (unfold z_Hco_z_Hcn, fact z_Hcn)
  have z_Hcs: "?z_hcr((CHOOSE x:(~((x \\in (A \\cup {(j[p])}))=>(x \\in isa'dotdot(1, (X +  -.(1))))))))"
  by (rule zenon_all_0 [of "?z_hcr" "(CHOOSE x:(~((x \\in (A \\cup {(j[p])}))=>(x \\in isa'dotdot(1, (X +  -.(1)))))))", OF z_Hco])
  show FALSE
  proof (rule zenon_imply [OF z_Hcs])
   assume z_Hct:"(~?z_hcg)"
   show FALSE
   by (rule notE [OF z_Hct z_Hcg])
  next
   assume z_Hce:"?z_hce"
   show FALSE
   by (rule notE [OF z_Hcf z_Hce])
  qed
 next
  assume z_Hcu:"((CHOOSE x:(~((x \\in (A \\cup {(j[p])}))=>(x \\in isa'dotdot(1, (X +  -.(1))))))) \\in {(j[p])})" (is "?z_hcu")
  show FALSE
  proof (rule zenon_in_addElt [of "(CHOOSE x:(~((x \\in (A \\cup {(j[p])}))=>(x \\in isa'dotdot(1, (X +  -.(1)))))))" "(j[p])" "{}", OF z_Hcu])
   assume z_Hcw:"((CHOOSE x:(~((x \\in (A \\cup {(j[p])}))=>(x \\in isa'dotdot(1, (X +  -.(1)))))))=(j[p]))" (is "?z_hcc=?z_hba")
   show FALSE
   proof (rule notE [OF z_Hcf])
    have z_Hcx: "(?z_hba=?z_hcc)"
    by (rule sym [OF z_Hcw])
    have z_Hce: "?z_hce"
    by (rule subst [where P="(\<lambda>zenon_Vh. (zenon_Vh \\in isa'dotdot(1, (X +  -.(1)))))", OF z_Hcx], fact z_Hq)
    thus "?z_hce" .
   qed
  next
   assume z_Hcy:"((CHOOSE x:(~((x \\in (A \\cup {(j[p])}))=>(x \\in isa'dotdot(1, (X +  -.(1))))))) \\in {})" (is "?z_hcy")
   show FALSE
   by (rule zenon_in_emptyset [of "(CHOOSE x:(~((x \\in (A \\cup {(j[p])}))=>(x \\in isa'dotdot(1, (X +  -.(1)))))))", OF z_Hcy])
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 749"; *} qed
lemma ob'728:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'232: "(cond((((fapply ((Q), (fapply ((j), (p))))) = (BOT))), (cond((((fapply ((j), (p))) = ((arith_add ((fapply ((l), (p))), ((minus (((Succ[0])))))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & (((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (M))))), (((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((arith_add ((fapply ((j), (p))), ((Succ[0])))))]))) & (((((a_pchash_primea :: c)) = (pc))) & ((((a_Mhash_primea :: c)) = (M))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D4'')]))) & ((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %d. (((a_h022c5783954683bdcbcacced356fd6a ((d)) :: c)) & (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((d), (''fres''))), (p))) = ((Head ((fapply ((a_ca), (''sigma'')))))))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = ((Tail ((fapply ((a_ca), (''sigma''))))))))))))))))))"
assumes v'233: "(((fapply ((pc), (p))) = (''D3'')))"
assumes v'234: "((((a_xhash_primea :: c)) = ([(x) EXCEPT ![(p)] = (fapply ((Q), (fapply ((j), (p)))))])))"
assumes v'235: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((j), (p)))] = (BOT)])))"
assumes v'236: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'237: "((((a_ihash_primea :: c)) = (i)))"
assumes v'238: "((((a_lhash_primea :: c)) = (l)))"
assumes v'239: "((((a_vhash_primea :: c)) = (v)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'242: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'243: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'252: "(((fapply ((Q), (fapply ((j), (p))))) \<noteq> (BOT)))"
assumes v'269: "(((fapply ((j), (p))) \<notin> (A)))"
assumes v'270: "((IsFiniteSet ((A))))"
assumes v'271: "((\<And> S :: c. (\<And> x_1 :: c. (((IsFiniteSet ((S)))) \<Longrightarrow> (((IsFiniteSet ((((S) \<union> ({(x_1)})))))) & ((((Cardinality ((((S) \<union> ({(x_1)})))))) = (cond((((x_1) \<in> (S))), ((Cardinality ((S)))), ((arith_add (((Cardinality ((S)))), ((Succ[0]))))))))))))))"
assumes v'272: "((\<And> S :: c. (\<And> n :: c. n \<in> (Nat) \<Longrightarrow> (((ExistsBijection (((isa_peri_peri_a (((Succ[0])), (n)))), (S)))) \<Longrightarrow> ((((Cardinality ((S)))) = (n)))))))"
assumes v'273: "(((IsFiniteSet (({})))) & (\<forall>S : ((((IsFiniteSet ((S)))) \<Rightarrow> ((((((Cardinality ((S)))) = ((0)))) \<Leftrightarrow> (((S) = ({})))))))))"
assumes v'274: "((((Cardinality (({})))) = ((0))))"
shows "((((Cardinality ((((A) \<union> ({(fapply ((j), (p)))})))))) = ((arith_add (((Cardinality ((A)))), ((Succ[0])))))))"(is "PROP ?ob'728")
proof -
ML_command {* writeln "*** TLAPS ENTER 728"; *}
show "PROP ?ob'728"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_e83991.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_e83991.znn.out
;; obligation #728
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'232" (TLA.cond (= (TLA.fapply Q (TLA.fapply j p))
BOT) (TLA.cond (= (TLA.fapply j p) (arith.add (TLA.fapply l p)
(arith.minus (TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea
(TLA.except pc p "D1")) (/\ (= a_jhash_primea j) (= a_Mhash_primea
M))) (/\ (= a_jhash_primea (TLA.except j p (arith.add (TLA.fapply j p)
(TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea pc) (= a_Mhash_primea
M)))) (/\ (= a_pchash_primea (TLA.except pc p "D4")) (= a_jhash_primea j)
(= a_Mhash_primea
(TLA.subsetOf CDomain ((d) (/\ (a_h022c5783954683bdcbcacced356fd6a d)
(TLA.bEx M ((a_ca) (/\ (= (TLA.fapply (TLA.fapply d "fres") p)
(Head (TLA.fapply a_ca "sigma"))) (TLA.bAll ProcSet ((q) (=> (-. (= q p))
(= (TLA.fapply (TLA.fapply d "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))) (= (TLA.fapply d "sigma")
(Tail (TLA.fapply a_ca "sigma"))))))))))))
$hyp "v'233" (= (TLA.fapply pc p) "D3")
$hyp "v'234" (= a_xhash_primea
(TLA.except x p (TLA.fapply Q (TLA.fapply j p))))
$hyp "v'235" (= a_Qhash_primea
(TLA.except Q (TLA.fapply j p) BOT))
$hyp "v'236" (= a_Xhash_primea X)
$hyp "v'237" (= a_ihash_primea i)
$hyp "v'238" (= a_lhash_primea l)
$hyp "v'239" (= a_vhash_primea
v)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'242" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'243" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'252" (-. (= (TLA.fapply Q (TLA.fapply j p))
BOT))
$hyp "v'269" (-. (TLA.in (TLA.fapply j p)
A))
$hyp "v'270" (IsFiniteSet A)
$hyp "v'271" (A. ((S) (A. ((x_1) (=> (IsFiniteSet S) (/\ (IsFiniteSet (TLA.cup S
(TLA.set x_1))) (= (Cardinality (TLA.cup S (TLA.set x_1)))
(TLA.cond (TLA.in x_1 S) (Cardinality S) (arith.add (Cardinality S)
(TLA.fapply TLA.Succ 0))))))))))
$hyp "v'272" (A. ((S) (TLA.bAll arith.N ((n) (=> (ExistsBijection (arith.intrange (TLA.fapply TLA.Succ 0)
n) S) (= (Cardinality S) n))))))
$hyp "v'273" (/\ (IsFiniteSet TLA.emptyset) (A. ((S) (=> (IsFiniteSet S)
(<=> (= (Cardinality S) 0) (= S
TLA.emptyset))))))
$hyp "v'274" (= (Cardinality TLA.emptyset) 0)
$goal (= (Cardinality (TLA.cup A (TLA.set (TLA.fapply j p))))
(arith.add (Cardinality A)
(TLA.fapply TLA.Succ 0)))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hs:"(\\A S:(\\A x_1:(IsFiniteSet(S)=>(IsFiniteSet((S \\cup {x_1}))&(Cardinality((S \\cup {x_1}))=cond((x_1 \\in S), Cardinality(S), (Cardinality(S) + 1)))))))" (is "\\A x : ?z_hbn(x)")
 using v'271 by blast
 have z_Hq:"(~((j[p]) \\in A))" (is "~?z_hbo")
 using v'269 by blast
 have z_Hr:"IsFiniteSet(A)" (is "?z_hr")
 using v'270 by blast
 assume z_Hw:"(Cardinality((A \\cup {(j[p])}))~=(Cardinality(A) + 1))" (is "?z_hbt~=?z_hbw")
 have z_Hby: "?z_hbn(A)" (is "\\A x : ?z_hbz(x)")
 by (rule zenon_all_0 [of "?z_hbn" "A", OF z_Hs])
 have z_Hca: "?z_hbz((j[p]))" (is "_=>?z_hcb")
 by (rule zenon_all_0 [of "?z_hbz" "(j[p])", OF z_Hby])
 show FALSE
 proof (rule zenon_imply [OF z_Hca])
  assume z_Hcc:"(~?z_hr)"
  show FALSE
  by (rule notE [OF z_Hcc z_Hr])
 next
  assume z_Hcb:"?z_hcb" (is "?z_hcd&?z_hce")
  have z_Hce: "?z_hce" (is "_=?z_hcf")
  by (rule zenon_and_1 [OF z_Hcb])
  show FALSE
  proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vhk. (?z_hbt=zenon_Vhk))" "?z_hbo" "Cardinality(A)" "?z_hbw", OF z_Hce])
   assume z_Hbo:"?z_hbo"
   assume z_Hcj:"(?z_hbt=Cardinality(A))" (is "_=?z_hbx")
   show FALSE
   by (rule notE [OF z_Hq z_Hbo])
  next
   assume z_Hq:"(~?z_hbo)"
   assume z_Hck:"(?z_hbt=?z_hbw)"
   show FALSE
   by (rule notE [OF z_Hw z_Hck])
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 728"; *} qed
lemma ob'796:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'232: "(cond((((fapply ((Q), (fapply ((j), (p))))) = (BOT))), (cond((((fapply ((j), (p))) = ((arith_add ((fapply ((l), (p))), ((minus (((Succ[0])))))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & (((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (M))))), (((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((arith_add ((fapply ((j), (p))), ((Succ[0])))))]))) & (((((a_pchash_primea :: c)) = (pc))) & ((((a_Mhash_primea :: c)) = (M))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D4'')]))) & ((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %d. (((a_h022c5783954683bdcbcacced356fd6a ((d)) :: c)) & (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((d), (''fres''))), (p))) = ((Head ((fapply ((a_ca), (''sigma'')))))))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = ((Tail ((fapply ((a_ca), (''sigma''))))))))))))))))))"
assumes v'233: "(((fapply ((pc), (p))) = (''D3'')))"
assumes v'234: "((((a_xhash_primea :: c)) = ([(x) EXCEPT ![(p)] = (fapply ((Q), (fapply ((j), (p)))))])))"
assumes v'235: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((j), (p)))] = (BOT)])))"
assumes v'236: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'237: "((((a_ihash_primea :: c)) = (i)))"
assumes v'238: "((((a_lhash_primea :: c)) = (l)))"
assumes v'239: "((((a_vhash_primea :: c)) = (v)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'242: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'243: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'252: "(((fapply ((Q), (fapply ((j), (p))))) \<noteq> (BOT)))"
assumes v'282: "((((DOMAIN ((Concat ((<<(fapply ((j), (p)))>>), (seq)))))) = ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((seq)))), ((Succ[0]))))))))))"
assumes v'283: "((((a_Lena (((Concat ((<<(fapply ((j), (p)))>>), (seq))))))) = ((arith_add (((a_Lena ((seq)))), ((Succ[0])))))))"
shows "((((DOMAIN ((Concat ((<<(fapply ((j), (p)))>>), (seq)))))) = ((isa_peri_peri_a (((Succ[0])), ((a_Lena (((Concat ((<<(fapply ((j), (p)))>>), (seq))))))))))))"(is "PROP ?ob'796")
proof -
ML_command {* writeln "*** TLAPS ENTER 796"; *}
show "PROP ?ob'796"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_b74e2b.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_b74e2b.znn.out
;; obligation #796
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'232" (TLA.cond (= (TLA.fapply Q (TLA.fapply j p))
BOT) (TLA.cond (= (TLA.fapply j p) (arith.add (TLA.fapply l p)
(arith.minus (TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea
(TLA.except pc p "D1")) (/\ (= a_jhash_primea j) (= a_Mhash_primea
M))) (/\ (= a_jhash_primea (TLA.except j p (arith.add (TLA.fapply j p)
(TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea pc) (= a_Mhash_primea
M)))) (/\ (= a_pchash_primea (TLA.except pc p "D4")) (= a_jhash_primea j)
(= a_Mhash_primea
(TLA.subsetOf CDomain ((d) (/\ (a_h022c5783954683bdcbcacced356fd6a d)
(TLA.bEx M ((a_ca) (/\ (= (TLA.fapply (TLA.fapply d "fres") p)
(Head (TLA.fapply a_ca "sigma"))) (TLA.bAll ProcSet ((q) (=> (-. (= q p))
(= (TLA.fapply (TLA.fapply d "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))) (= (TLA.fapply d "sigma")
(Tail (TLA.fapply a_ca "sigma"))))))))))))
$hyp "v'233" (= (TLA.fapply pc p) "D3")
$hyp "v'234" (= a_xhash_primea
(TLA.except x p (TLA.fapply Q (TLA.fapply j p))))
$hyp "v'235" (= a_Qhash_primea
(TLA.except Q (TLA.fapply j p) BOT))
$hyp "v'236" (= a_Xhash_primea X)
$hyp "v'237" (= a_ihash_primea i)
$hyp "v'238" (= a_lhash_primea l)
$hyp "v'239" (= a_vhash_primea
v)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'242" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'243" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'252" (-. (= (TLA.fapply Q (TLA.fapply j p))
BOT))
$hyp "v'282" (= (TLA.DOMAIN (Concat (TLA.tuple (TLA.fapply j p)) seq))
(arith.intrange (TLA.fapply TLA.Succ 0) (arith.add (a_Lena seq)
(TLA.fapply TLA.Succ 0))))
$hyp "v'283" (= (a_Lena (Concat (TLA.tuple (TLA.fapply j p)) seq))
(arith.add (a_Lena seq)
(TLA.fapply TLA.Succ 0)))
$goal (= (TLA.DOMAIN (Concat (TLA.tuple (TLA.fapply j p)) seq))
(arith.intrange (TLA.fapply TLA.Succ 0)
(a_Lena (Concat (TLA.tuple (TLA.fapply j p))
seq))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hq:"(DOMAIN(Concat(<<(j[p])>>, seq))=isa'dotdot(1, (a_Lena(seq) + 1)))" (is "?z_ht=?z_hba")
 using v'282 by blast
 have z_Hr:"(a_Lena(Concat(<<(j[p])>>, seq))=(a_Lena(seq) + 1))" (is "?z_hbe=?z_hbc")
 using v'283 by blast
 assume z_Hs:"(?z_ht~=isa'dotdot(1, ?z_hbe))" (is "_~=?z_hbf")
 show FALSE
 proof (rule notE [OF z_Hs])
  have z_Hbg: "(?z_hba=?z_hbf)"
  proof (rule zenon_nnpp [of "(?z_hba=?z_hbf)"])
   assume z_Hbh:"(?z_hba~=?z_hbf)"
   show FALSE
   proof (rule zenon_noteq [of "?z_hbf"])
    have z_Hbi: "(?z_hbc=?z_hbe)"
    by (rule sym [OF z_Hr])
    have z_Hbj: "(?z_hbf~=?z_hbf)"
    by (rule subst [where P="(\<lambda>zenon_Vkb. (isa'dotdot(1, zenon_Vkb)~=?z_hbf))", OF z_Hbi], fact z_Hbh)
    thus "(?z_hbf~=?z_hbf)" .
   qed
  qed
  have z_Hbo: "(?z_ht=?z_hbf)"
  by (rule subst [where P="(\<lambda>zenon_Vj. (?z_ht=zenon_Vj))", OF z_Hbg], fact z_Hq)
  thus "(?z_ht=?z_hbf)" .
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 796"; *} qed
lemma ob'896:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'232: "(cond((((fapply ((Q), (fapply ((j), (p))))) = (BOT))), (cond((((fapply ((j), (p))) = ((arith_add ((fapply ((l), (p))), ((minus (((Succ[0])))))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & (((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (M))))), (((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((arith_add ((fapply ((j), (p))), ((Succ[0])))))]))) & (((((a_pchash_primea :: c)) = (pc))) & ((((a_Mhash_primea :: c)) = (M))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D4'')]))) & ((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %d. (((a_h022c5783954683bdcbcacced356fd6a ((d)) :: c)) & (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((d), (''fres''))), (p))) = ((Head ((fapply ((a_ca), (''sigma'')))))))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = ((Tail ((fapply ((a_ca), (''sigma''))))))))))))))))))"
assumes v'233: "(((fapply ((pc), (p))) = (''D3'')))"
assumes v'234: "((((a_xhash_primea :: c)) = ([(x) EXCEPT ![(p)] = (fapply ((Q), (fapply ((j), (p)))))])))"
assumes v'235: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((j), (p)))] = (BOT)])))"
assumes v'236: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'237: "((((a_ihash_primea :: c)) = (i)))"
assumes v'238: "((((a_lhash_primea :: c)) = (l)))"
assumes v'239: "((((a_vhash_primea :: c)) = (v)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'242: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'243: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'252: "(((fapply ((Q), (fapply ((j), (p))))) \<noteq> (BOT)))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
assumes v'293: "(\<exists> a_cunde_a \<in> (M) : ((((fapply ((((''sigma'' :> ((Tail ((fapply ((a_ca), (''sigma''))))))) @@ (''fres'' :> ([(fapply ((a_ca), (''fres''))) EXCEPT ![(p)] = ((Head ((fapply ((a_ca), (''sigma''))))))])))), (''sigma''))) = ((Tail ((fapply ((a_cunde_a), (''sigma'')))))))) & (((fapply ((fapply ((((''sigma'' :> ((Tail ((fapply ((a_ca), (''sigma''))))))) @@ (''fres'' :> ([(fapply ((a_ca), (''fres''))) EXCEPT ![(p)] = ((Head ((fapply ((a_ca), (''sigma''))))))])))), (''fres''))), (p))) = ((Head ((fapply ((a_cunde_a), (''sigma'')))))))) & (\<forall> r \<in> (ProcSet) : (((((r) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((((''sigma'' :> ((Tail ((fapply ((a_ca), (''sigma''))))))) @@ (''fres'' :> ([(fapply ((a_ca), (''fres''))) EXCEPT ![(p)] = ((Head ((fapply ((a_ca), (''sigma''))))))])))), (''fres''))), (r))) = (fapply ((fapply ((a_cunde_a), (''fres''))), (r))))))))))"
assumes v'294: "(((((''sigma'' :> ((Tail ((fapply ((a_ca), (''sigma''))))))) @@ (''fres'' :> ([(fapply ((a_ca), (''fres''))) EXCEPT ![(p)] = ((Head ((fapply ((a_ca), (''sigma''))))))])))) \<in> (CDomain)))"
assumes v'295: "((a_h022c5783954683bdcbcacced356fd6a ((((''sigma'' :> ((Tail ((fapply ((a_ca), (''sigma''))))))) @@ (''fres'' :> ([(fapply ((a_ca), (''fres''))) EXCEPT ![(p)] = ((Head ((fapply ((a_ca), (''sigma''))))))]))))) :: c))"
shows "(((((''sigma'' :> ((Tail ((fapply ((a_ca), (''sigma''))))))) @@ (''fres'' :> ([(fapply ((a_ca), (''fres''))) EXCEPT ![(p)] = ((Head ((fapply ((a_ca), (''sigma''))))))])))) \<in> ((a_Mhash_primea :: c))))"(is "PROP ?ob'896")
proof -
ML_command {* writeln "*** TLAPS ENTER 896"; *}
show "PROP ?ob'896"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_5a6868.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_5a6868.znn.out
;; obligation #896
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'232" (TLA.cond (= (TLA.fapply Q (TLA.fapply j p))
BOT) (TLA.cond (= (TLA.fapply j p) (arith.add (TLA.fapply l p)
(arith.minus (TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea
(TLA.except pc p "D1")) (/\ (= a_jhash_primea j) (= a_Mhash_primea
M))) (/\ (= a_jhash_primea (TLA.except j p (arith.add (TLA.fapply j p)
(TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea pc) (= a_Mhash_primea
M)))) (/\ (= a_pchash_primea (TLA.except pc p "D4")) (= a_jhash_primea j)
(= a_Mhash_primea
(TLA.subsetOf CDomain ((d) (/\ (a_h022c5783954683bdcbcacced356fd6a d)
(TLA.bEx M ((a_ca) (/\ (= (TLA.fapply (TLA.fapply d "fres") p)
(Head (TLA.fapply a_ca "sigma"))) (TLA.bAll ProcSet ((q) (=> (-. (= q p))
(= (TLA.fapply (TLA.fapply d "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))) (= (TLA.fapply d "sigma")
(Tail (TLA.fapply a_ca "sigma"))))))))))))
$hyp "v'233" (= (TLA.fapply pc p) "D3")
$hyp "v'234" (= a_xhash_primea
(TLA.except x p (TLA.fapply Q (TLA.fapply j p))))
$hyp "v'235" (= a_Qhash_primea
(TLA.except Q (TLA.fapply j p) BOT))
$hyp "v'236" (= a_Xhash_primea X)
$hyp "v'237" (= a_ihash_primea i)
$hyp "v'238" (= a_lhash_primea l)
$hyp "v'239" (= a_vhash_primea
v)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'242" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'243" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'252" (-. (= (TLA.fapply Q (TLA.fapply j p))
BOT))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'293" (TLA.bEx M ((a_cunde_a) (/\ (= (TLA.fapply (TLA.record "sigma" (Tail (TLA.fapply a_ca "sigma")) "fres" (TLA.except (TLA.fapply a_ca "fres") p (Head (TLA.fapply a_ca "sigma")))) "sigma")
(Tail (TLA.fapply a_cunde_a "sigma")))
(= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Tail (TLA.fapply a_ca "sigma")) "fres" (TLA.except (TLA.fapply a_ca "fres") p (Head (TLA.fapply a_ca "sigma")))) "fres") p)
(Head (TLA.fapply a_cunde_a "sigma"))) (TLA.bAll ProcSet ((r) (=> (-. (= r
p))
(= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Tail (TLA.fapply a_ca "sigma")) "fres" (TLA.except (TLA.fapply a_ca "fres") p (Head (TLA.fapply a_ca "sigma")))) "fres") r)
(TLA.fapply (TLA.fapply a_cunde_a "fres") r))))))))
$hyp "v'294" (TLA.in (TLA.record "sigma" (Tail (TLA.fapply a_ca "sigma")) "fres" (TLA.except (TLA.fapply a_ca "fres") p (Head (TLA.fapply a_ca "sigma"))))
CDomain)
$hyp "v'295" (a_h022c5783954683bdcbcacced356fd6a (TLA.record "sigma" (Tail (TLA.fapply a_ca "sigma")) "fres" (TLA.except (TLA.fapply a_ca "fres") p (Head (TLA.fapply a_ca "sigma")))))
$goal (TLA.in (TLA.record "sigma" (Tail (TLA.fapply a_ca "sigma")) "fres" (TLA.except (TLA.fapply a_ca "fres") p (Head (TLA.fapply a_ca "sigma"))))
a_Mhash_primea)
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hr:"bEx(M, (\<lambda>a_cunde_a. ((((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''sigma''])=Tail((a_cunde_a[''sigma''])))&(((((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''fres''])[p])=Head((a_cunde_a[''sigma''])))&bAll(ProcSet, (\<lambda>r. ((r~=p)=>((((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''fres''])[r])=((a_cunde_a[''fres''])[r])))))))))" (is "?z_hr")
 using v'293 by blast
 have z_Hp:"((Q[(j[p])])~=BOT)" (is "?z_hcc~=_")
 using v'252 by blast
 have z_Ht:"a_h022c5783954683bdcbcacced356fd6a((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma'']))))))" (is "?z_ht")
 using v'295 by blast
 have z_Hs:"((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma'']))))) \\in CDomain)" (is "?z_hs")
 using v'294 by blast
 have z_Hd:"cond((?z_hcc=BOT), cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M)))), ((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf(CDomain, (\<lambda>d. (a_h022c5783954683bdcbcacced356fd6a(d)&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma'']))))))))))))))" (is "?z_hd")
 using v'232 by blast
 assume z_Hu:"(~((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma'']))))) \\in a_Mhash_primea))" (is "~?z_hej")
 have z_Hek_z_Hr: "(\\E x:((x \\in M)&((((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''sigma''])=Tail((x[''sigma''])))&(((((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''fres''])[p])=Head((x[''sigma''])))&bAll(ProcSet, (\<lambda>r. ((r~=p)=>((((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''fres''])[r])=((x[''fres''])[r]))))))))) == ?z_hr" (is "?z_hek == _")
 by (unfold bEx_def)
 have z_Hek: "?z_hek" (is "\\E x : ?z_hfb(x)")
 by (unfold z_Hek_z_Hr, fact z_Hr)
 have z_Hfc: "?z_hfb((CHOOSE x:((x \\in M)&((((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''sigma''])=Tail((x[''sigma''])))&(((((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''fres''])[p])=Head((x[''sigma''])))&bAll(ProcSet, (\<lambda>r. ((r~=p)=>((((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''fres''])[r])=((x[''fres''])[r]))))))))))" (is "?z_hfe&?z_hff")
 by (rule zenon_ex_choose_0 [of "?z_hfb", OF z_Hek])
 have z_Hfe: "?z_hfe"
 by (rule zenon_and_0 [OF z_Hfc])
 have z_Hff: "?z_hff" (is "?z_hfg&?z_hfh")
 by (rule zenon_and_1 [OF z_Hfc])
 have z_Hfg: "?z_hfg" (is "?z_hz=?z_hfi")
 by (rule zenon_and_0 [OF z_Hff])
 have z_Hfh: "?z_hfh" (is "?z_hfj&?z_hfk")
 by (rule zenon_and_1 [OF z_Hff])
 have z_Hfj: "?z_hfj" (is "?z_hbp=?z_hfl")
 by (rule zenon_and_0 [OF z_Hfh])
 have z_Hfk: "?z_hfk"
 by (rule zenon_and_1 [OF z_Hfh])
 show FALSE
 proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vf. zenon_Vf)" "(?z_hcc=BOT)" "cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))))" "((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf(CDomain, (\<lambda>d. (a_h022c5783954683bdcbcacced356fd6a(d)&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))))))", OF z_Hd])
  assume z_Hci:"(?z_hcc=BOT)"
  assume z_Hcj:"cond(((j[p])=((l[p]) +  -.(1))), ((a_pchash_primea=except(pc, p, ''D1''))&((a_jhash_primea=j)&(a_Mhash_primea=M))), ((a_jhash_primea=except(j, p, ((j[p]) + 1)))&((a_pchash_primea=pc)&(a_Mhash_primea=M))))" (is "?z_hcj")
  show FALSE
  by (rule notE [OF z_Hp z_Hci])
 next
  assume z_Hp:"(?z_hcc~=BOT)"
  assume z_Hdh:"((a_pchash_primea=except(pc, p, ''D4''))&((a_jhash_primea=j)&(a_Mhash_primea=subsetOf(CDomain, (\<lambda>d. (a_h022c5783954683bdcbcacced356fd6a(d)&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))))))" (is "?z_hdi&?z_hdl")
  have z_Hdl: "?z_hdl" (is "?z_hcx&?z_hdm")
  by (rule zenon_and_1 [OF z_Hdh])
  have z_Hdm: "?z_hdm" (is "_=?z_hdn")
  by (rule zenon_and_1 [OF z_Hdl])
  have z_Hfo: "(\\A zenon_Vub:((zenon_Vub \\in a_Mhash_primea)<=>(zenon_Vub \\in ?z_hdn)))" (is "\\A x : ?z_hft(x)")
  by (rule zenon_setequal_0 [of "a_Mhash_primea" "?z_hdn", OF z_Hdm])
  have z_Hfu: "?z_hft((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma'']))))))" (is "_<=>?z_hfv")
  by (rule zenon_all_0 [of "?z_hft" "(''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))", OF z_Hfo])
  show FALSE
  proof (rule zenon_equiv [OF z_Hfu])
   assume z_Hu:"(~?z_hej)"
   assume z_Hfw:"(~?z_hfv)"
   show FALSE
   proof (rule zenon_notin_subsetof [of "(''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))" "CDomain" "(\<lambda>d. (a_h022c5783954683bdcbcacced356fd6a(d)&bEx(M, (\<lambda>a_ca. ((((d[''fres''])[p])=Head((a_ca[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>(((d[''fres''])[q])=((a_ca[''fres''])[q])))))&((d[''sigma''])=Tail((a_ca[''sigma''])))))))))", OF z_Hfw])
    assume z_Hfx:"(~?z_hs)"
    show FALSE
    by (rule notE [OF z_Hfx z_Hs])
   next
    assume z_Hfy:"(~(?z_ht&bEx(M, (\<lambda>zenon_Vmi. ((?z_hbp=Head((zenon_Vmi[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>((((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''fres''])[q])=((zenon_Vmi[''fres''])[q])))))&(?z_hz=Tail((zenon_Vmi[''sigma''])))))))))" (is "~(_&?z_hga)")
    show FALSE
    proof (rule zenon_notand [OF z_Hfy])
     assume z_Hgr:"(~?z_ht)"
     show FALSE
     by (rule notE [OF z_Hgr z_Ht])
    next
     assume z_Hgs:"(~?z_hga)"
     have z_Hgt: "(~(?z_hfj&(?z_hfk&?z_hfg)))" (is "~(_&?z_hgv)")
     by (rule zenon_notex_in_0 [of "M" "(\<lambda>zenon_Vmi. ((?z_hbp=Head((zenon_Vmi[''sigma''])))&(bAll(ProcSet, (\<lambda>q. ((q~=p)=>((((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''fres''])[q])=((zenon_Vmi[''fres''])[q])))))&(?z_hz=Tail((zenon_Vmi[''sigma'']))))))", OF z_Hgs z_Hfe])
     show FALSE
     proof (rule zenon_notand [OF z_Hgt])
      assume z_Hgw:"(?z_hbp~=?z_hfl)"
      show FALSE
      by (rule notE [OF z_Hgw z_Hfj])
     next
      assume z_Hgx:"(~?z_hgv)"
      show FALSE
      proof (rule zenon_notand [OF z_Hgx])
       assume z_Hgy:"(~?z_hfk)"
       show FALSE
       by (rule notE [OF z_Hgy z_Hfk])
      next
       assume z_Hgz:"(?z_hz~=?z_hfi)"
       show FALSE
       by (rule notE [OF z_Hgz z_Hfg])
      qed
     qed
    qed
   qed
  next
   assume z_Hej:"?z_hej"
   assume z_Hfv:"?z_hfv"
   show FALSE
   by (rule notE [OF z_Hu z_Hej])
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 896"; *} qed
lemma ob'951:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'231: "(cond((((fapply ((Q), (fapply ((j), (p))))) = (BOT))), (cond((((fapply ((j), (p))) = ((arith_add ((fapply ((l), (p))), ((minus (((Succ[0])))))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & (((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (M))))), (((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((arith_add ((fapply ((j), (p))), ((Succ[0])))))]))) & (((((a_pchash_primea :: c)) = (pc))) & ((((a_Mhash_primea :: c)) = (M))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D4'')]))) & ((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %d. (((a_h022c5783954683bdcbcacced356fd6a ((d)) :: c)) & (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((d), (''fres''))), (p))) = ((Head ((fapply ((a_ca), (''sigma'')))))))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = ((Tail ((fapply ((a_ca), (''sigma''))))))))))))))))))"
assumes v'232: "(((fapply ((pc), (p))) = (''D3'')))"
assumes v'233: "((((a_xhash_primea :: c)) = ([(x) EXCEPT ![(p)] = (fapply ((Q), (fapply ((j), (p)))))])))"
assumes v'234: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((j), (p)))] = (BOT)])))"
assumes v'235: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'236: "((((a_ihash_primea :: c)) = (i)))"
assumes v'237: "((((a_lhash_primea :: c)) = (l)))"
assumes v'238: "((((a_vhash_primea :: c)) = (v)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'241: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'242: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'251: "(((fapply ((Q), (fapply ((j), (p))))) \<noteq> (BOT)))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
assumes v'284: "(((fapply ((((''sigma'' :> ((Tail ((fapply ((a_ca), (''sigma''))))))) @@ (''fres'' :> ([(fapply ((a_ca), (''fres''))) EXCEPT ![(p)] = ((Head ((fapply ((a_ca), (''sigma''))))))])))), (''sigma''))) \<in> ([((DOMAIN (seq))) \<rightarrow> (((Nat) \\ ({((0))})))])))"
assumes v'285: "((([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k)))))))))))))]) \<in> ([((DOMAIN (seq))) \<rightarrow> (((Nat) \\ ({((0))})))])))"
assumes v'286: "(\<forall> k \<in> ((DOMAIN (seq))) : (((fapply ((fapply ((((''sigma'' :> ((Tail ((fapply ((a_ca), (''sigma''))))))) @@ (''fres'' :> ([(fapply ((a_ca), (''fres''))) EXCEPT ![(p)] = ((Head ((fapply ((a_ca), (''sigma''))))))])))), (''sigma''))), (k))) = (fapply (([ k_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k_1))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k_1)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k_1)))))))))))))]), (k))))))"
shows "(((fapply ((((''sigma'' :> ((Tail ((fapply ((a_ca), (''sigma''))))))) @@ (''fres'' :> ([(fapply ((a_ca), (''fres''))) EXCEPT ![(p)] = ((Head ((fapply ((a_ca), (''sigma''))))))])))), (''sigma''))) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (k)))))))))))))])))"(is "PROP ?ob'951")
proof -
ML_command {* writeln "*** TLAPS ENTER 951"; *}
show "PROP ?ob'951"
using assms by auto
ML_command {* writeln "*** TLAPS EXIT 951"; *} qed
lemma ob'989:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'231: "(cond((((fapply ((Q), (fapply ((j), (p))))) = (BOT))), (cond((((fapply ((j), (p))) = ((arith_add ((fapply ((l), (p))), ((minus (((Succ[0])))))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & (((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (M))))), (((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((arith_add ((fapply ((j), (p))), ((Succ[0])))))]))) & (((((a_pchash_primea :: c)) = (pc))) & ((((a_Mhash_primea :: c)) = (M))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D4'')]))) & ((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %d. (((a_h022c5783954683bdcbcacced356fd6a ((d)) :: c)) & (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((d), (''fres''))), (p))) = ((Head ((fapply ((a_ca), (''sigma'')))))))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = ((Tail ((fapply ((a_ca), (''sigma''))))))))))))))))))"
assumes v'232: "(((fapply ((pc), (p))) = (''D3'')))"
assumes v'233: "((((a_xhash_primea :: c)) = ([(x) EXCEPT ![(p)] = (fapply ((Q), (fapply ((j), (p)))))])))"
assumes v'234: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((j), (p)))] = (BOT)])))"
assumes v'235: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'236: "((((a_ihash_primea :: c)) = (i)))"
assumes v'237: "((((a_lhash_primea :: c)) = (l)))"
assumes v'238: "((((a_vhash_primea :: c)) = (v)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'241: "(\<forall> k \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))) : ((((((fapply (((a_Qhash_primea :: c)), (k))) \<noteq> (BOT))) \<Rightarrow> (((k) \<in> (A))))) & (((((((k) \<in> (A))) \<and> (((fapply (((a_Qhash_primea :: c)), (k))) = (BOT))))) \<Rightarrow> (\<exists> q \<in> (ProcSet) : (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (k))))))))))"
assumes v'242: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'251: "(((fapply ((Q), (fapply ((j), (p))))) \<noteq> (BOT)))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
fixes k
assumes k_in : "(k \<in> ((DOMAIN (seq))))"
assumes v'290: "(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) = (BOT)))"
assumes v'295: "(((fapply ((seq), (k))) \<in> (A)))"
shows "(\<exists> r \<in> (ProcSet) : (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k))))))))"(is "PROP ?ob'989")
proof -
ML_command {* writeln "*** TLAPS ENTER 989"; *}
show "PROP ?ob'989"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_f1c05e.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_f1c05e.znn.out
;; obligation #989
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'231" (TLA.cond (= (TLA.fapply Q (TLA.fapply j p))
BOT) (TLA.cond (= (TLA.fapply j p) (arith.add (TLA.fapply l p)
(arith.minus (TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea
(TLA.except pc p "D1")) (/\ (= a_jhash_primea j) (= a_Mhash_primea
M))) (/\ (= a_jhash_primea (TLA.except j p (arith.add (TLA.fapply j p)
(TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea pc) (= a_Mhash_primea
M)))) (/\ (= a_pchash_primea (TLA.except pc p "D4")) (= a_jhash_primea j)
(= a_Mhash_primea
(TLA.subsetOf CDomain ((d) (/\ (a_h022c5783954683bdcbcacced356fd6a d)
(TLA.bEx M ((a_ca) (/\ (= (TLA.fapply (TLA.fapply d "fres") p)
(Head (TLA.fapply a_ca "sigma"))) (TLA.bAll ProcSet ((q) (=> (-. (= q p))
(= (TLA.fapply (TLA.fapply d "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))) (= (TLA.fapply d "sigma")
(Tail (TLA.fapply a_ca "sigma"))))))))))))
$hyp "v'232" (= (TLA.fapply pc p) "D3")
$hyp "v'233" (= a_xhash_primea
(TLA.except x p (TLA.fapply Q (TLA.fapply j p))))
$hyp "v'234" (= a_Qhash_primea
(TLA.except Q (TLA.fapply j p) BOT))
$hyp "v'235" (= a_Xhash_primea X)
$hyp "v'236" (= a_ihash_primea i)
$hyp "v'237" (= a_lhash_primea l)
$hyp "v'238" (= a_vhash_primea
v)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'241" (TLA.bAll (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0)))) ((k) (/\ (=> (-. (= (TLA.fapply a_Qhash_primea k)
BOT)) (TLA.in k A)) (=> (/\ (TLA.in k A) (= (TLA.fapply a_Qhash_primea k)
BOT)) (TLA.bEx ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q) "E2")
(= (TLA.fapply a_ihash_primea q)
k))))))))
$hyp "v'242" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'251" (-. (= (TLA.fapply Q (TLA.fapply j p))
BOT))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "k_in" (TLA.in k (TLA.DOMAIN seq))
$hyp "v'290" (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)
$hyp "v'295" (TLA.in (TLA.fapply seq k)
A)
$goal (TLA.bEx ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r) "E2")
(= (TLA.fapply i r)
(TLA.fapply seq k)))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hi:"(a_ihash_primea=i)"
 using v'236 by blast
 have z_Hh:"(a_Xhash_primea=X)"
 using v'235 by blast
 have z_Hl:"(A \\in SUBSET(isa'dotdot(1, (a_Xhash_primea +  -.(1)))))" (is "?z_hl")
 using A_in by blast
 have z_Ht:"((seq[k]) \\in A)" (is "?z_ht")
 using v'295 by blast
 have z_Hs:"((a_Qhash_primea[(seq[k])])=BOT)" (is "?z_hbi=_")
 using v'290 by blast
 have z_Hn:"bAll(isa'dotdot(1, (a_Xhash_primea +  -.(1))), (\<lambda>k. ((((a_Qhash_primea[k])~=BOT)=>(k \\in A))&(((k \\in A)&((a_Qhash_primea[k])=BOT))=>bEx(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=k))))))))" (is "?z_hn")
 using v'241 by blast
 assume z_Hu:"(~bEx(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((i[r])=(seq[k]))))))" (is "~?z_hcf")
 have z_Hcn: "(A \\subseteq isa'dotdot(1, (a_Xhash_primea +  -.(1))))" (is "?z_hcn")
 by (rule zenon_in_SUBSET_0 [of "A" "isa'dotdot(1, (a_Xhash_primea +  -.(1)))", OF z_Hl])
 have z_Hco_z_Hn: "(\\A x:((x \\in isa'dotdot(1, (a_Xhash_primea +  -.(1))))=>((((a_Qhash_primea[x])~=BOT)=>(x \\in A))&(((x \\in A)&((a_Qhash_primea[x])=BOT))=>bEx(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=x)))))))) == ?z_hn" (is "?z_hco == _")
 by (unfold bAll_def)
 have z_Hco: "?z_hco" (is "\\A x : ?z_hde(x)")
 by (unfold z_Hco_z_Hn, fact z_Hn)
 have z_Hdf_z_Hu: "(~(\\E x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((i[x])=(seq[k])))))) == (~?z_hcf)" (is "?z_hdf == ?z_hu")
 by (unfold bEx_def)
 have z_Hdf: "?z_hdf" (is "~(\\E x : ?z_hdo(x))")
 by (unfold z_Hdf_z_Hu, fact z_Hu)
 have z_Hdp: "(A \\subseteq isa'dotdot(1, (X +  -.(1))))" (is "?z_hdp")
 by (rule subst [where P="(\<lambda>zenon_Vwx. (A \\subseteq isa'dotdot(1, (zenon_Vwx +  -.(1)))))", OF z_Hh z_Hcn])
 have z_Hdx_z_Hdp: "bAll(A, (\<lambda>zenon_Vob. (zenon_Vob \\in isa'dotdot(1, (X +  -.(1)))))) == ?z_hdp" (is "?z_hdx == _")
 by (unfold subset_def)
 have z_Hdx: "?z_hdx"
 by (unfold z_Hdx_z_Hdp, fact z_Hdp)
 have z_Heb_z_Hdx: "(\\A x:((x \\in A)=>(x \\in isa'dotdot(1, (X +  -.(1)))))) == ?z_hdx" (is "?z_heb == _")
 by (unfold bAll_def)
 have z_Heb: "?z_heb" (is "\\A x : ?z_hee(x)")
 by (unfold z_Heb_z_Hdx, fact z_Hdx)
 have z_Hef: "?z_hde((seq[k]))" (is "?z_heg=>?z_heh")
 by (rule zenon_all_0 [of "?z_hde" "(seq[k])", OF z_Hco])
 show FALSE
 proof (rule zenon_imply [OF z_Hef])
  assume z_Hei:"(~?z_heg)"
  have z_Hej: "(~((seq[k]) \\in isa'dotdot(1, (X +  -.(1)))))" (is "~?z_hek")
  by (rule subst [where P="(\<lambda>zenon_Vex. (~((seq[k]) \\in isa'dotdot(1, (zenon_Vex +  -.(1))))))", OF z_Hh z_Hei])
  have z_Her: "?z_hee((seq[k]))"
  by (rule zenon_all_0 [of "?z_hee" "(seq[k])", OF z_Heb])
  show FALSE
  proof (rule zenon_imply [OF z_Her])
   assume z_Hes:"(~?z_ht)"
   show FALSE
   by (rule notE [OF z_Hes z_Ht])
  next
   assume z_Hek:"?z_hek"
   show FALSE
   by (rule notE [OF z_Hej z_Hek])
  qed
 next
  assume z_Heh:"?z_heh" (is "?z_het&?z_heu")
  have z_Heu: "?z_heu" (is "?z_hev=>?z_hew")
  by (rule zenon_and_1 [OF z_Heh])
  show FALSE
  proof (rule zenon_imply [OF z_Heu])
   assume z_Hex:"(~?z_hev)" (is "~(_&?z_hs)")
   show FALSE
   proof (rule zenon_notand [OF z_Hex])
    assume z_Hes:"(~?z_ht)"
    show FALSE
    by (rule notE [OF z_Hes z_Ht])
   next
    assume z_Hey:"(?z_hbi~=BOT)"
    show FALSE
    by (rule notE [OF z_Hey z_Hs])
   qed
  next
   assume z_Hew:"?z_hew"
   have z_Hez_z_Hew: "(\\E x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(seq[k]))))) == ?z_hew" (is "?z_hez == _")
   by (unfold bEx_def)
   have z_Hez: "?z_hez" (is "\\E x : ?z_hfe(x)")
   by (unfold z_Hez_z_Hew, fact z_Hew)
   have z_Hff: "?z_hfe((CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(seq[k]))))))" (is "?z_hfh&?z_hfi")
   by (rule zenon_ex_choose_0 [of "?z_hfe", OF z_Hez])
   have z_Hfh: "?z_hfh"
   by (rule zenon_and_0 [OF z_Hff])
   have z_Hfi: "?z_hfi" (is "?z_hfj&?z_hfk")
   by (rule zenon_and_1 [OF z_Hff])
   have z_Hfj: "?z_hfj" (is "?z_hfl=?z_hcc")
   by (rule zenon_and_0 [OF z_Hfi])
   have z_Hfk: "?z_hfk" (is "?z_hfm=?z_hbf")
   by (rule zenon_and_1 [OF z_Hfi])
   have z_Hfn: "((i[(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=?z_hcc)&((a_ihash_primea[x])=?z_hbf))))])=?z_hbf)" (is "?z_hfo=_")
   by (rule subst [where P="(\<lambda>zenon_Vay. ((zenon_Vay[(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=?z_hcc)&((a_ihash_primea[x])=?z_hbf))))])=?z_hbf))", OF z_Hi z_Hfk])
   have z_Hft: "~?z_hdo((CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=?z_hcc)&((a_ihash_primea[x])=?z_hbf)))))" (is "~(_&?z_hfu)")
   by (rule zenon_notex_0 [of "?z_hdo" "(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=?z_hcc)&((a_ihash_primea[x])=?z_hbf))))", OF z_Hdf])
   show FALSE
   proof (rule zenon_notand [OF z_Hft])
    assume z_Hfv:"(~?z_hfh)"
    show FALSE
    by (rule notE [OF z_Hfv z_Hfh])
   next
    assume z_Hfw:"(~?z_hfu)" (is "~(_&?z_hfn)")
    show FALSE
    proof (rule zenon_notand [OF z_Hfw])
     assume z_Hfx:"(?z_hfl~=?z_hcc)"
     show FALSE
     by (rule notE [OF z_Hfx z_Hfj])
    next
     assume z_Hfy:"(?z_hfo~=?z_hbf)"
     show FALSE
     by (rule notE [OF z_Hfy z_Hfn])
    qed
   qed
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 989"; *} qed
lemma ob'768:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'231: "(cond((((fapply ((Q), (fapply ((j), (p))))) = (BOT))), (cond((((fapply ((j), (p))) = ((arith_add ((fapply ((l), (p))), ((minus (((Succ[0])))))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & (((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (M))))), (((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((arith_add ((fapply ((j), (p))), ((Succ[0])))))]))) & (((((a_pchash_primea :: c)) = (pc))) & ((((a_Mhash_primea :: c)) = (M))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D4'')]))) & ((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %d. (((a_h022c5783954683bdcbcacced356fd6a ((d)) :: c)) & (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((d), (''fres''))), (p))) = ((Head ((fapply ((a_ca), (''sigma'')))))))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = ((Tail ((fapply ((a_ca), (''sigma''))))))))))))))))))"
assumes v'232: "(((fapply ((pc), (p))) = (''D3'')))"
assumes v'233: "((((a_xhash_primea :: c)) = ([(x) EXCEPT ![(p)] = (fapply ((Q), (fapply ((j), (p)))))])))"
assumes v'234: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((j), (p)))] = (BOT)])))"
assumes v'235: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'236: "((((a_ihash_primea :: c)) = (i)))"
assumes v'237: "((((a_lhash_primea :: c)) = (l)))"
assumes v'238: "((((a_vhash_primea :: c)) = (v)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> (subsetOf(([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) \<rightarrow> (A)]), %f. (\<forall> w \<in> (A) : (\<exists> q \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) : (((fapply ((f), (q))) = (w))))))))"
assumes v'241: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'242: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'251: "(((fapply ((Q), (fapply ((j), (p))))) \<noteq> (BOT)))"
assumes v'273: "((((a_Lena (((Concat ((<<(fapply ((j), (p)))>>), (seq))))))) = ((Cardinality ((((A) \<union> ({(fapply ((j), (p)))}))))))))"
assumes v'274: "((((Concat ((<<(fapply ((j), (p)))>>), (seq)))) \<in> ([((isa_peri_peri_a (((Succ[0])), ((a_Lena (((Concat ((<<(fapply ((j), (p)))>>), (seq)))))))))) \<rightarrow> (((A) \<union> ({(fapply ((j), (p)))})))])))"
assumes v'275: "(\<forall> w \<in> (((A) \<union> ({(fapply ((j), (p)))}))) : (\<exists> k \<in> ((isa_peri_peri_a (((Succ[0])), ((a_Lena (((Concat ((<<(fapply ((j), (p)))>>), (seq)))))))))) : (((fapply (((Concat ((<<(fapply ((j), (p)))>>), (seq)))), (k))) = (w)))))"
shows "((((Concat ((<<(fapply ((j), (p)))>>), (seq)))) \<in> (subsetOf(([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((((A) \<union> ({(fapply ((j), (p)))}))))))))) \<rightarrow> (((A) \<union> ({(fapply ((j), (p)))})))]), %f. (\<forall> w \<in> (((A) \<union> ({(fapply ((j), (p)))}))) : (\<exists> q \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((((A) \<union> ({(fapply ((j), (p)))}))))))))) : (((fapply ((f), (q))) = (w)))))))))"(is "PROP ?ob'768")
proof -
ML_command {* writeln "*** TLAPS ENTER 768"; *}
show "PROP ?ob'768"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_cf70fa.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_cf70fa.znn.out
;; obligation #768
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'231" (TLA.cond (= (TLA.fapply Q (TLA.fapply j p))
BOT) (TLA.cond (= (TLA.fapply j p) (arith.add (TLA.fapply l p)
(arith.minus (TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea
(TLA.except pc p "D1")) (/\ (= a_jhash_primea j) (= a_Mhash_primea
M))) (/\ (= a_jhash_primea (TLA.except j p (arith.add (TLA.fapply j p)
(TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea pc) (= a_Mhash_primea
M)))) (/\ (= a_pchash_primea (TLA.except pc p "D4")) (= a_jhash_primea j)
(= a_Mhash_primea
(TLA.subsetOf CDomain ((d) (/\ (a_h022c5783954683bdcbcacced356fd6a d)
(TLA.bEx M ((a_ca) (/\ (= (TLA.fapply (TLA.fapply d "fres") p)
(Head (TLA.fapply a_ca "sigma"))) (TLA.bAll ProcSet ((q) (=> (-. (= q p))
(= (TLA.fapply (TLA.fapply d "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))) (= (TLA.fapply d "sigma")
(Tail (TLA.fapply a_ca "sigma"))))))))))))
$hyp "v'232" (= (TLA.fapply pc p) "D3")
$hyp "v'233" (= a_xhash_primea
(TLA.except x p (TLA.fapply Q (TLA.fapply j p))))
$hyp "v'234" (= a_Qhash_primea
(TLA.except Q (TLA.fapply j p) BOT))
$hyp "v'235" (= a_Xhash_primea X)
$hyp "v'236" (= a_ihash_primea i)
$hyp "v'237" (= a_lhash_primea l)
$hyp "v'238" (= a_vhash_primea
v)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (TLA.subsetOf (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) A) ((f) (TLA.bAll A ((w) (TLA.bEx (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) ((q) (= (TLA.fapply f q)
w))))))))
$hyp "v'241" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'242" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'251" (-. (= (TLA.fapply Q (TLA.fapply j p))
BOT))
$hyp "v'273" (= (a_Lena (Concat (TLA.tuple (TLA.fapply j p)) seq))
(Cardinality (TLA.cup A
(TLA.set (TLA.fapply j p)))))
$hyp "v'274" (TLA.in (Concat (TLA.tuple (TLA.fapply j p)) seq)
(TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
(a_Lena (Concat (TLA.tuple (TLA.fapply j p)) seq))) (TLA.cup A
(TLA.set (TLA.fapply j p)))))
$hyp "v'275" (TLA.bAll (TLA.cup A
(TLA.set (TLA.fapply j p))) ((w) (TLA.bEx (arith.intrange (TLA.fapply TLA.Succ 0)
(a_Lena (Concat (TLA.tuple (TLA.fapply j p))
seq))) ((k) (= (TLA.fapply (Concat (TLA.tuple (TLA.fapply j p)) seq) k)
w)))))
$goal (TLA.in (Concat (TLA.tuple (TLA.fapply j p)) seq)
(TLA.subsetOf (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality (TLA.cup A (TLA.set (TLA.fapply j p))))) (TLA.cup A
(TLA.set (TLA.fapply j p)))) ((f) (TLA.bAll (TLA.cup A
(TLA.set (TLA.fapply j p))) ((w) (TLA.bEx (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality (TLA.cup A
(TLA.set (TLA.fapply j p))))) ((q) (= (TLA.fapply f q)
w))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hs:"bAll((A \\cup {(j[p])}), (\<lambda>w. bEx(isa'dotdot(1, a_Lena(Concat(<<(j[p])>>, seq))), (\<lambda>k. ((Concat(<<(j[p])>>, seq)[k])=w)))))" (is "?z_hs")
 using v'275 by blast
 have z_Hr:"(Concat(<<(j[p])>>, seq) \\in FuncSet(isa'dotdot(1, a_Lena(Concat(<<(j[p])>>, seq))), (A \\cup {(j[p])})))" (is "?z_hr")
 using v'274 by blast
 have z_Hq:"(a_Lena(Concat(<<(j[p])>>, seq))=Cardinality((A \\cup {(j[p])})))" (is "?z_hbe=?z_hbo")
 using v'273 by blast
 have zenon_L1_: "(isa'dotdot(1, ?z_hbe)~=isa'dotdot(1, ?z_hbo)) ==> (?z_hbe=?z_hbo) ==> FALSE" (is "?z_hbp ==> ?z_hq ==> FALSE")
 proof -
  assume z_Hbp:"?z_hbp" (is "?z_hbc~=?z_hbq")
  assume z_Hq:"?z_hq"
  show FALSE
  proof (rule zenon_noteq [of "?z_hbq"])
   have z_Hbr: "(?z_hbq~=?z_hbq)"
   by (rule subst [where P="(\<lambda>zenon_Vfj. (isa'dotdot(1, zenon_Vfj)~=?z_hbq))", OF z_Hq], fact z_Hbp)
   thus "(?z_hbq~=?z_hbq)" .
  qed
 qed
 assume z_Ht:"(~(Concat(<<(j[p])>>, seq) \\in subsetOf(FuncSet(isa'dotdot(1, ?z_hbo), (A \\cup {(j[p])})), (\<lambda>f. bAll((A \\cup {(j[p])}), (\<lambda>w. bEx(isa'dotdot(1, ?z_hbo), (\<lambda>q. ((f[q])=w)))))))))" (is "~?z_hbw")
 have z_Hci_z_Hs: "(\\A x:((x \\in (A \\cup {(j[p])}))=>bEx(isa'dotdot(1, ?z_hbe), (\<lambda>k. ((Concat(<<(j[p])>>, seq)[k])=x))))) == ?z_hs" (is "?z_hci == _")
 by (unfold bAll_def)
 have z_Hci: "?z_hci" (is "\\A x : ?z_hcp(x)")
 by (unfold z_Hci_z_Hs, fact z_Hs)
 show FALSE
 proof (rule zenon_notin_subsetof [of "Concat(<<(j[p])>>, seq)" "FuncSet(isa'dotdot(1, ?z_hbo), (A \\cup {(j[p])}))" "(\<lambda>f. bAll((A \\cup {(j[p])}), (\<lambda>w. bEx(isa'dotdot(1, ?z_hbo), (\<lambda>q. ((f[q])=w))))))", OF z_Ht])
  assume z_Hcq:"(~(Concat(<<(j[p])>>, seq) \\in FuncSet(isa'dotdot(1, ?z_hbo), (A \\cup {(j[p])}))))" (is "~?z_hcr")
  show FALSE
  proof (rule notE [OF z_Hcq])
   have z_Hcs: "(FuncSet(isa'dotdot(1, ?z_hbe), (A \\cup {(j[p])}))=FuncSet(isa'dotdot(1, ?z_hbo), (A \\cup {(j[p])})))" (is "?z_hbn=?z_hby")
   proof (rule zenon_nnpp [of "(?z_hbn=?z_hby)"])
    assume z_Hct:"(?z_hbn~=?z_hby)"
    show FALSE
    proof (rule zenon_noteq [of "?z_hby"])
     have z_Hcu: "(isa'dotdot(1, ?z_hbe)=isa'dotdot(1, ?z_hbo))" (is "?z_hbc=?z_hbq")
     proof (rule zenon_nnpp [of "(?z_hbc=?z_hbq)"])
      assume z_Hbp:"(?z_hbc~=?z_hbq)"
      show FALSE
      by (rule zenon_L1_ [OF z_Hbp z_Hq])
     qed
     have z_Hcv: "(?z_hby~=?z_hby)"
     by (rule subst [where P="(\<lambda>zenon_Vdj. (FuncSet(zenon_Vdj, (A \\cup {(j[p])}))~=?z_hby))", OF z_Hcu], fact z_Hct)
     thus "(?z_hby~=?z_hby)" .
    qed
   qed
   have z_Hcr: "?z_hcr"
   by (rule subst [where P="(\<lambda>zenon_Vjj. (Concat(<<(j[p])>>, seq) \\in zenon_Vjj))", OF z_Hcs], fact z_Hr)
   thus "?z_hcr" .
  qed
 next
  assume z_Hdd:"(~bAll((A \\cup {(j[p])}), (\<lambda>w. bEx(isa'dotdot(1, ?z_hbo), (\<lambda>k. ((Concat(<<(j[p])>>, seq)[k])=w))))))" (is "~?z_hde")
  have z_Hdh_z_Hdd: "(~(\\A x:((x \\in (A \\cup {(j[p])}))=>bEx(isa'dotdot(1, ?z_hbo), (\<lambda>k. ((Concat(<<(j[p])>>, seq)[k])=x)))))) == (~?z_hde)" (is "?z_hdh == ?z_hdd")
  by (unfold bAll_def)
  have z_Hdh: "?z_hdh" (is "~(\\A x : ?z_hdl(x))")
  by (unfold z_Hdh_z_Hdd, fact z_Hdd)
  have z_Hdm: "(\\E x:(~((x \\in (A \\cup {(j[p])}))=>bEx(isa'dotdot(1, ?z_hbo), (\<lambda>k. ((Concat(<<(j[p])>>, seq)[k])=x))))))" (is "\\E x : ?z_hdo(x)")
  by (rule zenon_notallex_0 [of "?z_hdl", OF z_Hdh])
  have z_Hdp: "?z_hdo((CHOOSE x:(~((x \\in (A \\cup {(j[p])}))=>bEx(isa'dotdot(1, ?z_hbo), (\<lambda>k. ((Concat(<<(j[p])>>, seq)[k])=x)))))))" (is "~(?z_hdr=>?z_hds)")
  by (rule zenon_ex_choose_0 [of "?z_hdo", OF z_Hdm])
  have z_Hdr: "?z_hdr"
  by (rule zenon_notimply_0 [OF z_Hdp])
  have z_Hdt: "(~?z_hds)"
  by (rule zenon_notimply_1 [OF z_Hdp])
  have z_Hdu_z_Hdt: "(~(\\E x:((x \\in isa'dotdot(1, ?z_hbo))&((Concat(<<(j[p])>>, seq)[x])=(CHOOSE x:(~((x \\in (A \\cup {(j[p])}))=>bEx(isa'dotdot(1, ?z_hbo), (\<lambda>k. ((Concat(<<(j[p])>>, seq)[k])=x)))))))))) == (~?z_hds)" (is "?z_hdu == ?z_hdt")
  by (unfold bEx_def)
  have z_Hdu: "?z_hdu" (is "~(\\E x : ?z_hea(x))")
  by (unfold z_Hdu_z_Hdt, fact z_Hdt)
  have z_Heb: "?z_hcp((CHOOSE x:(~((x \\in (A \\cup {(j[p])}))=>bEx(isa'dotdot(1, ?z_hbo), (\<lambda>k. ((Concat(<<(j[p])>>, seq)[k])=x)))))))" (is "_=>?z_hec")
  by (rule zenon_all_0 [of "?z_hcp" "(CHOOSE x:(~((x \\in (A \\cup {(j[p])}))=>bEx(isa'dotdot(1, ?z_hbo), (\<lambda>k. ((Concat(<<(j[p])>>, seq)[k])=x))))))", OF z_Hci])
  show FALSE
  proof (rule zenon_imply [OF z_Heb])
   assume z_Hed:"(~?z_hdr)"
   show FALSE
   by (rule notE [OF z_Hed z_Hdr])
  next
   assume z_Hec:"?z_hec"
   have z_Hee_z_Hec: "(\\E x:((x \\in isa'dotdot(1, ?z_hbe))&((Concat(<<(j[p])>>, seq)[x])=(CHOOSE x:(~((x \\in (A \\cup {(j[p])}))=>bEx(isa'dotdot(1, ?z_hbo), (\<lambda>k. ((Concat(<<(j[p])>>, seq)[k])=x))))))))) == ?z_hec" (is "?z_hee == _")
   by (unfold bEx_def)
   have z_Hee: "?z_hee" (is "\\E x : ?z_heh(x)")
   by (unfold z_Hee_z_Hec, fact z_Hec)
   have z_Hei: "?z_heh((CHOOSE x:((x \\in isa'dotdot(1, ?z_hbe))&((Concat(<<(j[p])>>, seq)[x])=(CHOOSE x:(~((x \\in (A \\cup {(j[p])}))=>bEx(isa'dotdot(1, ?z_hbo), (\<lambda>k. ((Concat(<<(j[p])>>, seq)[k])=x))))))))))" (is "?z_hek&?z_hel")
   by (rule zenon_ex_choose_0 [of "?z_heh", OF z_Hee])
   have z_Hek: "?z_hek"
   by (rule zenon_and_0 [OF z_Hei])
   have z_Hel: "?z_hel" (is "?z_hem=?z_hdq")
   by (rule zenon_and_1 [OF z_Hei])
   have z_Hen: "~?z_hea((CHOOSE x:((x \\in isa'dotdot(1, ?z_hbe))&((Concat(<<(j[p])>>, seq)[x])=?z_hdq))))" (is "~(?z_heo&_)")
   by (rule zenon_notex_0 [of "?z_hea" "(CHOOSE x:((x \\in isa'dotdot(1, ?z_hbe))&((Concat(<<(j[p])>>, seq)[x])=?z_hdq)))", OF z_Hdu])
   show FALSE
   proof (rule zenon_notand [OF z_Hen])
    assume z_Hep:"(~?z_heo)"
    show FALSE
    proof (rule notE [OF z_Hep])
     have z_Hcu: "(isa'dotdot(1, ?z_hbe)=isa'dotdot(1, ?z_hbo))" (is "?z_hbc=?z_hbq")
     proof (rule zenon_nnpp [of "(?z_hbc=?z_hbq)"])
      assume z_Hbp:"(?z_hbc~=?z_hbq)"
      show FALSE
      by (rule zenon_L1_ [OF z_Hbp z_Hq])
     qed
     have z_Heo: "?z_heo"
     by (rule subst [where P="(\<lambda>zenon_Vkj. ((CHOOSE x:((x \\in ?z_hbc)&((Concat(<<(j[p])>>, seq)[x])=?z_hdq))) \\in zenon_Vkj))", OF z_Hcu], fact z_Hek)
     thus "?z_heo" .
    qed
   next
    assume z_Het:"(?z_hem~=?z_hdq)"
    show FALSE
    by (rule notE [OF z_Het z_Hel])
   qed
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 768"; *} qed
lemma ob'1000:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'232: "(cond((((fapply ((Q), (fapply ((j), (p))))) = (BOT))), (cond((((fapply ((j), (p))) = ((arith_add ((fapply ((l), (p))), ((minus (((Succ[0])))))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & (((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (M))))), (((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((arith_add ((fapply ((j), (p))), ((Succ[0])))))]))) & (((((a_pchash_primea :: c)) = (pc))) & ((((a_Mhash_primea :: c)) = (M))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D4'')]))) & ((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %d. (((a_h022c5783954683bdcbcacced356fd6a ((d)) :: c)) & (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((d), (''fres''))), (p))) = ((Head ((fapply ((a_ca), (''sigma'')))))))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = ((Tail ((fapply ((a_ca), (''sigma''))))))))))))))))))"
assumes v'233: "(((fapply ((pc), (p))) = (''D3'')))"
assumes v'234: "((((a_xhash_primea :: c)) = ([(x) EXCEPT ![(p)] = (fapply ((Q), (fapply ((j), (p)))))])))"
assumes v'235: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((j), (p)))] = (BOT)])))"
assumes v'236: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'237: "((((a_ihash_primea :: c)) = (i)))"
assumes v'238: "((((a_lhash_primea :: c)) = (l)))"
assumes v'239: "((((a_vhash_primea :: c)) = (v)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'242: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'243: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'252: "(((fapply ((Q), (fapply ((j), (p))))) \<noteq> (BOT)))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
assumes v'285: "((\<And> k :: c. k \<in> ((DOMAIN (seq))) \<Longrightarrow> (((fapply ((fapply ((((''sigma'' :> ((Tail ((fapply ((a_ca), (''sigma''))))))) @@ (''fres'' :> ([(fapply ((a_ca), (''fres''))) EXCEPT ![(p)] = ((Head ((fapply ((a_ca), (''sigma''))))))])))), (''sigma''))), (k))) = (fapply (([ k_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k_1))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k_1)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k_1)))))))))))))]), (k)))))))"
shows "(\<forall> k \<in> ((DOMAIN (seq))) : (((fapply ((fapply ((((''sigma'' :> ((Tail ((fapply ((a_ca), (''sigma''))))))) @@ (''fres'' :> ([(fapply ((a_ca), (''fres''))) EXCEPT ![(p)] = ((Head ((fapply ((a_ca), (''sigma''))))))])))), (''sigma''))), (k))) = (fapply (([ k_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k_1))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k_1)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k_1)))))))))))))]), (k))))))"(is "PROP ?ob'1000")
proof -
ML_command {* writeln "*** TLAPS ENTER 1000"; *}
show "PROP ?ob'1000"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_141180.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_141180.znn.out
;; obligation #1000
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'232" (TLA.cond (= (TLA.fapply Q (TLA.fapply j p))
BOT) (TLA.cond (= (TLA.fapply j p) (arith.add (TLA.fapply l p)
(arith.minus (TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea
(TLA.except pc p "D1")) (/\ (= a_jhash_primea j) (= a_Mhash_primea
M))) (/\ (= a_jhash_primea (TLA.except j p (arith.add (TLA.fapply j p)
(TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea pc) (= a_Mhash_primea
M)))) (/\ (= a_pchash_primea (TLA.except pc p "D4")) (= a_jhash_primea j)
(= a_Mhash_primea
(TLA.subsetOf CDomain ((d) (/\ (a_h022c5783954683bdcbcacced356fd6a d)
(TLA.bEx M ((a_ca) (/\ (= (TLA.fapply (TLA.fapply d "fres") p)
(Head (TLA.fapply a_ca "sigma"))) (TLA.bAll ProcSet ((q) (=> (-. (= q p))
(= (TLA.fapply (TLA.fapply d "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))) (= (TLA.fapply d "sigma")
(Tail (TLA.fapply a_ca "sigma"))))))))))))
$hyp "v'233" (= (TLA.fapply pc p) "D3")
$hyp "v'234" (= a_xhash_primea
(TLA.except x p (TLA.fapply Q (TLA.fapply j p))))
$hyp "v'235" (= a_Qhash_primea
(TLA.except Q (TLA.fapply j p) BOT))
$hyp "v'236" (= a_Xhash_primea X)
$hyp "v'237" (= a_ihash_primea i)
$hyp "v'238" (= a_lhash_primea l)
$hyp "v'239" (= a_vhash_primea
v)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'242" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'243" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'252" (-. (= (TLA.fapply Q (TLA.fapply j p))
BOT))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'285" (TLA.bAll (TLA.DOMAIN seq) ((k) (= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Tail (TLA.fapply a_ca "sigma")) "fres" (TLA.except (TLA.fapply a_ca "fres") p (Head (TLA.fapply a_ca "sigma")))) "sigma") k)
(TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((k_1) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k_1))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k_1)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply i r)
(TLA.fapply seq k_1))))))))) k))))
$goal (TLA.bAll (TLA.DOMAIN seq) ((k) (= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Tail (TLA.fapply a_ca "sigma")) "fres" (TLA.except (TLA.fapply a_ca "fres") p (Head (TLA.fapply a_ca "sigma")))) "sigma") k)
(TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((k_1) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k_1))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k_1)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply i r)
(TLA.fapply seq k_1))))))))) k))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hr:"bAll(DOMAIN(seq), (\<lambda>k. ((((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''sigma''])[k])=(Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((i[r])=(seq[k_1])))))]))))[k]))))" (is "?z_hr")
 using v'285 by blast
 assume z_Hs:"(~?z_hr)"
 show FALSE
 by (rule notE [OF z_Hs z_Hr])
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1000"; *} qed
lemma ob'772:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'231: "(cond((((fapply ((Q), (fapply ((j), (p))))) = (BOT))), (cond((((fapply ((j), (p))) = ((arith_add ((fapply ((l), (p))), ((minus (((Succ[0])))))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & (((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (M))))), (((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((arith_add ((fapply ((j), (p))), ((Succ[0])))))]))) & (((((a_pchash_primea :: c)) = (pc))) & ((((a_Mhash_primea :: c)) = (M))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D4'')]))) & ((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %d. (((a_h022c5783954683bdcbcacced356fd6a ((d)) :: c)) & (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((d), (''fres''))), (p))) = ((Head ((fapply ((a_ca), (''sigma'')))))))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = ((Tail ((fapply ((a_ca), (''sigma''))))))))))))))))))"
assumes v'232: "(((fapply ((pc), (p))) = (''D3'')))"
assumes v'233: "((((a_xhash_primea :: c)) = ([(x) EXCEPT ![(p)] = (fapply ((Q), (fapply ((j), (p)))))])))"
assumes v'234: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((j), (p)))] = (BOT)])))"
assumes v'235: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'236: "((((a_ihash_primea :: c)) = (i)))"
assumes v'237: "((((a_lhash_primea :: c)) = (l)))"
assumes v'238: "((((a_vhash_primea :: c)) = (v)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'241: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'242: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'251: "(((fapply ((Q), (fapply ((j), (p))))) \<noteq> (BOT)))"
assumes v'279: "(\<forall> k \<in> ((isa_peri_peri_a (((Succ[0])), ((a_Lena (([ k \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((<<(fapply ((j), (p)))>>)))), ((a_Lena ((seq))))))))))  \<mapsto> (cond(((leq ((k), ((a_Lena ((<<(fapply ((j), (p)))>>))))))), (fapply ((<<(fapply ((j), (p)))>>), (k))), (fapply ((seq), ((arith_add ((k), ((minus (((a_Lena ((<<(fapply ((j), (p)))>>))))))))))))))]))))))) : (((fapply (([ k_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((<<(fapply ((j), (p)))>>)))), ((a_Lena ((seq))))))))))  \<mapsto> (cond(((leq ((k_1), ((a_Lena ((<<(fapply ((j), (p)))>>))))))), (fapply ((<<(fapply ((j), (p)))>>), (k_1))), (fapply ((seq), ((arith_add ((k_1), ((minus (((a_Lena ((<<(fapply ((j), (p)))>>))))))))))))))]), (k))) \<in> (((A) \<union> ({(fapply ((j), (p)))}))))))"
assumes v'280: "((((DOMAIN ([ k \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((<<(fapply ((j), (p)))>>)))), ((a_Lena ((seq))))))))))  \<mapsto> (cond(((leq ((k), ((a_Lena ((<<(fapply ((j), (p)))>>))))))), (fapply ((<<(fapply ((j), (p)))>>), (k))), (fapply ((seq), ((arith_add ((k), ((minus (((a_Lena ((<<(fapply ((j), (p)))>>))))))))))))))]))) = ((isa_peri_peri_a (((Succ[0])), ((a_Lena (([ k \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((<<(fapply ((j), (p)))>>)))), ((a_Lena ((seq))))))))))  \<mapsto> (cond(((leq ((k), ((a_Lena ((<<(fapply ((j), (p)))>>))))))), (fapply ((<<(fapply ((j), (p)))>>), (k))), (fapply ((seq), ((arith_add ((k), ((minus (((a_Lena ((<<(fapply ((j), (p)))>>))))))))))))))])))))))))"
shows "((([ k \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((<<(fapply ((j), (p)))>>)))), ((a_Lena ((seq))))))))))  \<mapsto> (cond(((leq ((k), ((a_Lena ((<<(fapply ((j), (p)))>>))))))), (fapply ((<<(fapply ((j), (p)))>>), (k))), (fapply ((seq), ((arith_add ((k), ((minus (((a_Lena ((<<(fapply ((j), (p)))>>))))))))))))))]) \<in> ([((isa_peri_peri_a (((Succ[0])), ((a_Lena (([ k \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((<<(fapply ((j), (p)))>>)))), ((a_Lena ((seq))))))))))  \<mapsto> (cond(((leq ((k), ((a_Lena ((<<(fapply ((j), (p)))>>))))))), (fapply ((<<(fapply ((j), (p)))>>), (k))), (fapply ((seq), ((arith_add ((k), ((minus (((a_Lena ((<<(fapply ((j), (p)))>>))))))))))))))]))))))) \<rightarrow> (((A) \<union> ({(fapply ((j), (p)))})))])))"(is "PROP ?ob'772")
proof -
ML_command {* writeln "*** TLAPS ENTER 772"; *}
show "PROP ?ob'772"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_294d44.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_294d44.znn.out
;; obligation #772
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'231" (TLA.cond (= (TLA.fapply Q (TLA.fapply j p))
BOT) (TLA.cond (= (TLA.fapply j p) (arith.add (TLA.fapply l p)
(arith.minus (TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea
(TLA.except pc p "D1")) (/\ (= a_jhash_primea j) (= a_Mhash_primea
M))) (/\ (= a_jhash_primea (TLA.except j p (arith.add (TLA.fapply j p)
(TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea pc) (= a_Mhash_primea
M)))) (/\ (= a_pchash_primea (TLA.except pc p "D4")) (= a_jhash_primea j)
(= a_Mhash_primea
(TLA.subsetOf CDomain ((d) (/\ (a_h022c5783954683bdcbcacced356fd6a d)
(TLA.bEx M ((a_ca) (/\ (= (TLA.fapply (TLA.fapply d "fres") p)
(Head (TLA.fapply a_ca "sigma"))) (TLA.bAll ProcSet ((q) (=> (-. (= q p))
(= (TLA.fapply (TLA.fapply d "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))) (= (TLA.fapply d "sigma")
(Tail (TLA.fapply a_ca "sigma"))))))))))))
$hyp "v'232" (= (TLA.fapply pc p) "D3")
$hyp "v'233" (= a_xhash_primea
(TLA.except x p (TLA.fapply Q (TLA.fapply j p))))
$hyp "v'234" (= a_Qhash_primea
(TLA.except Q (TLA.fapply j p) BOT))
$hyp "v'235" (= a_Xhash_primea X)
$hyp "v'236" (= a_ihash_primea i)
$hyp "v'237" (= a_lhash_primea l)
$hyp "v'238" (= a_vhash_primea
v)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'241" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'242" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'251" (-. (= (TLA.fapply Q (TLA.fapply j p))
BOT))
$hyp "v'279" (TLA.bAll (arith.intrange (TLA.fapply TLA.Succ 0)
(a_Lena (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.tuple (TLA.fapply j p)))
(a_Lena seq))) ((k) (TLA.cond (arith.le k
(a_Lena (TLA.tuple (TLA.fapply j p)))) (TLA.fapply (TLA.tuple (TLA.fapply j p)) k) (TLA.fapply seq (arith.add k
(arith.minus (a_Lena (TLA.tuple (TLA.fapply j p))))))))))) ((k) (TLA.in (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.tuple (TLA.fapply j p)))
(a_Lena seq))) ((k_1) (TLA.cond (arith.le k_1
(a_Lena (TLA.tuple (TLA.fapply j p)))) (TLA.fapply (TLA.tuple (TLA.fapply j p)) k_1) (TLA.fapply seq (arith.add k_1
(arith.minus (a_Lena (TLA.tuple (TLA.fapply j p))))))))) k) (TLA.cup A
(TLA.set (TLA.fapply j p))))))
$hyp "v'280" (= (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.tuple (TLA.fapply j p)))
(a_Lena seq))) ((k) (TLA.cond (arith.le k
(a_Lena (TLA.tuple (TLA.fapply j p)))) (TLA.fapply (TLA.tuple (TLA.fapply j p)) k) (TLA.fapply seq (arith.add k
(arith.minus (a_Lena (TLA.tuple (TLA.fapply j p))))))))))
(arith.intrange (TLA.fapply TLA.Succ 0)
(a_Lena (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.tuple (TLA.fapply j p)))
(a_Lena seq))) ((k) (TLA.cond (arith.le k
(a_Lena (TLA.tuple (TLA.fapply j p)))) (TLA.fapply (TLA.tuple (TLA.fapply j p)) k) (TLA.fapply seq (arith.add k
(arith.minus (a_Lena (TLA.tuple (TLA.fapply j p))))))))))))
$goal (TLA.in (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.tuple (TLA.fapply j p)))
(a_Lena seq))) ((k) (TLA.cond (arith.le k
(a_Lena (TLA.tuple (TLA.fapply j p)))) (TLA.fapply (TLA.tuple (TLA.fapply j p)) k) (TLA.fapply seq (arith.add k
(arith.minus (a_Lena (TLA.tuple (TLA.fapply j p)))))))))
(TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
(a_Lena (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.tuple (TLA.fapply j p)))
(a_Lena seq))) ((k) (TLA.cond (arith.le k
(a_Lena (TLA.tuple (TLA.fapply j p)))) (TLA.fapply (TLA.tuple (TLA.fapply j p)) k) (TLA.fapply seq (arith.add k
(arith.minus (a_Lena (TLA.tuple (TLA.fapply j p))))))))))) (TLA.cup A
(TLA.set (TLA.fapply j p)))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hq:"bAll(isa'dotdot(1, a_Lena(Fcn(isa'dotdot(1, (a_Lena(<<(j[p])>>) + a_Lena(seq))), (\<lambda>k. cond((k <= a_Lena(<<(j[p])>>)), (<<(j[p])>>[k]), (seq[(k +  -.(a_Lena(<<(j[p])>>)))])))))), (\<lambda>k. ((Fcn(isa'dotdot(1, (a_Lena(<<(j[p])>>) + a_Lena(seq))), (\<lambda>k. cond((k <= a_Lena(<<(j[p])>>)), (<<(j[p])>>[k]), (seq[(k +  -.(a_Lena(<<(j[p])>>)))]))))[k]) \\in (A \\cup {(j[p])}))))" (is "?z_hq")
 using v'279 by blast
 have z_Hr:"(DOMAIN(Fcn(isa'dotdot(1, (a_Lena(<<(j[p])>>) + a_Lena(seq))), (\<lambda>k. cond((k <= a_Lena(<<(j[p])>>)), (<<(j[p])>>[k]), (seq[(k +  -.(a_Lena(<<(j[p])>>)))])))))=isa'dotdot(1, a_Lena(Fcn(isa'dotdot(1, (a_Lena(<<(j[p])>>) + a_Lena(seq))), (\<lambda>k. cond((k <= a_Lena(<<(j[p])>>)), (<<(j[p])>>[k]), (seq[(k +  -.(a_Lena(<<(j[p])>>)))])))))))" (is "?z_hbu=?z_ht")
 using v'280 by blast
 assume z_Hs:"(~(Fcn(isa'dotdot(1, (a_Lena(<<(j[p])>>) + a_Lena(seq))), (\<lambda>k. cond((k <= a_Lena(<<(j[p])>>)), (<<(j[p])>>[k]), (seq[(k +  -.(a_Lena(<<(j[p])>>)))])))) \\in FuncSet(?z_ht, (A \\cup {(j[p])}))))" (is "~?z_hbv")
 have z_Hbx_z_Hq: "(\\A zenon_Vh:((zenon_Vh \\in ?z_ht)=>((Fcn(isa'dotdot(1, (a_Lena(<<(j[p])>>) + a_Lena(seq))), (\<lambda>k. cond((k <= a_Lena(<<(j[p])>>)), (<<(j[p])>>[k]), (seq[(k +  -.(a_Lena(<<(j[p])>>)))]))))[zenon_Vh]) \\in (A \\cup {(j[p])})))) == ?z_hq" (is "?z_hbx == _")
 by (unfold bAll_def)
 have z_Hbx: "?z_hbx" (is "\\A x : ?z_hcd(x)")
 by (unfold z_Hbx_z_Hq, fact z_Hq)
 show FALSE
 proof (rule zenon_notin_funcset [of "Fcn(isa'dotdot(1, (a_Lena(<<(j[p])>>) + a_Lena(seq))), (\<lambda>k. cond((k <= a_Lena(<<(j[p])>>)), (<<(j[p])>>[k]), (seq[(k +  -.(a_Lena(<<(j[p])>>)))]))))" "?z_ht" "(A \\cup {(j[p])})", OF z_Hs])
  assume z_Hce:"(~isAFcn(Fcn(isa'dotdot(1, (a_Lena(<<(j[p])>>) + a_Lena(seq))), (\<lambda>k. cond((k <= a_Lena(<<(j[p])>>)), (<<(j[p])>>[k]), (seq[(k +  -.(a_Lena(<<(j[p])>>)))]))))))" (is "~?z_hcf")
  show FALSE
  by (rule zenon_notisafcn_fcn [of "isa'dotdot(1, (a_Lena(<<(j[p])>>) + a_Lena(seq)))" "(\<lambda>k. cond((k <= a_Lena(<<(j[p])>>)), (<<(j[p])>>[k]), (seq[(k +  -.(a_Lena(<<(j[p])>>)))])))", OF z_Hce])
 next
  assume z_Hcg:"(?z_hbu~=?z_ht)"
  show FALSE
  by (rule notE [OF z_Hcg z_Hr])
 next
  assume z_Hch:"(~?z_hbx)"
  show FALSE
  by (rule notE [OF z_Hch z_Hbx])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 772"; *} qed
lemma ob'914:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'231: "(cond((((fapply ((Q), (fapply ((j), (p))))) = (BOT))), (cond((((fapply ((j), (p))) = ((arith_add ((fapply ((l), (p))), ((minus (((Succ[0])))))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & (((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (M))))), (((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((arith_add ((fapply ((j), (p))), ((Succ[0])))))]))) & (((((a_pchash_primea :: c)) = (pc))) & ((((a_Mhash_primea :: c)) = (M))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D4'')]))) & ((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %d. (((a_h022c5783954683bdcbcacced356fd6a ((d)) :: c)) & (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((d), (''fres''))), (p))) = ((Head ((fapply ((a_ca), (''sigma'')))))))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = ((Tail ((fapply ((a_ca), (''sigma''))))))))))))))))))"
assumes v'232: "(((fapply ((pc), (p))) = (''D3'')))"
assumes v'233: "((((a_xhash_primea :: c)) = ([(x) EXCEPT ![(p)] = (fapply ((Q), (fapply ((j), (p)))))])))"
assumes v'234: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((j), (p)))] = (BOT)])))"
assumes v'235: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'236: "((((a_ihash_primea :: c)) = (i)))"
assumes v'237: "((((a_lhash_primea :: c)) = (l)))"
assumes v'238: "((((a_vhash_primea :: c)) = (v)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'241: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'242: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'251: "(((fapply ((Q), (fapply ((j), (p))))) \<noteq> (BOT)))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
assumes v'289: "((((DOMAIN (fapply ((a_ca), (''sigma''))))) = ((isa_peri_peri_a (((Succ[0])), ((a_Lena ((fapply ((a_ca), (''sigma'')))))))))))"
assumes v'290: "(((fapply ((a_ca), (''sigma''))) \<in> ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))])))))))"
shows "(((fapply ((a_ca), (''sigma''))) \<in> ([((isa_peri_peri_a (((Succ[0])), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))) \<rightarrow> (((Nat) \\ ({((0))})))])))"(is "PROP ?ob'914")
proof -
ML_command {* writeln "*** TLAPS ENTER 914"; *}
show "PROP ?ob'914"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_9c1a0f.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_9c1a0f.znn.out
;; obligation #914
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'231" (TLA.cond (= (TLA.fapply Q (TLA.fapply j p))
BOT) (TLA.cond (= (TLA.fapply j p) (arith.add (TLA.fapply l p)
(arith.minus (TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea
(TLA.except pc p "D1")) (/\ (= a_jhash_primea j) (= a_Mhash_primea
M))) (/\ (= a_jhash_primea (TLA.except j p (arith.add (TLA.fapply j p)
(TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea pc) (= a_Mhash_primea
M)))) (/\ (= a_pchash_primea (TLA.except pc p "D4")) (= a_jhash_primea j)
(= a_Mhash_primea
(TLA.subsetOf CDomain ((d) (/\ (a_h022c5783954683bdcbcacced356fd6a d)
(TLA.bEx M ((a_ca) (/\ (= (TLA.fapply (TLA.fapply d "fres") p)
(Head (TLA.fapply a_ca "sigma"))) (TLA.bAll ProcSet ((q) (=> (-. (= q p))
(= (TLA.fapply (TLA.fapply d "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))) (= (TLA.fapply d "sigma")
(Tail (TLA.fapply a_ca "sigma"))))))))))))
$hyp "v'232" (= (TLA.fapply pc p) "D3")
$hyp "v'233" (= a_xhash_primea
(TLA.except x p (TLA.fapply Q (TLA.fapply j p))))
$hyp "v'234" (= a_Qhash_primea
(TLA.except Q (TLA.fapply j p) BOT))
$hyp "v'235" (= a_Xhash_primea X)
$hyp "v'236" (= a_ihash_primea i)
$hyp "v'237" (= a_lhash_primea l)
$hyp "v'238" (= a_vhash_primea
v)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'241" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'242" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'251" (-. (= (TLA.fapply Q (TLA.fapply j p))
BOT))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'289" (= (TLA.DOMAIN (TLA.fapply a_ca "sigma"))
(arith.intrange (TLA.fapply TLA.Succ 0)
(a_Lena (TLA.fapply a_ca "sigma"))))
$hyp "v'290" (TLA.in (TLA.fapply a_ca "sigma")
(TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))))
$goal (TLA.in (TLA.fapply a_ca "sigma")
(TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
(a_Lena (TLA.fapply a_ca "sigma"))) (TLA.setminus arith.N
(TLA.set 0))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hs:"((a_ca[''sigma'']) \\in UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0}))))))" (is "?z_hs")
 using v'290 by blast
 have z_Hr:"(DOMAIN((a_ca[''sigma'']))=isa'dotdot(1, a_Lena((a_ca[''sigma'']))))" (is "?z_hbi=?z_hbj")
 using v'289 by blast
 assume z_Ht:"(~((a_ca[''sigma'']) \\in FuncSet(?z_hbj, (Nat \\ {0}))))" (is "~?z_hbl")
 have z_Hbn: "(\\E zenon_Vk:((zenon_Vk \\in setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))&((a_ca[''sigma'']) \\in zenon_Vk)))" (is "\\E x : ?z_hbs(x)")
 by (rule zenon_in_UNION_0 [of "(a_ca[''sigma''])" "setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0}))))", OF z_Hs])
 have z_Hbt: "?z_hbs((CHOOSE zenon_Vk:((zenon_Vk \\in setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))&((a_ca[''sigma'']) \\in zenon_Vk))))" (is "?z_hbv&?z_hbw")
 by (rule zenon_ex_choose_0 [of "?z_hbs", OF z_Hbn])
 have z_Hbv: "?z_hbv"
 by (rule zenon_and_0 [OF z_Hbt])
 have z_Hbw: "?z_hbw"
 by (rule zenon_and_1 [OF z_Hbt])
 show FALSE
 proof (rule notE [OF z_Ht])
  have z_Hbx: "((CHOOSE zenon_Vk:((zenon_Vk \\in setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))&((a_ca[''sigma'']) \\in zenon_Vk)))=FuncSet(?z_hbj, (Nat \\ {0})))" (is "?z_hbu=?z_hbm")
  proof (rule zenon_nnpp [of "(?z_hbu=?z_hbm)"])
   assume z_Hby:"(?z_hbu~=?z_hbm)"
   have z_Hbz: "(\\E zenon_Vxa:((zenon_Vxa \\in Nat)&(?z_hbu=FuncSet(isa'dotdot(1, zenon_Vxa), (Nat \\ {0})))))" (is "\\E x : ?z_hcg(x)")
   by (rule zenon_in_setofall_0 [of "?z_hbu" "Nat" "(\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))", OF z_Hbv])
   have z_Hch: "?z_hcg((CHOOSE zenon_Vxa:((zenon_Vxa \\in Nat)&(?z_hbu=FuncSet(isa'dotdot(1, zenon_Vxa), (Nat \\ {0}))))))" (is "?z_hcj&?z_hck")
   by (rule zenon_ex_choose_0 [of "?z_hcg", OF z_Hbz])
   have z_Hck: "?z_hck" (is "_=?z_hcl")
   by (rule zenon_and_1 [OF z_Hch])
   show FALSE
   proof (rule notE [OF z_Hby])
    have z_Hcm: "(?z_hcl=?z_hbm)"
    proof (rule zenon_nnpp [of "(?z_hcl=?z_hbm)"])
     assume z_Hcn:"(?z_hcl~=?z_hbm)"
     show FALSE
     proof (rule zenon_noteq [of "?z_hbm"])
      have z_Hco: "(isa'dotdot(1, (CHOOSE zenon_Vxa:((zenon_Vxa \\in Nat)&(?z_hbu=FuncSet(isa'dotdot(1, zenon_Vxa), (Nat \\ {0}))))))=?z_hbj)" (is "?z_hcp=_")
      proof (rule zenon_nnpp [of "(?z_hcp=?z_hbj)"])
       assume z_Hcq:"(?z_hcp~=?z_hbj)"
       show FALSE
       proof (rule notE [OF z_Hcq])
        have z_Hcr: "(?z_hbi=?z_hcp)"
        proof (rule zenon_nnpp [of "(?z_hbi=?z_hcp)"])
         assume z_Hcs:"(?z_hbi~=?z_hcp)"
         show FALSE
         proof (rule zenon_em [of "(?z_hcp=?z_hcp)"])
          assume z_Hct:"(?z_hcp=?z_hcp)"
          show FALSE
          proof (rule notE [OF z_Hcs])
           have z_Hcu: "(?z_hcp=?z_hbi)"
           proof (rule zenon_nnpp [of "(?z_hcp=?z_hbi)"])
            assume z_Hcv:"(?z_hcp~=?z_hbi)"
            have z_Hcw: "(\\A zenon_Vpd:((zenon_Vpd \\in ?z_hbu)<=>(zenon_Vpd \\in ?z_hcl)))" (is "\\A x : ?z_hdb(x)")
            by (rule zenon_setequal_0 [of "?z_hbu" "?z_hcl", OF z_Hck])
            have z_Hdc: "?z_hdb((a_ca[''sigma'']))" (is "_<=>?z_hdd")
            by (rule zenon_all_0 [of "?z_hdb" "(a_ca[''sigma''])", OF z_Hcw])
            show FALSE
            proof (rule zenon_equiv [OF z_Hdc])
             assume z_Hde:"(~?z_hbw)"
             assume z_Hdf:"(~?z_hdd)"
             show FALSE
             by (rule notE [OF z_Hde z_Hbw])
            next
             assume z_Hbw:"?z_hbw"
             assume z_Hdd:"?z_hdd"
             have z_Hcr: "(?z_hbi=?z_hcp)"
             by (rule zenon_in_funcset_1 [of "(a_ca[''sigma''])" "?z_hcp" "(Nat \\ {0})", OF z_Hdd])
             show FALSE
             by (rule zenon_eqsym [OF z_Hcr z_Hcv])
            qed
           qed
           have z_Hcr: "(?z_hbi=?z_hcp)"
           by (rule subst [where P="(\<lambda>zenon_Vlwf. (zenon_Vlwf=?z_hcp))", OF z_Hcu], fact z_Hct)
           thus "(?z_hbi=?z_hcp)" .
          qed
         next
          assume z_Hdj:"(?z_hcp~=?z_hcp)"
          show FALSE
          by (rule zenon_noteq [OF z_Hdj])
         qed
        qed
        have z_Hco: "(?z_hcp=?z_hbj)"
        by (rule subst [where P="(\<lambda>zenon_Vmwf. (zenon_Vmwf=?z_hbj))", OF z_Hcr], fact z_Hr)
        thus "(?z_hcp=?z_hbj)" .
       qed
      qed
      have z_Hdn: "(?z_hbm~=?z_hbm)"
      by (rule subst [where P="(\<lambda>zenon_Vjwf. (FuncSet(zenon_Vjwf, (Nat \\ {0}))~=?z_hbm))", OF z_Hco], fact z_Hcn)
      thus "(?z_hbm~=?z_hbm)" .
     qed
    qed
    have z_Hbx: "(?z_hbu=?z_hbm)"
    by (rule subst [where P="(\<lambda>zenon_Vowf. (?z_hbu=zenon_Vowf))", OF z_Hcm], fact z_Hck)
    thus "(?z_hbu=?z_hbm)" .
   qed
  qed
  have z_Hbl: "?z_hbl"
  by (rule subst [where P="(\<lambda>zenon_Vpwf. ((a_ca[''sigma'']) \\in zenon_Vpwf))", OF z_Hbx], fact z_Hbw)
  thus "?z_hbl" .
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 914"; *} qed
lemma ob'1127:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'233: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'234: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'235: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'236: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'237: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'238: "((((a_jhash_primea :: c)) = (j)))"
assumes v'239: "((((a_lhash_primea :: c)) = (l)))"
assumes v'240: "((((a_xhash_primea :: c)) = (x)))"
assumes v'241: "((((a_vhash_primea :: c)) = (v)))"
assumes v'242: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca)) :: c)) & (\<exists> d \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d)) :: c)))) : (\<exists> seq \<in> ((Perm ((S)))) : ((((fapply ((a_ca), (''sigma''))) = ((Concat ((fapply ((d), (''sigma''))), ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (fapply ((v), (fapply ((seq), (k)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (S))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (fapply ((fapply ((d), (''fres''))), (q)))))))))))))))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'245: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'246: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'253: "(((fapply (((a_ihash_primea :: c)), (p))) \<notin> (A)))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
assumes v'272: "((((ValuesMatchInds ((seq), (fapply ((a_ca), (''sigma'')))))) \<and> ((GoodRes ((A), (fapply ((a_ca), (''fres''))))))))"
assumes v'273: "(((a_ca) \<in> ((a_Mhash_primea :: c))))"
assumes v'274: "((h4a197f508dc4c3ceeef6982fc8065d ((A), (fapply ((a_ca), (''fres'')))) :: c))"
assumes v'275: "((((ValuesMatchInds ((seq), (fapply ((a_ca), (''sigma'')))))) = ((a_h5f69bd2035062162153eeb4da53c07a ((seq), (fapply ((a_ca), (''sigma'')))) :: c))))"
shows "(\<exists> a_ca_1 \<in> ((a_Mhash_primea :: c)) : ((((a_h5f69bd2035062162153eeb4da53c07a ((seq), (fapply ((a_ca_1), (''sigma'')))) :: c)) \<and> ((h4a197f508dc4c3ceeef6982fc8065d ((A), (fapply ((a_ca_1), (''fres'')))) :: c)))))"(is "PROP ?ob'1127")
proof -
ML_command {* writeln "*** TLAPS ENTER 1127"; *}
show "PROP ?ob'1127"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_c8be46.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_c8be46.znn.out
;; obligation #1127
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'233" (= (TLA.fapply pc p) "E1")
$hyp "v'234" (= a_pchash_primea
(TLA.except pc p "E2"))
$hyp "v'235" (= a_ihash_primea
(TLA.except i p X))
$hyp "v'236" (= a_Xhash_primea (arith.add X
(TLA.fapply TLA.Succ 0)))
$hyp "v'237" (= a_Qhash_primea Q)
$hyp "v'238" (= a_jhash_primea j)
$hyp "v'239" (= a_lhash_primea l)
$hyp "v'240" (= a_xhash_primea x)
$hyp "v'241" (= a_vhash_primea v)
$hyp "v'242" (= a_Mhash_primea
(TLA.subsetOf CDomain ((a_ca) (/\ (a_h022c5783954683bdcbcacced356fd6a a_ca)
(TLA.bEx M ((d) (TLA.bEx (TLA.SUBSET (hc4e622ce2e33ef1c6a9f10c01956cd d)) ((S) (TLA.bEx (Perm S) ((seq) (/\ (= (TLA.fapply a_ca "sigma")
(Concat (TLA.fapply d "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.fapply v (TLA.fapply seq k))))))
(TLA.bAll ProcSet ((q) (TLA.cond (TLA.in q
S) (= (TLA.fapply (TLA.fapply a_ca "fres") q)
ACK) (= (TLA.fapply (TLA.fapply a_ca "fres") q)
(TLA.fapply (TLA.fapply d "fres") q))))))))))))))))
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'245" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'246" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'253" (-. (TLA.in (TLA.fapply a_ihash_primea p)
A))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'272" (/\ (ValuesMatchInds seq (TLA.fapply a_ca "sigma")) (GoodRes A
(TLA.fapply a_ca "fres")))
$hyp "v'273" (TLA.in a_ca
a_Mhash_primea)
$hyp "v'274" (h4a197f508dc4c3ceeef6982fc8065d A
(TLA.fapply a_ca "fres"))
$hyp "v'275" (= (ValuesMatchInds seq (TLA.fapply a_ca "sigma"))
(a_h5f69bd2035062162153eeb4da53c07a seq
(TLA.fapply a_ca "sigma")))
$goal (TLA.bEx a_Mhash_primea ((a_ca_1) (/\ (a_h5f69bd2035062162153eeb4da53c07a seq
(TLA.fapply a_ca_1 "sigma")) (h4a197f508dc4c3ceeef6982fc8065d A
(TLA.fapply a_ca_1 "fres")))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hm:"(a_Mhash_primea=subsetOf(CDomain, (\<lambda>a_ca. (a_h022c5783954683bdcbcacced356fd6a(a_ca)&bEx(M, (\<lambda>d. bEx(SUBSET(hc4e622ce2e33ef1c6a9f10c01956cd(d)), (\<lambda>S. bEx(Perm(S), (\<lambda>seq. (((a_ca[''sigma''])=Concat((d[''sigma'']), Fcn(DOMAIN(seq), (\<lambda>k. (v[(seq[k])])))))&bAll(ProcSet, (\<lambda>q. cond((q \\in S), (((a_ca[''fres''])[q])=ACK), (((a_ca[''fres''])[q])=((d[''fres''])[q]))))))))))))))))" (is "_=?z_hz")
 using v'242 by blast
 have z_Ht:"(ValuesMatchInds(seq, (a_ca[''sigma'']))&GoodRes(A, (a_ca[''fres''])))" (is "?z_hct&?z_hcu")
 using v'272 by blast
 have z_Hw:"(?z_hct=a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma''])))" (is "_=?z_hcw")
 using v'275 by blast
 have z_Hv:"h4a197f508dc4c3ceeef6982fc8065d(A, (a_ca[''fres'']))" (is "?z_hv")
 using v'274 by blast
 have z_Hu:"(a_ca \\in a_Mhash_primea)" (is "?z_hu")
 using v'273 by blast
 assume z_Hx:"(~bEx(a_Mhash_primea, (\<lambda>a_ca_1. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca_1[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(A, (a_ca_1[''fres'']))))))" (is "~?z_hcx")
 have z_Hct: "?z_hct"
 by (rule zenon_and_0 [OF z_Ht])
 have z_Hdf: "(a_ca \\in ?z_hz)" (is "?z_hdf")
 by (rule subst [where P="(\<lambda>zenon_Vj. (a_ca \\in zenon_Vj))", OF z_Hm z_Hu])
 have z_Hdj: "(~bEx(?z_hz, (\<lambda>a_ca_1. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca_1[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(A, (a_ca_1[''fres'']))))))" (is "~?z_hdk")
 by (rule subst [where P="(\<lambda>zenon_Vf. (~bEx(zenon_Vf, (\<lambda>a_ca_1. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca_1[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(A, (a_ca_1[''fres''])))))))", OF z_Hm z_Hx])
 have z_Hdp_z_Hdj: "(~(\\E x:((x \\in ?z_hz)&(a_h5f69bd2035062162153eeb4da53c07a(seq, (x[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(A, (x[''fres''])))))) == (~?z_hdk)" (is "?z_hdp == ?z_hdj")
 by (unfold bEx_def)
 have z_Hdp: "?z_hdp" (is "~(\\E x : ?z_hdz(x))")
 by (unfold z_Hdp_z_Hdj, fact z_Hdj)
 show FALSE
 proof (rule zenon_p_eq_l [of "?z_hct" "?z_hct" "?z_hcw", OF z_Hct z_Hw])
  assume z_Hea:"(?z_hct~=?z_hct)"
  show FALSE
  by (rule zenon_noteq [OF z_Hea])
 next
  assume z_Hcw:"?z_hcw"
  have z_Heb: "~?z_hdz(a_ca)" (is "~(_&?z_hec)")
  by (rule zenon_notex_0 [of "?z_hdz" "a_ca", OF z_Hdp])
  show FALSE
  proof (rule zenon_notand [OF z_Heb])
   assume z_Hed:"(~?z_hdf)"
   show FALSE
   by (rule notE [OF z_Hed z_Hdf])
  next
   assume z_Hee:"(~?z_hec)"
   show FALSE
   proof (rule zenon_notand [OF z_Hee])
    assume z_Hef:"(~?z_hcw)"
    show FALSE
    by (rule notE [OF z_Hef z_Hcw])
   next
    assume z_Heg:"(~?z_hv)"
    show FALSE
    by (rule notE [OF z_Heg z_Hv])
   qed
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1127"; *} qed
lemma ob'1124:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (\<forall> A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0]))))))))))))) : ((((GoodEnqSet ((A)))) \<Rightarrow> (\<forall> seq \<in> ((Perm ((A)))) : ((((JInvSeq ((seq)))) \<Rightarrow> (\<exists> a_ca \<in> (M) : (((ValuesMatchInds ((seq), (fapply ((a_ca), (''sigma'')))))) & ((GoodRes ((A), (fapply ((a_ca), (''fres''))))))))))))))) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'232: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'233: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'234: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'235: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'236: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'237: "((((a_jhash_primea :: c)) = (j)))"
assumes v'238: "((((a_lhash_primea :: c)) = (l)))"
assumes v'239: "((((a_xhash_primea :: c)) = (x)))"
assumes v'240: "((((a_vhash_primea :: c)) = (v)))"
assumes v'241: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca)) :: c)) & (\<exists> d \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d)) :: c)))) : (\<exists> seq \<in> ((Perm ((S)))) : ((((fapply ((a_ca), (''sigma''))) = ((Concat ((fapply ((d), (''sigma''))), ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (fapply ((v), (fapply ((seq), (k)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (S))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (fapply ((fapply ((d), (''fres''))), (q)))))))))))))))))"
assumes v'242: "((\<And> A :: c. A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))) \<Longrightarrow> (\<And> seq :: c. seq \<in> ((Perm ((A)))) \<Longrightarrow> (((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c)) \<Longrightarrow> (((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c)) \<Longrightarrow> (\<exists> a_ca \<in> ((a_Mhash_primea :: c)) : ((((a_h5f69bd2035062162153eeb4da53c07a ((seq), (fapply ((a_ca), (''sigma'')))) :: c)) \<and> ((h4a197f508dc4c3ceeef6982fc8065d ((A), (fapply ((a_ca), (''fres'')))) :: c))))))))))"
shows "(\<forall> A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))) : ((((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c)) \<Rightarrow> (\<forall> seq \<in> ((Perm ((A)))) : ((((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c)) \<Rightarrow> (\<exists> a_ca \<in> ((a_Mhash_primea :: c)) : (((a_h5f69bd2035062162153eeb4da53c07a ((seq), (fapply ((a_ca), (''sigma'')))) :: c)) & ((h4a197f508dc4c3ceeef6982fc8065d ((A), (fapply ((a_ca), (''fres'')))) :: c))))))))))"(is "PROP ?ob'1124")
proof -
ML_command {* writeln "*** TLAPS ENTER 1124"; *}
show "PROP ?ob'1124"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_e6155e.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_e6155e.znn.out
;; obligation #1124
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa
(TLA.bAll (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0) (arith.add X
(arith.minus (TLA.fapply TLA.Succ 0))))) ((A) (=> (GoodEnqSet A)
(TLA.bAll (Perm A) ((seq) (=> (JInvSeq seq)
(TLA.bEx M ((a_ca) (/\ (ValuesMatchInds seq (TLA.fapply a_ca "sigma"))
(GoodRes A (TLA.fapply a_ca "fres")))))))))))) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'232" (= (TLA.fapply pc p) "E1")
$hyp "v'233" (= a_pchash_primea
(TLA.except pc p "E2"))
$hyp "v'234" (= a_ihash_primea
(TLA.except i p X))
$hyp "v'235" (= a_Xhash_primea (arith.add X
(TLA.fapply TLA.Succ 0)))
$hyp "v'236" (= a_Qhash_primea Q)
$hyp "v'237" (= a_jhash_primea j)
$hyp "v'238" (= a_lhash_primea l)
$hyp "v'239" (= a_xhash_primea x)
$hyp "v'240" (= a_vhash_primea v)
$hyp "v'241" (= a_Mhash_primea
(TLA.subsetOf CDomain ((a_ca) (/\ (a_h022c5783954683bdcbcacced356fd6a a_ca)
(TLA.bEx M ((d) (TLA.bEx (TLA.SUBSET (hc4e622ce2e33ef1c6a9f10c01956cd d)) ((S) (TLA.bEx (Perm S) ((seq) (/\ (= (TLA.fapply a_ca "sigma")
(Concat (TLA.fapply d "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.fapply v (TLA.fapply seq k))))))
(TLA.bAll ProcSet ((q) (TLA.cond (TLA.in q
S) (= (TLA.fapply (TLA.fapply a_ca "fres") q)
ACK) (= (TLA.fapply (TLA.fapply a_ca "fres") q)
(TLA.fapply (TLA.fapply d "fres") q))))))))))))))))
$hyp "v'242" (TLA.bAll (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))) ((A) (TLA.bAll (Perm A) ((seq) (=> (a_h809dcbde4a0ebaffb04edba90d34c1a A) (=> (a_h76227835d3f4b8a2f4a94c89f14166a seq) (TLA.bEx a_Mhash_primea ((a_ca) (/\ (a_h5f69bd2035062162153eeb4da53c07a seq
(TLA.fapply a_ca "sigma")) (h4a197f508dc4c3ceeef6982fc8065d A
(TLA.fapply a_ca "fres")))))))))))
$goal (TLA.bAll (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))) ((A) (=> (a_h809dcbde4a0ebaffb04edba90d34c1a A)
(TLA.bAll (Perm A) ((seq) (=> (a_h76227835d3f4b8a2f4a94c89f14166a seq)
(TLA.bEx a_Mhash_primea ((a_ca) (/\ (a_h5f69bd2035062162153eeb4da53c07a seq
(TLA.fapply a_ca "sigma")) (h4a197f508dc4c3ceeef6982fc8065d A
(TLA.fapply a_ca "fres")))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hg:"(a_Xhash_primea=(X + 1))" (is "_=?z_hq")
 using v'235 by blast
 have z_Hn:"bAll(SUBSET(isa'dotdot(1, (a_Xhash_primea +  -.(1)))), (\<lambda>A. bAll(Perm(A), (\<lambda>seq. (a_h809dcbde4a0ebaffb04edba90d34c1a(A)=>(a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(A, (a_ca[''fres''])))))))))))" (is "?z_hn")
 using v'242 by blast
 assume z_Ho:"(~bAll(SUBSET(isa'dotdot(1, (a_Xhash_primea +  -.(1)))), (\<lambda>A. (a_h809dcbde4a0ebaffb04edba90d34c1a(A)=>bAll(Perm(A), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(A, (a_ca[''fres'']))))))))))))" (is "~?z_hbs")
 have z_Hbx_z_Hn: "(\\A x:((x \\in SUBSET(isa'dotdot(1, (a_Xhash_primea +  -.(1)))))=>bAll(Perm(x), (\<lambda>seq. (a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>(a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres'']))))))))))) == ?z_hn" (is "?z_hbx == _")
 by (unfold bAll_def)
 have z_Hbx: "?z_hbx" (is "\\A x : ?z_hcl(x)")
 by (unfold z_Hbx_z_Hn, fact z_Hn)
 have z_Hcm: "(~bAll(SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))), (\<lambda>A. (a_h809dcbde4a0ebaffb04edba90d34c1a(A)=>bAll(Perm(A), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(A, (a_ca[''fres'']))))))))))))" (is "~?z_hcn")
 by (rule subst [where P="(\<lambda>zenon_Vxs. (~bAll(SUBSET(isa'dotdot(1, (zenon_Vxs +  -.(1)))), (\<lambda>A. (a_h809dcbde4a0ebaffb04edba90d34c1a(A)=>bAll(Perm(A), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(A, (a_ca[''fres''])))))))))))))", OF z_Hg z_Ho])
 have z_Hcy_z_Hcm: "(~(\\A x:((x \\in SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))))=>(a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>bAll(Perm(x), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres''])))))))))))) == (~?z_hcn)" (is "?z_hcy == ?z_hcm")
 by (unfold bAll_def)
 have z_Hcy: "?z_hcy" (is "~(\\A x : ?z_hdf(x))")
 by (unfold z_Hcy_z_Hcm, fact z_Hcm)
 have z_Hdg: "(\\E x:(~((x \\in SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))))=>(a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>bAll(Perm(x), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres'']))))))))))))" (is "\\E x : ?z_hdi(x)")
 by (rule zenon_notallex_0 [of "?z_hdf", OF z_Hcy])
 have z_Hdj: "?z_hdi((CHOOSE x:(~((x \\in SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))))=>(a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>bAll(Perm(x), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres''])))))))))))))" (is "~(?z_hdl=>?z_hdm)")
 by (rule zenon_ex_choose_0 [of "?z_hdi", OF z_Hdg])
 have z_Hdl: "?z_hdl"
 by (rule zenon_notimply_0 [OF z_Hdj])
 have z_Hdn: "(~?z_hdm)" (is "~(?z_hdo=>?z_hdp)")
 by (rule zenon_notimply_1 [OF z_Hdj])
 have z_Hdo: "?z_hdo"
 by (rule zenon_notimply_0 [OF z_Hdn])
 have z_Hdq: "(~?z_hdp)"
 by (rule zenon_notimply_1 [OF z_Hdn])
 have z_Hdr: "((CHOOSE x:(~((x \\in SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))))=>(a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>bAll(Perm(x), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres''])))))))))))) \\subseteq isa'dotdot(1, (?z_hq +  -.(1))))" (is "?z_hdr")
 by (rule zenon_in_SUBSET_0 [of "(CHOOSE x:(~((x \\in SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))))=>(a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>bAll(Perm(x), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres'']))))))))))))" "isa'dotdot(1, (?z_hq +  -.(1)))", OF z_Hdl])
 have z_Hds_z_Hdq: "(~(\\A x:((x \\in Perm((CHOOSE x:(~((x \\in SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))))=>(a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>bAll(Perm(x), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres'']))))))))))))))=>(a_h76227835d3f4b8a2f4a94c89f14166a(x)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(x, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d((CHOOSE x:(~((x \\in SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))))=>(a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>bAll(Perm(x), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres''])))))))))))), (a_ca[''fres'']))))))))) == (~?z_hdp)" (is "?z_hds == ?z_hdq")
 by (unfold bAll_def)
 have z_Hds: "?z_hds" (is "~(\\A x : ?z_hee(x))")
 by (unfold z_Hds_z_Hdq, fact z_Hdq)
 have z_Hef: "(\\E x:(~((x \\in Perm((CHOOSE x:(~((x \\in SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))))=>(a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>bAll(Perm(x), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres'']))))))))))))))=>(a_h76227835d3f4b8a2f4a94c89f14166a(x)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(x, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d((CHOOSE x:(~((x \\in SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))))=>(a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>bAll(Perm(x), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres''])))))))))))), (a_ca[''fres''])))))))))" (is "\\E x : ?z_heh(x)")
 by (rule zenon_notallex_0 [of "?z_hee", OF z_Hds])
 have z_Hei: "?z_heh((CHOOSE x:(~((x \\in Perm((CHOOSE x:(~((x \\in SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))))=>(a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>bAll(Perm(x), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres'']))))))))))))))=>(a_h76227835d3f4b8a2f4a94c89f14166a(x)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(x, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d((CHOOSE x:(~((x \\in SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))))=>(a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>bAll(Perm(x), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres''])))))))))))), (a_ca[''fres'']))))))))))" (is "~(?z_hek=>?z_hel)")
 by (rule zenon_ex_choose_0 [of "?z_heh", OF z_Hef])
 have z_Hek: "?z_hek"
 by (rule zenon_notimply_0 [OF z_Hei])
 have z_Hem: "(~?z_hel)" (is "~(?z_hen=>?z_heo)")
 by (rule zenon_notimply_1 [OF z_Hei])
 have z_Hen: "?z_hen"
 by (rule zenon_notimply_0 [OF z_Hem])
 have z_Hep: "(~?z_heo)"
 by (rule zenon_notimply_1 [OF z_Hem])
 have z_Heq: "?z_hcl((CHOOSE x:(~((x \\in SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))))=>(a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>bAll(Perm(x), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres''])))))))))))))" (is "?z_her=>?z_hes")
 by (rule zenon_all_0 [of "?z_hcl" "(CHOOSE x:(~((x \\in SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))))=>(a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>bAll(Perm(x), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres'']))))))))))))", OF z_Hbx])
 show FALSE
 proof (rule zenon_imply [OF z_Heq])
  assume z_Het:"(~?z_her)"
  have z_Heu: "(~((CHOOSE x:(~((x \\in SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))))=>(a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>bAll(Perm(x), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres''])))))))))))) \\subseteq isa'dotdot(1, (a_Xhash_primea +  -.(1)))))" (is "~?z_hev")
  by (rule zenon_notin_SUBSET_0 [of "(CHOOSE x:(~((x \\in SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))))=>(a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>bAll(Perm(x), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres'']))))))))))))" "isa'dotdot(1, (a_Xhash_primea +  -.(1)))", OF z_Het])
  have z_Hew: "(~?z_hdr)"
  by (rule subst [where P="(\<lambda>zenon_Vls. (~((CHOOSE x:(~((x \\in SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))))=>(a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>bAll(Perm(x), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres''])))))))))))) \\subseteq isa'dotdot(1, (zenon_Vls +  -.(1))))))", OF z_Hg z_Heu])
  show FALSE
  by (rule notE [OF z_Hew z_Hdr])
 next
  assume z_Hes:"?z_hes"
  have z_Hfd_z_Hes: "(\\A x:((x \\in Perm((CHOOSE x:(~((x \\in SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))))=>(a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>bAll(Perm(x), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres'']))))))))))))))=>(?z_hdo=>(a_h76227835d3f4b8a2f4a94c89f14166a(x)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(x, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d((CHOOSE x:(~((x \\in SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))))=>(a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>bAll(Perm(x), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres''])))))))))))), (a_ca[''fres'']))))))))) == ?z_hes" (is "?z_hfd == _")
  by (unfold bAll_def)
  have z_Hfd: "?z_hfd" (is "\\A x : ?z_hfg(x)")
  by (unfold z_Hfd_z_Hes, fact z_Hes)
  have z_Hfh: "?z_hfg((CHOOSE x:(~((x \\in Perm((CHOOSE x:(~((x \\in SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))))=>(a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>bAll(Perm(x), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres'']))))))))))))))=>(a_h76227835d3f4b8a2f4a94c89f14166a(x)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(x, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d((CHOOSE x:(~((x \\in SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))))=>(a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>bAll(Perm(x), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres''])))))))))))), (a_ca[''fres'']))))))))))" (is "_=>?z_hfi")
  by (rule zenon_all_0 [of "?z_hfg" "(CHOOSE x:(~((x \\in Perm((CHOOSE x:(~((x \\in SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))))=>(a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>bAll(Perm(x), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres'']))))))))))))))=>(a_h76227835d3f4b8a2f4a94c89f14166a(x)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(x, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d((CHOOSE x:(~((x \\in SUBSET(isa'dotdot(1, (?z_hq +  -.(1)))))=>(a_h809dcbde4a0ebaffb04edba90d34c1a(x)=>bAll(Perm(x), (\<lambda>seq. (a_h76227835d3f4b8a2f4a94c89f14166a(seq)=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(x, (a_ca[''fres''])))))))))))), (a_ca[''fres''])))))))))", OF z_Hfd])
  show FALSE
  proof (rule zenon_imply [OF z_Hfh])
   assume z_Hfj:"(~?z_hek)"
   show FALSE
   by (rule notE [OF z_Hfj z_Hek])
  next
   assume z_Hfi:"?z_hfi"
   show FALSE
   proof (rule zenon_imply [OF z_Hfi])
    assume z_Hfk:"(~?z_hdo)"
    show FALSE
    by (rule notE [OF z_Hfk z_Hdo])
   next
    assume z_Hel:"?z_hel"
    show FALSE
    proof (rule zenon_imply [OF z_Hel])
     assume z_Hfl:"(~?z_hen)"
     show FALSE
     by (rule notE [OF z_Hfl z_Hen])
    next
     assume z_Heo:"?z_heo"
     show FALSE
     by (rule notE [OF z_Hep z_Heo])
    qed
   qed
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1124"; *} qed
lemma ob'1119:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'233: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'234: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'235: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'236: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'237: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'238: "((((a_jhash_primea :: c)) = (j)))"
assumes v'239: "((((a_lhash_primea :: c)) = (l)))"
assumes v'240: "((((a_xhash_primea :: c)) = (x)))"
assumes v'241: "((((a_vhash_primea :: c)) = (v)))"
assumes v'242: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca)) :: c)) & (\<exists> d \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d)) :: c)))) : (\<exists> seq \<in> ((Perm ((S)))) : ((((fapply ((a_ca), (''sigma''))) = ((Concat ((fapply ((d), (''sigma''))), ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (fapply ((v), (fapply ((seq), (k)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (S))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (fapply ((fapply ((d), (''fres''))), (q)))))))))))))))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'245: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'246: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'253: "(((((fapply (((a_ihash_primea :: c)), (p))) \<notin> (A))) \<Longrightarrow> (\<exists> a_ca \<in> ((a_Mhash_primea :: c)) : ((((a_h5f69bd2035062162153eeb4da53c07a ((seq), (fapply ((a_ca), (''sigma'')))) :: c)) \<and> ((h4a197f508dc4c3ceeef6982fc8065d ((A), (fapply ((a_ca), (''fres'')))) :: c)))))))"
assumes v'254: "(((((fapply (((a_ihash_primea :: c)), (p))) \<in> (A))) \<Longrightarrow> (\<exists> a_ca \<in> ((a_Mhash_primea :: c)) : ((((a_h5f69bd2035062162153eeb4da53c07a ((seq), (fapply ((a_ca), (''sigma'')))) :: c)) \<and> ((h4a197f508dc4c3ceeef6982fc8065d ((A), (fapply ((a_ca), (''fres'')))) :: c)))))))"
shows "(\<exists> a_ca \<in> ((a_Mhash_primea :: c)) : ((((a_h5f69bd2035062162153eeb4da53c07a ((seq), (fapply ((a_ca), (''sigma'')))) :: c)) \<and> ((h4a197f508dc4c3ceeef6982fc8065d ((A), (fapply ((a_ca), (''fres'')))) :: c)))))"(is "PROP ?ob'1119")
proof -
ML_command {* writeln "*** TLAPS ENTER 1119"; *}
show "PROP ?ob'1119"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_acd620.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_acd620.znn.out
;; obligation #1119
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'233" (= (TLA.fapply pc p) "E1")
$hyp "v'234" (= a_pchash_primea
(TLA.except pc p "E2"))
$hyp "v'235" (= a_ihash_primea
(TLA.except i p X))
$hyp "v'236" (= a_Xhash_primea (arith.add X
(TLA.fapply TLA.Succ 0)))
$hyp "v'237" (= a_Qhash_primea Q)
$hyp "v'238" (= a_jhash_primea j)
$hyp "v'239" (= a_lhash_primea l)
$hyp "v'240" (= a_xhash_primea x)
$hyp "v'241" (= a_vhash_primea v)
$hyp "v'242" (= a_Mhash_primea
(TLA.subsetOf CDomain ((a_ca) (/\ (a_h022c5783954683bdcbcacced356fd6a a_ca)
(TLA.bEx M ((d) (TLA.bEx (TLA.SUBSET (hc4e622ce2e33ef1c6a9f10c01956cd d)) ((S) (TLA.bEx (Perm S) ((seq) (/\ (= (TLA.fapply a_ca "sigma")
(Concat (TLA.fapply d "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.fapply v (TLA.fapply seq k))))))
(TLA.bAll ProcSet ((q) (TLA.cond (TLA.in q
S) (= (TLA.fapply (TLA.fapply a_ca "fres") q)
ACK) (= (TLA.fapply (TLA.fapply a_ca "fres") q)
(TLA.fapply (TLA.fapply d "fres") q))))))))))))))))
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'245" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'246" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'253" (=> (-. (TLA.in (TLA.fapply a_ihash_primea p)
A)) (TLA.bEx a_Mhash_primea ((a_ca) (/\ (a_h5f69bd2035062162153eeb4da53c07a seq
(TLA.fapply a_ca "sigma")) (h4a197f508dc4c3ceeef6982fc8065d A
(TLA.fapply a_ca "fres"))))))
$hyp "v'254" (=> (TLA.in (TLA.fapply a_ihash_primea p)
A) (TLA.bEx a_Mhash_primea ((a_ca) (/\ (a_h5f69bd2035062162153eeb4da53c07a seq
(TLA.fapply a_ca "sigma")) (h4a197f508dc4c3ceeef6982fc8065d A
(TLA.fapply a_ca "fres"))))))
$goal (TLA.bEx a_Mhash_primea ((a_ca) (/\ (a_h5f69bd2035062162153eeb4da53c07a seq
(TLA.fapply a_ca "sigma")) (h4a197f508dc4c3ceeef6982fc8065d A
(TLA.fapply a_ca "fres")))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hr:"((~((a_ihash_primea[p]) \\in A))=>bEx(a_Mhash_primea, (\<lambda>a_ca. (a_h5f69bd2035062162153eeb4da53c07a(seq, (a_ca[''sigma'']))&h4a197f508dc4c3ceeef6982fc8065d(A, (a_ca[''fres'']))))))" (is "?z_hu=>?z_hba")
 using v'253 by blast
 have z_Hs:"(((a_ihash_primea[p]) \\in A)=>?z_hba)" (is "?z_hv=>_")
 using v'254 by blast
 assume z_Ht:"(~?z_hba)"
 show FALSE
 proof (rule zenon_imply [OF z_Hr])
  assume z_Hbm:"(~?z_hu)"
  have z_Hv: "?z_hv"
  by (rule zenon_notnot_0 [OF z_Hbm])
  show FALSE
  proof (rule zenon_imply [OF z_Hs])
   assume z_Hu:"?z_hu"
   show FALSE
   by (rule notE [OF z_Hu z_Hv])
  next
   assume z_Hba:"?z_hba"
   show FALSE
   by (rule notE [OF z_Ht z_Hba])
  qed
 next
  assume z_Hba:"?z_hba"
  show FALSE
  by (rule notE [OF z_Ht z_Hba])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1119"; *} qed
lemma ob'1181:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'233: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'234: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'235: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'236: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'237: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'238: "((((a_jhash_primea :: c)) = (j)))"
assumes v'239: "((((a_lhash_primea :: c)) = (l)))"
assumes v'240: "((((a_xhash_primea :: c)) = (x)))"
assumes v'241: "((((a_vhash_primea :: c)) = (v)))"
assumes v'242: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca)) :: c)) & (\<exists> d \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d)) :: c)))) : (\<exists> seq \<in> ((Perm ((S)))) : ((((fapply ((a_ca), (''sigma''))) = ((Concat ((fapply ((d), (''sigma''))), ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (fapply ((v), (fapply ((seq), (k)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (S))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (fapply ((fapply ((d), (''fres''))), (q)))))))))))))))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'245: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'246: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'253: "(((fapply (((a_ihash_primea :: c)), (p))) \<notin> (A)))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
assumes v'274: "((\<And> k :: c. k \<in> ((DOMAIN (seq))) \<Longrightarrow> (((fapply (([ k_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k_1)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k_1)))))))))))))]), (k))) = (fapply (([ k_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k_1))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k_1)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k_1)))))))))))))]), (k)))))))"
shows "((([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k)))))))))))))]) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k)))))))))))))])))"(is "PROP ?ob'1181")
proof -
ML_command {* writeln "*** TLAPS ENTER 1181"; *}
show "PROP ?ob'1181"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_730b0d.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_730b0d.znn.out
;; obligation #1181
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'233" (= (TLA.fapply pc p) "E1")
$hyp "v'234" (= a_pchash_primea
(TLA.except pc p "E2"))
$hyp "v'235" (= a_ihash_primea
(TLA.except i p X))
$hyp "v'236" (= a_Xhash_primea (arith.add X
(TLA.fapply TLA.Succ 0)))
$hyp "v'237" (= a_Qhash_primea Q)
$hyp "v'238" (= a_jhash_primea j)
$hyp "v'239" (= a_lhash_primea l)
$hyp "v'240" (= a_xhash_primea x)
$hyp "v'241" (= a_vhash_primea v)
$hyp "v'242" (= a_Mhash_primea
(TLA.subsetOf CDomain ((a_ca) (/\ (a_h022c5783954683bdcbcacced356fd6a a_ca)
(TLA.bEx M ((d) (TLA.bEx (TLA.SUBSET (hc4e622ce2e33ef1c6a9f10c01956cd d)) ((S) (TLA.bEx (Perm S) ((seq) (/\ (= (TLA.fapply a_ca "sigma")
(Concat (TLA.fapply d "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.fapply v (TLA.fapply seq k))))))
(TLA.bAll ProcSet ((q) (TLA.cond (TLA.in q
S) (= (TLA.fapply (TLA.fapply a_ca "fres") q)
ACK) (= (TLA.fapply (TLA.fapply a_ca "fres") q)
(TLA.fapply (TLA.fapply d "fres") q))))))))))))))))
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'245" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'246" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'253" (-. (TLA.in (TLA.fapply a_ihash_primea p)
A))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'274" (TLA.bAll (TLA.DOMAIN seq) ((k) (= (TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((k_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k_1))
BOT)) (TLA.fapply Q (TLA.fapply seq k_1)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k_1))))))))) k)
(TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((k_1) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k_1))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k_1)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k_1))))))))) k))))
$goal (= (TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k)))))))))
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Ht:"bAll(DOMAIN(seq), (\<lambda>k. ((Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))]))))[k])=(Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))]))))[k]))))" (is "?z_ht")
 using v'274 by blast
 assume z_Hu:"(Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))]))))~=Fcn(DOMAIN(seq), (\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))))" (is "?z_hba~=?z_hbz")
 have z_Hcq: "(~(((isAFcn(?z_hba)&isAFcn(?z_hbz))&(DOMAIN(?z_hba)=DOMAIN(?z_hbz)))&(\\A zenon_Vi:((zenon_Vi \\in DOMAIN(?z_hbz))=>((?z_hba[zenon_Vi])=(?z_hbz[zenon_Vi]))))))" (is "~(?z_hcs&?z_hcz)")
 by (rule zenon_notfunequal_0 [of "?z_hba" "?z_hbz", OF z_Hu])
 show FALSE
 proof (rule zenon_notand [OF z_Hcq])
  assume z_Hdg:"(~?z_hcs)" (is "~(?z_hct&?z_hcw)")
  show FALSE
  proof (rule zenon_notand [OF z_Hdg])
   assume z_Hdh:"(~?z_hct)" (is "~(?z_hcu&?z_hcv)")
   show FALSE
   proof (rule zenon_notand [OF z_Hdh])
    assume z_Hdi:"(~?z_hcu)"
    show FALSE
    by (rule zenon_notisafcn_fcn [of "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))])))", OF z_Hdi])
   next
    assume z_Hdj:"(~?z_hcv)"
    show FALSE
    by (rule zenon_notisafcn_fcn [of "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdj])
   qed
  next
   assume z_Hdk:"(DOMAIN(?z_hba)~=DOMAIN(?z_hbz))" (is "?z_hcx~=?z_hcy")
   have z_Hdl: "(DOMAIN(seq)~=?z_hcy)" (is "?z_hv~=_")
   by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vgz. (zenon_Vgz~=?z_hcy))" "?z_hv" "(\<lambda>k_1. (CASE ((Q[(seq[k_1])])~=BOT) -> (Q[(seq[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[k_1])))))])))", OF z_Hdk])
   have z_Hdp: "(?z_hv~=?z_hv)"
   by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vsy. (?z_hv~=zenon_Vsy))" "?z_hv" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hdl])
   show FALSE
   by (rule zenon_noteq [OF z_Hdp])
  qed
 next
  assume z_Hdt:"(~?z_hcz)" (is "~(\\A x : ?z_hdu(x))")
  have z_Hdv: "(\\E zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbz))=>((?z_hba[zenon_Vi])=(?z_hbz[zenon_Vi])))))" (is "\\E x : ?z_hdx(x)")
  by (rule zenon_notallex_0 [of "?z_hdu", OF z_Hdt])
  have z_Hdy: "?z_hdx((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbz))=>((?z_hba[zenon_Vi])=(?z_hbz[zenon_Vi]))))))" (is "~(?z_hea=>?z_heb)")
  by (rule zenon_ex_choose_0 [of "?z_hdx", OF z_Hdv])
  have z_Hea: "?z_hea"
  by (rule zenon_notimply_0 [OF z_Hdy])
  have z_Hec: "((?z_hba[(CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbz))=>((?z_hba[zenon_Vi])=(?z_hbz[zenon_Vi])))))])~=(?z_hbz[(CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbz))=>((?z_hba[zenon_Vi])=(?z_hbz[zenon_Vi])))))]))" (is "?z_hed~=?z_hee")
  by (rule zenon_notimply_1 [OF z_Hdy])
  have z_Hef: "((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbz))=>((?z_hba[zenon_Vi])=(?z_hbz[zenon_Vi]))))) \\in DOMAIN(seq))" (is "?z_hef")
  by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vpg. ((CHOOSE zenon_Vi:(~((zenon_Vi \\in DOMAIN(?z_hbz))=>((?z_hba[zenon_Vi])=(?z_hbz[zenon_Vi]))))) \\in zenon_Vpg))" "DOMAIN(seq)" "(\<lambda>k_1. (CASE ((a_Qhash_primea[(seq[k_1])])~=BOT) -> (a_Qhash_primea[(seq[k_1])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k_1])))))])))", OF z_Hea])
  have z_Heb: "?z_heb"
  by (rule zenon_all_in_0 [of "DOMAIN(seq)" "(\<lambda>k. ((?z_hba[k])=(?z_hbz[k])))", OF z_Ht z_Hef])
  show FALSE
  by (rule notE [OF z_Hec z_Heb])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1181"; *} qed
lemma ob'1174:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'232: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'233: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'234: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'235: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'236: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'237: "((((a_jhash_primea :: c)) = (j)))"
assumes v'238: "((((a_lhash_primea :: c)) = (l)))"
assumes v'239: "((((a_xhash_primea :: c)) = (x)))"
assumes v'240: "((((a_vhash_primea :: c)) = (v)))"
assumes v'241: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca)) :: c)) & (\<exists> d \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d)) :: c)))) : (\<exists> seq \<in> ((Perm ((S)))) : ((((fapply ((a_ca), (''sigma''))) = ((Concat ((fapply ((d), (''sigma''))), ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (fapply ((v), (fapply ((seq), (k)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (S))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (fapply ((fapply ((d), (''fres''))), (q)))))))))))))))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'244: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'245: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'252: "(((fapply (((a_ihash_primea :: c)), (p))) \<notin> (A)))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
assumes v'273: "((GoodRes ((A), (fapply ((a_ca), (''fres''))))))"
assumes v'274: "(((fapply ((a_ca), (''sigma''))) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply ((pc), (q))) = (''E2''))) \<and> (((fapply ((i), (q))) = (fapply ((seq), (k)))))))))))))])))"
assumes v'275: "((([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (k)))))))))))))]) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %r. (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (k)))))))))))))])))"
shows "(((((fapply ((a_ca), (''sigma''))) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (k)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply ((pc), (q))) = (''E2''))) \<and> (((fapply ((i), (q))) = (fapply ((seq), (k)))))))))))))]))) = (((fapply ((a_ca), (''sigma''))) = ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k))))) \<noteq> (BOT)))>>,<<(fapply (((a_Qhash_primea :: c)), (fapply ((seq), (k)))))>>,(fapply (((a_vhash_primea :: c)), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (k)))))))))))))])))))"(is "PROP ?ob'1174")
proof -
ML_command {* writeln "*** TLAPS ENTER 1174"; *}
show "PROP ?ob'1174"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_074ea6.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_074ea6.znn.out
;; obligation #1174
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'232" (= (TLA.fapply pc p) "E1")
$hyp "v'233" (= a_pchash_primea
(TLA.except pc p "E2"))
$hyp "v'234" (= a_ihash_primea
(TLA.except i p X))
$hyp "v'235" (= a_Xhash_primea (arith.add X
(TLA.fapply TLA.Succ 0)))
$hyp "v'236" (= a_Qhash_primea Q)
$hyp "v'237" (= a_jhash_primea j)
$hyp "v'238" (= a_lhash_primea l)
$hyp "v'239" (= a_xhash_primea x)
$hyp "v'240" (= a_vhash_primea v)
$hyp "v'241" (= a_Mhash_primea
(TLA.subsetOf CDomain ((a_ca) (/\ (a_h022c5783954683bdcbcacced356fd6a a_ca)
(TLA.bEx M ((d) (TLA.bEx (TLA.SUBSET (hc4e622ce2e33ef1c6a9f10c01956cd d)) ((S) (TLA.bEx (Perm S) ((seq) (/\ (= (TLA.fapply a_ca "sigma")
(Concat (TLA.fapply d "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.fapply v (TLA.fapply seq k))))))
(TLA.bAll ProcSet ((q) (TLA.cond (TLA.in q
S) (= (TLA.fapply (TLA.fapply a_ca "fres") q)
ACK) (= (TLA.fapply (TLA.fapply a_ca "fres") q)
(TLA.fapply (TLA.fapply d "fres") q))))))))))))))))
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'244" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'245" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'252" (-. (TLA.in (TLA.fapply a_ihash_primea p)
A))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'273" (GoodRes A
(TLA.fapply a_ca "fres"))
$hyp "v'274" (= (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply pc q)
"E2") (= (TLA.fapply i q)
(TLA.fapply seq k))))))))))
$hyp "v'275" (= (TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r)
"E2") (= (TLA.fapply i r) (TLA.fapply seq k)))))))))
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq k))))))))))
$goal (= (= (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq k))
BOT)) (TLA.fapply Q (TLA.fapply seq k)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply pc q)
"E2") (= (TLA.fapply i q) (TLA.fapply seq k))))))))))
(= (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.CASE (-. (= (TLA.fapply a_Qhash_primea (TLA.fapply seq k))
BOT)) (TLA.fapply a_Qhash_primea (TLA.fapply seq k)) (TLA.fapply a_vhash_primea (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq k)))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hv:"(Fcn(DOMAIN(seq), (\<lambda>k. (CASE ((Q[(seq[k])])~=BOT) -> (Q[(seq[k])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((pc[q])=''E2'')&((i[q])=(seq[k])))))]))))=Fcn(DOMAIN(seq), (\<lambda>k. (CASE ((a_Qhash_primea[(seq[k])])~=BOT) -> (a_Qhash_primea[(seq[k])]) [] OTHER -> (a_vhash_primea[bChoice(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(seq[k])))))])))))" (is "?z_hx=?z_hbw")
 using v'275 by blast
 assume z_Hw:"(((a_ca[''sigma''])=?z_hx)~=((a_ca[''sigma''])=?z_hbw))" (is "?z_hu~=?z_hcr")
 show FALSE
 proof (rule zenon_noteq [of "?z_hcr"])
  have z_Hcs: "(?z_hcr~=?z_hcr)"
  by (rule subst [where P="(\<lambda>zenon_Vkb. (((a_ca[''sigma''])=zenon_Vkb)~=?z_hcr))", OF z_Hv], fact z_Hw)
  thus "(?z_hcr~=?z_hcr)" .
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1174"; *} qed
lemma ob'1200:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'232: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'233: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'234: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'235: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'236: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'237: "((((a_jhash_primea :: c)) = (j)))"
assumes v'238: "((((a_lhash_primea :: c)) = (l)))"
assumes v'239: "((((a_xhash_primea :: c)) = (x)))"
assumes v'240: "((((a_vhash_primea :: c)) = (v)))"
assumes v'241: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca)) :: c)) & (\<exists> d \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d)) :: c)))) : (\<exists> seq \<in> (subsetOf(([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))) \<rightarrow> (S)]), %f. (\<forall> w \<in> (S) : (\<exists> q \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))) : (((fapply ((f), (q))) = (w))))))) : ((((fapply ((a_ca), (''sigma''))) = ((Concat ((fapply ((d), (''sigma''))), ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (fapply ((v), (fapply ((seq), (k)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (S))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (fapply ((fapply ((d), (''fres''))), (q)))))))))))))))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> (subsetOf(([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) \<rightarrow> (A)]), %f. (\<forall> w \<in> (A) : (\<exists> q \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) : (((fapply ((f), (q))) = (w))))))))"
assumes v'244: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'245: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'253: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
assumes v'260: "((((DOMAIN (seq))) = ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A)))))))))"
shows "(\<exists> k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) : (((fapply ((seq), (k))) = (fapply (((a_ihash_primea :: c)), (p))))))"(is "PROP ?ob'1200")
proof -
ML_command {* writeln "*** TLAPS ENTER 1200"; *}
show "PROP ?ob'1200"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_781a61.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_781a61.znn.out
;; obligation #1200
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'232" (= (TLA.fapply pc p) "E1")
$hyp "v'233" (= a_pchash_primea
(TLA.except pc p "E2"))
$hyp "v'234" (= a_ihash_primea
(TLA.except i p X))
$hyp "v'235" (= a_Xhash_primea (arith.add X
(TLA.fapply TLA.Succ 0)))
$hyp "v'236" (= a_Qhash_primea Q)
$hyp "v'237" (= a_jhash_primea j)
$hyp "v'238" (= a_lhash_primea l)
$hyp "v'239" (= a_xhash_primea x)
$hyp "v'240" (= a_vhash_primea v)
$hyp "v'241" (= a_Mhash_primea
(TLA.subsetOf CDomain ((a_ca) (/\ (a_h022c5783954683bdcbcacced356fd6a a_ca)
(TLA.bEx M ((d) (TLA.bEx (TLA.SUBSET (hc4e622ce2e33ef1c6a9f10c01956cd d)) ((S) (TLA.bEx (TLA.subsetOf (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality S)) S) ((f) (TLA.bAll S ((w) (TLA.bEx (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality S)) ((q) (= (TLA.fapply f q)
w))))))) ((seq) (/\ (= (TLA.fapply a_ca "sigma")
(Concat (TLA.fapply d "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.fapply v (TLA.fapply seq k))))))
(TLA.bAll ProcSet ((q) (TLA.cond (TLA.in q
S) (= (TLA.fapply (TLA.fapply a_ca "fres") q)
ACK) (= (TLA.fapply (TLA.fapply a_ca "fres") q)
(TLA.fapply (TLA.fapply d "fres") q))))))))))))))))
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (TLA.subsetOf (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) A) ((f) (TLA.bAll A ((w) (TLA.bEx (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) ((q) (= (TLA.fapply f q)
w))))))))
$hyp "v'244" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'245" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'253" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "v'260" (= (TLA.DOMAIN seq) (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$goal (TLA.bEx (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)) ((k) (= (TLA.fapply seq k)
(TLA.fapply a_ihash_primea p))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Ho:"(seq \\in subsetOf(FuncSet(isa'dotdot(1, Cardinality(A)), A), (\<lambda>f. bAll(A, (\<lambda>w. bEx(isa'dotdot(1, Cardinality(A)), (\<lambda>q. ((f[q])=w))))))))" (is "?z_ho")
 using seq_in by blast
 have z_Hr:"((a_ihash_primea[p]) \\in A)" (is "?z_hr")
 using v'253 by blast
 assume z_Ht:"(~bEx(isa'dotdot(1, Cardinality(A)), (\<lambda>k. ((seq[k])=(a_ihash_primea[p])))))" (is "~?z_hbo")
 have z_Hbt: "bAll(A, (\<lambda>w. bEx(isa'dotdot(1, Cardinality(A)), (\<lambda>q. ((seq[q])=w)))))" (is "?z_hbt")
 by (rule zenon_in_subsetof_1 [of "seq" "FuncSet(isa'dotdot(1, Cardinality(A)), A)" "(\<lambda>f. bAll(A, (\<lambda>w. bEx(isa'dotdot(1, Cardinality(A)), (\<lambda>q. ((f[q])=w))))))", OF z_Ho])
 have z_Hbz_z_Hbt: "(\\A x:((x \\in A)=>bEx(isa'dotdot(1, Cardinality(A)), (\<lambda>q. ((seq[q])=x))))) == ?z_hbt" (is "?z_hbz == _")
 by (unfold bAll_def)
 have z_Hbz: "?z_hbz" (is "\\A x : ?z_hcg(x)")
 by (unfold z_Hbz_z_Hbt, fact z_Hbt)
 have z_Hch: "?z_hcg((a_ihash_primea[p]))"
 by (rule zenon_all_0 [of "?z_hcg" "(a_ihash_primea[p])", OF z_Hbz])
 show FALSE
 proof (rule zenon_imply [OF z_Hch])
  assume z_Hci:"(~?z_hr)"
  show FALSE
  by (rule notE [OF z_Hci z_Hr])
 next
  assume z_Hbo:"?z_hbo"
  show FALSE
  by (rule notE [OF z_Ht z_Hbo])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1200"; *} qed
lemma ob'1195:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "(((((((pc) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & (((X) \<in> (((Nat) \\ ({((0))}))))) & (((Q) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((i) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((j) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((l) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((x) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((v) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((M) \<in> ((SUBSET (subsetOf((CDomain), %a_ca. ((CFTypeOK ((a_ca))))))))))) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'232: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'233: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'234: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'235: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'236: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'237: "((((a_jhash_primea :: c)) = (j)))"
assumes v'238: "((((a_lhash_primea :: c)) = (l)))"
assumes v'239: "((((a_xhash_primea :: c)) = (x)))"
assumes v'240: "((((a_vhash_primea :: c)) = (v)))"
assumes v'241: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca)) :: c)) & (\<exists> d \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d)) :: c)))) : (\<exists> seq \<in> ((Perm ((S)))) : ((((fapply ((a_ca), (''sigma''))) = ((Concat ((fapply ((d), (''sigma''))), ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (fapply ((v), (fapply ((seq), (k)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (S))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (fapply ((fapply ((d), (''fres''))), (q)))))))))))))))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'244: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'245: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'253: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
assumes v'258: "((IsFiniteSet (((isa_peri_peri_a (((Succ[0])), (X)))))))"
assumes v'259: "((\<And> S :: c. (((IsFiniteSet ((S)))) \<Longrightarrow> (\<And> T :: c. T \<in> ((SUBSET (S))) \<Longrightarrow> (((IsFiniteSet ((T)))) & ((leq (((Cardinality ((T)))), ((Cardinality ((S))))))) & ((((((Cardinality ((S)))) = ((Cardinality ((T)))))) \<Rightarrow> (((S) = (T))))))))))"
shows "((IsFiniteSet ((A))))"(is "PROP ?ob'1195")
proof -
ML_command {* writeln "*** TLAPS ENTER 1195"; *}
show "PROP ?ob'1195"
using assms by auto
ML_command {* writeln "*** TLAPS EXIT 1195"; *} qed
lemma ob'1221:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'233: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'234: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'235: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'236: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'237: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'238: "((((a_jhash_primea :: c)) = (j)))"
assumes v'239: "((((a_lhash_primea :: c)) = (l)))"
assumes v'240: "((((a_xhash_primea :: c)) = (x)))"
assumes v'241: "((((a_vhash_primea :: c)) = (v)))"
assumes v'242: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca)) :: c)) & (\<exists> d \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d)) :: c)))) : (\<exists> seq \<in> ((Perm ((S)))) : ((((fapply ((a_ca), (''sigma''))) = ((Concat ((fapply ((d), (''sigma''))), ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (fapply ((v), (fapply ((seq), (k)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (S))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (fapply ((fapply ((d), (''fres''))), (q)))))))))))))))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'245: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'246: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'254: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
assumes v'266: "(\<exists> z \<in> ((isa_peri_peri_a (((arith_add ((k), ((Succ[0]))))), ((Cardinality ((A))))))) : (((fapply ((Q), (fapply ((seq), (z))))) \<noteq> (BOT))))"
fixes z
assumes z_in : "(z \<in> ((isa_peri_peri_a (((arith_add ((k), ((Succ[0]))))), ((Cardinality ((A))))))))"
assumes v'282: "(((fapply ((seq), (z))) \<in> (A)))"
assumes v'283: "(\<forall> b \<in> (A) : ((leq ((b), (X)))))"
shows "((leq ((fapply ((seq), (z))), (X))))"(is "PROP ?ob'1221")
proof -
ML_command {* writeln "*** TLAPS ENTER 1221"; *}
show "PROP ?ob'1221"
using assms by auto
ML_command {* writeln "*** TLAPS EXIT 1221"; *} qed
lemma ob'1212:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'233: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'234: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'235: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'236: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'237: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'238: "((((a_jhash_primea :: c)) = (j)))"
assumes v'239: "((((a_lhash_primea :: c)) = (l)))"
assumes v'240: "((((a_xhash_primea :: c)) = (x)))"
assumes v'241: "((((a_vhash_primea :: c)) = (v)))"
assumes v'242: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca)) :: c)) & (\<exists> d \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d)) :: c)))) : (\<exists> seq \<in> ((Perm ((S)))) : ((((fapply ((a_ca), (''sigma''))) = ((Concat ((fapply ((d), (''sigma''))), ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (fapply ((v), (fapply ((seq), (k)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (S))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (fapply ((fapply ((d), (''fres''))), (q)))))))))))))))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'245: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'246: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'254: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
assumes v'266: "(\<exists> z \<in> ((isa_peri_peri_a (((arith_add ((k), ((Succ[0]))))), ((Cardinality ((A))))))) : (((fapply ((Q), (fapply ((seq), (z))))) \<noteq> (BOT))))"
fixes z
assumes z_in : "(z \<in> ((isa_peri_peri_a (((arith_add ((k), ((Succ[0]))))), ((Cardinality ((A))))))))"
assumes v'286: "((leq ((fapply ((seq), (z))), (X))))"
assumes v'287: "(((fapply ((seq), (k))) \<noteq> (fapply ((seq), (z)))))"
assumes v'288: "(((X) = (fapply ((seq), (k)))))"
shows "((less ((fapply ((seq), (z))), (fapply ((seq), (k))))))"(is "PROP ?ob'1212")
proof -
ML_command {* writeln "*** TLAPS ENTER 1212"; *}
show "PROP ?ob'1212"
using assms by auto
ML_command {* writeln "*** TLAPS EXIT 1212"; *} qed
lemma ob'1259:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'232: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'233: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'234: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'235: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'236: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'237: "((((a_jhash_primea :: c)) = (j)))"
assumes v'238: "((((a_lhash_primea :: c)) = (l)))"
assumes v'239: "((((a_xhash_primea :: c)) = (x)))"
assumes v'240: "((((a_vhash_primea :: c)) = (v)))"
assumes v'241: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca)) :: c)) & (\<exists> d \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d)) :: c)))) : (\<exists> seq \<in> (subsetOf(([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))) \<rightarrow> (S)]), %f. (\<forall> w \<in> (S) : (\<exists> q \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))) : (((fapply ((f), (q))) = (w))))))) : ((((fapply ((a_ca), (''sigma''))) = ((Concat ((fapply ((d), (''sigma''))), ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (fapply ((v), (fapply ((seq), (k)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (S))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (fapply ((fapply ((d), (''fres''))), (q)))))))))))))))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> (subsetOf(([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) \<rightarrow> (A)]), %f. (\<forall> w \<in> (A) : (\<exists> q \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) : (((fapply ((f), (q))) = (w))))))))"
assumes v'244: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'245: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'253: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
assumes v'267: "((((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0])))))))))))  \<mapsto> (fapply ((seq), (z)))]))) = ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0])))))))))))))"
assumes v'268: "((((Cardinality ((setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z)))))))) = ((arith_add ((k), ((minus (((Succ[0]))))))))))"
shows "((([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0])))))))))))  \<mapsto> (fapply ((seq), (z)))]) \<in> (subsetOf(([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z))))))))))) \<rightarrow> (setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z)))))]), %f. (\<forall> w \<in> (setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z))))) : (\<exists> q \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z))))))))))) : (((fapply ((f), (q))) = (w)))))))))"(is "PROP ?ob'1259")
proof -
ML_command {* writeln "*** TLAPS ENTER 1259"; *}
show "PROP ?ob'1259"
using assms by auto
ML_command {* writeln "*** TLAPS EXIT 1259"; *} qed
lemma ob'1293:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'232: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'233: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'234: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'235: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'236: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'237: "((((a_jhash_primea :: c)) = (j)))"
assumes v'238: "((((a_lhash_primea :: c)) = (l)))"
assumes v'239: "((((a_xhash_primea :: c)) = (x)))"
assumes v'240: "((((a_vhash_primea :: c)) = (v)))"
assumes v'241: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca)) :: c)) & (\<exists> d \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d)) :: c)))) : (\<exists> seq \<in> (subsetOf(([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))) \<rightarrow> (S)]), %f. (\<forall> w \<in> (S) : (\<exists> q \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))) : (((fapply ((f), (q))) = (w))))))) : ((((fapply ((a_ca), (''sigma''))) = ((Concat ((fapply ((d), (''sigma''))), ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (fapply ((v), (fapply ((seq), (k)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (S))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (fapply ((fapply ((d), (''fres''))), (q)))))))))))))))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> (subsetOf(([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) \<rightarrow> (A)]), %f. (\<forall> w \<in> (A) : (\<exists> q \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) : (((fapply ((f), (q))) = (w))))))))"
assumes v'244: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'245: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'253: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes m
assumes m_in : "(m \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0]))))))))))))"
assumes v'272: "(((fapply ((Q), (m))) \<noteq> (BOT)))"
assumes v'277: "(((m) \<in> (A)))"
shows "(\<exists> km \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) : (((fapply ((seq), (km))) = (m))))"(is "PROP ?ob'1293")
proof -
ML_command {* writeln "*** TLAPS ENTER 1293"; *}
show "PROP ?ob'1293"
using assms by auto
ML_command {* writeln "*** TLAPS EXIT 1293"; *} qed
lemma ob'1312:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'233: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'234: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'235: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'236: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'237: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'238: "((((a_jhash_primea :: c)) = (j)))"
assumes v'239: "((((a_lhash_primea :: c)) = (l)))"
assumes v'240: "((((a_xhash_primea :: c)) = (x)))"
assumes v'241: "((((a_vhash_primea :: c)) = (v)))"
assumes v'242: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca)) :: c)) & (\<exists> d \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d)) :: c)))) : (\<exists> seq \<in> ((Perm ((S)))) : ((((fapply ((a_ca), (''sigma''))) = ((Concat ((fapply ((d), (''sigma''))), ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (fapply ((v), (fapply ((seq), (k)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (S))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (fapply ((fapply ((d), (''fres''))), (q)))))))))))))))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'245: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'246: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'254: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes m
assumes m_in : "(m \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0]))))))))))))"
assumes v'274: "(((m) \<in> (setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z)))))))"
assumes v'275: "(((fapply ((Q), (m))) = (BOT)))"
fixes km
assumes km_in : "(km \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))))"
assumes v'285: "(((fapply ((seq), (km))) = (m)))"
assumes v'286: "(\<forall> y \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))) : (((y) \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))))"
assumes v'287: "(((((km) \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))) \<Rightarrow> (((fapply ((seq), (km))) \<in> (A)))))"
shows "(((m) \<in> (A)))"(is "PROP ?ob'1312")
proof -
ML_command {* writeln "*** TLAPS ENTER 1312"; *}
show "PROP ?ob'1312"
using assms by auto
ML_command {* writeln "*** TLAPS EXIT 1312"; *} qed
lemma ob'1309:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'232: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'233: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'234: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'235: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'236: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'237: "((((a_jhash_primea :: c)) = (j)))"
assumes v'238: "((((a_lhash_primea :: c)) = (l)))"
assumes v'239: "((((a_xhash_primea :: c)) = (x)))"
assumes v'240: "((((a_vhash_primea :: c)) = (v)))"
assumes v'241: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca)) :: c)) & (\<exists> d \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d)) :: c)))) : (\<exists> seq \<in> (subsetOf(([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))) \<rightarrow> (S)]), %f. (\<forall> w \<in> (S) : (\<exists> q \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))) : (((fapply ((f), (q))) = (w))))))) : ((((fapply ((a_ca), (''sigma''))) = ((Concat ((fapply ((d), (''sigma''))), ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (fapply ((v), (fapply ((seq), (k)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (S))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (fapply ((fapply ((d), (''fres''))), (q)))))))))))))))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> (subsetOf(([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) \<rightarrow> (A)]), %f. (\<forall> w \<in> (A) : (\<exists> q \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) : (((fapply ((f), (q))) = (w))))))))"
assumes v'244: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'245: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'253: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes m
assumes m_in : "(m \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0]))))))))))))"
assumes v'273: "(((m) \<in> (setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z)))))))"
assumes v'274: "(((fapply ((Q), (m))) = (BOT)))"
fixes km
assumes km_in : "(km \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))))"
assumes v'283: "(((fapply ((seq), (km))) = (m)))"
shows "(((((km) \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))) \<Rightarrow> (((fapply ((seq), (km))) \<in> (A)))))"(is "PROP ?ob'1309")
proof -
ML_command {* writeln "*** TLAPS ENTER 1309"; *}
show "PROP ?ob'1309"
using assms by auto
ML_command {* writeln "*** TLAPS EXIT 1309"; *} qed
lemma ob'1303:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'232: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'233: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'234: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'235: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'236: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'237: "((((a_jhash_primea :: c)) = (j)))"
assumes v'238: "((((a_lhash_primea :: c)) = (l)))"
assumes v'239: "((((a_xhash_primea :: c)) = (x)))"
assumes v'240: "((((a_vhash_primea :: c)) = (v)))"
assumes v'241: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca)) :: c)) & (\<exists> d \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d)) :: c)))) : (\<exists> seq \<in> (subsetOf(([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))) \<rightarrow> (S)]), %f. (\<forall> w \<in> (S) : (\<exists> q \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))) : (((fapply ((f), (q))) = (w))))))) : ((((fapply ((a_ca), (''sigma''))) = ((Concat ((fapply ((d), (''sigma''))), ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (fapply ((v), (fapply ((seq), (k)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (S))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (fapply ((fapply ((d), (''fres''))), (q)))))))))))))))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> (subsetOf(([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) \<rightarrow> (A)]), %f. (\<forall> w \<in> (A) : (\<exists> q \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) : (((fapply ((f), (q))) = (w))))))))"
assumes v'244: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'245: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'253: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes m
assumes m_in : "(m \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0]))))))))))))"
assumes v'273: "(((m) \<in> (setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z)))))))"
assumes v'274: "(((fapply ((Q), (m))) = (BOT)))"
shows "(\<exists> km \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))) : (((fapply ((seq), (km))) = (m))))"(is "PROP ?ob'1303")
proof -
ML_command {* writeln "*** TLAPS ENTER 1303"; *}
show "PROP ?ob'1303"
using assms by auto
ML_command {* writeln "*** TLAPS EXIT 1303"; *} qed
lemma ob'1372:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'232: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'233: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'234: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'235: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'236: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'237: "((((a_jhash_primea :: c)) = (j)))"
assumes v'238: "((((a_lhash_primea :: c)) = (l)))"
assumes v'239: "((((a_xhash_primea :: c)) = (x)))"
assumes v'240: "((((a_vhash_primea :: c)) = (v)))"
assumes v'241: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca)) :: c)) & (\<exists> d \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d)) :: c)))) : (\<exists> seq \<in> (subsetOf(([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))) \<rightarrow> (S)]), %f. (\<forall> w \<in> (S) : (\<exists> q \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((S))))))) : (((fapply ((f), (q))) = (w))))))) : ((((fapply ((a_ca), (''sigma''))) = ((Concat ((fapply ((d), (''sigma''))), ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (fapply ((v), (fapply ((seq), (k)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (S))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (fapply ((fapply ((d), (''fres''))), (q)))))))))))))))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> (subsetOf(([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) \<rightarrow> (A)]), %f. (\<forall> w \<in> (A) : (\<exists> q \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) : (((fapply ((f), (q))) = (w))))))))"
assumes v'244: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'245: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'253: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes n
assumes n_in : "(n \<in> (setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z))))))"
fixes kn
assumes kn_in : "(kn \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))))"
assumes v'279: "(((fapply ((seq), (kn))) = (n)))"
assumes v'280: "(\<forall> y \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))) : (((y) \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))))"
shows "(((kn) \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A)))))))))"(is "PROP ?ob'1372")
proof -
ML_command {* writeln "*** TLAPS ENTER 1372"; *}
show "PROP ?ob'1372"
using assms by auto
ML_command {* writeln "*** TLAPS EXIT 1372"; *} qed
lemma ob'1420:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (\<forall> A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0]))))))))))))) : ((((GoodEnqSet ((A)))) \<Rightarrow> (\<forall> seq \<in> ((Perm ((A)))) : ((((JInvSeq ((seq)))) \<Rightarrow> (\<exists> a_ca \<in> (M) : (((ValuesMatchInds ((seq), (fapply ((a_ca), (''sigma'')))))) & ((GoodRes ((A), (fapply ((a_ca), (''fres''))))))))))))))) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'232: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'233: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'234: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'235: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'236: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'237: "((((a_jhash_primea :: c)) = (j)))"
assumes v'238: "((((a_lhash_primea :: c)) = (l)))"
assumes v'239: "((((a_xhash_primea :: c)) = (x)))"
assumes v'240: "((((a_vhash_primea :: c)) = (v)))"
assumes v'241: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca)) :: c)) & (\<exists> d \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d)) :: c)))) : (\<exists> seq \<in> ((Perm ((S)))) : ((((fapply ((a_ca), (''sigma''))) = ((Concat ((fapply ((d), (''sigma''))), ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (fapply ((v), (fapply ((seq), (k)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (S))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (fapply ((fapply ((d), (''fres''))), (q)))))))))))))))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'244: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'245: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'253: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
assumes v'270: "((([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0])))))))))))  \<mapsto> (fapply ((seq), (z)))]) \<in> ((Perm ((setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z))))))))))"
assumes v'271: "((GoodEnqSet ((setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z))))))))"
assumes v'272: "((JInvSeq (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0])))))))))))  \<mapsto> (fapply ((seq), (z)))]))))"
assumes v'273: "(((setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z))))) \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0])))))))))))))))"
shows "(\<exists> a_ca \<in> (M) : ((((ValuesMatchInds (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0])))))))))))  \<mapsto> (fapply ((seq), (z)))]), (fapply ((a_ca), (''sigma'')))))) \<and> ((GoodRes ((setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z))))), (fapply ((a_ca), (''fres'')))))))))"(is "PROP ?ob'1420")
proof -
ML_command {* writeln "*** TLAPS ENTER 1420"; *}
show "PROP ?ob'1420"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_e8764f.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_e8764f.znn.out
;; obligation #1420
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa
(TLA.bAll (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0) (arith.add X
(arith.minus (TLA.fapply TLA.Succ 0))))) ((A) (=> (GoodEnqSet A)
(TLA.bAll (Perm A) ((seq) (=> (JInvSeq seq)
(TLA.bEx M ((a_ca) (/\ (ValuesMatchInds seq (TLA.fapply a_ca "sigma"))
(GoodRes A (TLA.fapply a_ca "fres")))))))))))) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'232" (= (TLA.fapply pc p) "E1")
$hyp "v'233" (= a_pchash_primea
(TLA.except pc p "E2"))
$hyp "v'234" (= a_ihash_primea
(TLA.except i p X))
$hyp "v'235" (= a_Xhash_primea (arith.add X
(TLA.fapply TLA.Succ 0)))
$hyp "v'236" (= a_Qhash_primea Q)
$hyp "v'237" (= a_jhash_primea j)
$hyp "v'238" (= a_lhash_primea l)
$hyp "v'239" (= a_xhash_primea x)
$hyp "v'240" (= a_vhash_primea v)
$hyp "v'241" (= a_Mhash_primea
(TLA.subsetOf CDomain ((a_ca) (/\ (a_h022c5783954683bdcbcacced356fd6a a_ca)
(TLA.bEx M ((d) (TLA.bEx (TLA.SUBSET (hc4e622ce2e33ef1c6a9f10c01956cd d)) ((S) (TLA.bEx (Perm S) ((seq) (/\ (= (TLA.fapply a_ca "sigma")
(Concat (TLA.fapply d "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((k) (TLA.fapply v (TLA.fapply seq k))))))
(TLA.bAll ProcSet ((q) (TLA.cond (TLA.in q
S) (= (TLA.fapply (TLA.fapply a_ca "fres") q)
ACK) (= (TLA.fapply (TLA.fapply a_ca "fres") q)
(TLA.fapply (TLA.fapply d "fres") q))))))))))))))))
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'244" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'245" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'253" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "v'270" (TLA.in (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z)))
(Perm (TLA.setOfAll (arith.intrange (TLA.fapply TLA.Succ 0) (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z)))))
$hyp "v'271" (GoodEnqSet (TLA.setOfAll (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z))))
$hyp "v'272" (JInvSeq (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z))))
$hyp "v'273" (TLA.in (TLA.setOfAll (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z)))
(TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0) (arith.add X
(arith.minus (TLA.fapply TLA.Succ 0))))))
$goal (TLA.bEx M ((a_ca) (/\ (ValuesMatchInds (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z)))
(TLA.fapply a_ca "sigma"))
(GoodRes (TLA.setOfAll (arith.intrange (TLA.fapply TLA.Succ 0) (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z)))
(TLA.fapply a_ca "fres")))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hb:"((TypeOK&(a_Invunde_E2a&(a_Invunde_E3a&(a_Invunde_D2a&(a_Invunde_D3a&(a_Invunde_Qa&bAll(SUBSET(isa'dotdot(1, (X +  -.(1)))), (\<lambda>A. (GoodEnqSet(A)=>bAll(Perm(A), (\<lambda>seq. (JInvSeq(seq)=>bEx(M, (\<lambda>a_ca. (ValuesMatchInds(seq, (a_ca[''sigma'']))&GoodRes(A, (a_ca[''fres''])))))))))))))))))&(Next|(a_h4fd5f73954dc53af536c1c75068837a=vars)))" (is "?z_hy&?z_hcm")
 using v'209 by blast
 have z_Ht:"(Fcn(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))) \\in Perm(setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z])))))" (is "?z_ht")
 using v'270 by blast
 have z_Hv:"JInvSeq(Fcn(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))))" (is "?z_hv")
 using v'272 by blast
 have z_Hu:"GoodEnqSet(setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))))" (is "?z_hu")
 using v'271 by blast
 have z_Hw:"(setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))) \\in SUBSET(isa'dotdot(1, (X +  -.(1)))))" (is "?z_hw")
 using v'273 by blast
 assume z_Hx:"(~bEx(M, (\<lambda>a_ca. (ValuesMatchInds(Fcn(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))), (a_ca[''sigma'']))&GoodRes(setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))), (a_ca[''fres'']))))))" (is "~?z_hda")
 have z_Hy: "?z_hy" (is "_&?z_hba")
 by (rule zenon_and_0 [OF z_Hb])
 have z_Hba: "?z_hba" (is "_&?z_hbc")
 by (rule zenon_and_1 [OF z_Hy])
 have z_Hbc: "?z_hbc" (is "_&?z_hbe")
 by (rule zenon_and_1 [OF z_Hba])
 have z_Hbe: "?z_hbe" (is "_&?z_hbg")
 by (rule zenon_and_1 [OF z_Hbc])
 have z_Hbg: "?z_hbg" (is "_&?z_hbi")
 by (rule zenon_and_1 [OF z_Hbe])
 have z_Hbi: "?z_hbi" (is "_&?z_hbk")
 by (rule zenon_and_1 [OF z_Hbg])
 have z_Hbk: "?z_hbk"
 by (rule zenon_and_1 [OF z_Hbi])
 have z_Hdf_z_Hbk: "(\\A x:((x \\in SUBSET(isa'dotdot(1, (X +  -.(1)))))=>(GoodEnqSet(x)=>bAll(Perm(x), (\<lambda>seq. (JInvSeq(seq)=>bEx(M, (\<lambda>a_ca. (ValuesMatchInds(seq, (a_ca[''sigma'']))&GoodRes(x, (a_ca[''fres'']))))))))))) == ?z_hbk" (is "?z_hdf == _")
 by (unfold bAll_def)
 have z_Hdf: "?z_hdf" (is "\\A x : ?z_hdt(x)")
 by (unfold z_Hdf_z_Hbk, fact z_Hbk)
 have z_Hdu: "?z_hdt(setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))))" (is "_=>?z_hdv")
 by (rule zenon_all_0 [of "?z_hdt" "setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z])))", OF z_Hdf])
 show FALSE
 proof (rule zenon_imply [OF z_Hdu])
  assume z_Hdw:"(~?z_hw)"
  show FALSE
  by (rule notE [OF z_Hdw z_Hw])
 next
  assume z_Hdv:"?z_hdv" (is "_=>?z_hdx")
  show FALSE
  proof (rule zenon_imply [OF z_Hdv])
   assume z_Hdy:"(~?z_hu)"
   show FALSE
   by (rule notE [OF z_Hdy z_Hu])
  next
   assume z_Hdx:"?z_hdx"
   have z_Hdz_z_Hdx: "(\\A x:((x \\in Perm(setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z])))))=>(JInvSeq(x)=>bEx(M, (\<lambda>a_ca. (ValuesMatchInds(x, (a_ca[''sigma'']))&GoodRes(setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))), (a_ca[''fres''])))))))) == ?z_hdx" (is "?z_hdz == _")
   by (unfold bAll_def)
   have z_Hdz: "?z_hdz" (is "\\A x : ?z_hei(x)")
   by (unfold z_Hdz_z_Hdx, fact z_Hdx)
   have z_Hej: "?z_hei(Fcn(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))))" (is "_=>?z_hek")
   by (rule zenon_all_0 [of "?z_hei" "Fcn(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z])))", OF z_Hdz])
   show FALSE
   proof (rule zenon_imply [OF z_Hej])
    assume z_Hel:"(~?z_ht)"
    show FALSE
    by (rule notE [OF z_Hel z_Ht])
   next
    assume z_Hek:"?z_hek"
    show FALSE
    proof (rule zenon_imply [OF z_Hek])
     assume z_Hem:"(~?z_hv)"
     show FALSE
     by (rule notE [OF z_Hem z_Hv])
    next
     assume z_Hda:"?z_hda"
     show FALSE
     by (rule notE [OF z_Hx z_Hda])
    qed
   qed
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1420"; *} qed
lemma ob'956:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E1 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'231: "(cond((((fapply ((Q), (fapply ((j), (p))))) = (BOT))), (cond((((fapply ((j), (p))) = ((arith_add ((fapply ((l), (p))), ((minus (((Succ[0])))))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D1'')]))) & (((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (M))))), (((((a_jhash_primea :: c)) = ([(j) EXCEPT ![(p)] = ((arith_add ((fapply ((j), (p))), ((Succ[0])))))]))) & (((((a_pchash_primea :: c)) = (pc))) & ((((a_Mhash_primea :: c)) = (M))))))), (((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''D4'')]))) & ((((a_jhash_primea :: c)) = (j))) & ((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %d. (((a_h022c5783954683bdcbcacced356fd6a ((d)) :: c)) & (\<exists> a_ca \<in> (M) : ((((fapply ((fapply ((d), (''fres''))), (p))) = ((Head ((fapply ((a_ca), (''sigma'')))))))) & (\<forall> q \<in> (ProcSet) : (((((q) \<noteq> (p))) \<Rightarrow> (((fapply ((fapply ((d), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q)))))))) & (((fapply ((d), (''sigma''))) = ((Tail ((fapply ((a_ca), (''sigma''))))))))))))))))))"
assumes v'232: "(((fapply ((pc), (p))) = (''D3'')))"
assumes v'233: "((((a_xhash_primea :: c)) = ([(x) EXCEPT ![(p)] = (fapply ((Q), (fapply ((j), (p)))))])))"
assumes v'234: "((((a_Qhash_primea :: c)) = ([(Q) EXCEPT ![(fapply ((j), (p)))] = (BOT)])))"
assumes v'235: "((((a_Xhash_primea :: c)) = (X)))"
assumes v'236: "((((a_ihash_primea :: c)) = (i)))"
assumes v'237: "((((a_lhash_primea :: c)) = (l)))"
assumes v'238: "((((a_vhash_primea :: c)) = (v)))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'241: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'242: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'251: "(((fapply ((Q), (fapply ((j), (p))))) \<noteq> (BOT)))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
assumes v'289: "((((DOMAIN (fapply ((((''sigma'' :> ((Tail ((fapply ((a_ca), (''sigma''))))))) @@ (''fres'' :> ([(fapply ((a_ca), (''fres''))) EXCEPT ![(p)] = ((Head ((fapply ((a_ca), (''sigma''))))))])))), (''sigma''))))) = ((isa_peri_peri_a (((Succ[0])), ((a_Lena ((seq)))))))))"
assumes v'290: "(((fapply ((((''sigma'' :> ((Tail ((fapply ((a_ca), (''sigma''))))))) @@ (''fres'' :> ([(fapply ((a_ca), (''fres''))) EXCEPT ![(p)] = ((Head ((fapply ((a_ca), (''sigma''))))))])))), (''sigma''))) \<in> ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))])))))))"
assumes v'291: "((((DOMAIN (seq))) = ((isa_peri_peri_a (((Succ[0])), ((a_Lena ((seq)))))))))"
shows "(((fapply ((((''sigma'' :> ((Tail ((fapply ((a_ca), (''sigma''))))))) @@ (''fres'' :> ([(fapply ((a_ca), (''fres''))) EXCEPT ![(p)] = ((Head ((fapply ((a_ca), (''sigma''))))))])))), (''sigma''))) \<in> ([((DOMAIN (seq))) \<rightarrow> (((Nat) \\ ({((0))})))])))"(is "PROP ?ob'956")
proof -
ML_command {* writeln "*** TLAPS ENTER 956"; *}
show "PROP ?ob'956"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_a0d90e.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_a0d90e.znn.out
;; obligation #956
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "v'231" (TLA.cond (= (TLA.fapply Q (TLA.fapply j p))
BOT) (TLA.cond (= (TLA.fapply j p) (arith.add (TLA.fapply l p)
(arith.minus (TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea
(TLA.except pc p "D1")) (/\ (= a_jhash_primea j) (= a_Mhash_primea
M))) (/\ (= a_jhash_primea (TLA.except j p (arith.add (TLA.fapply j p)
(TLA.fapply TLA.Succ 0)))) (/\ (= a_pchash_primea pc) (= a_Mhash_primea
M)))) (/\ (= a_pchash_primea (TLA.except pc p "D4")) (= a_jhash_primea j)
(= a_Mhash_primea
(TLA.subsetOf CDomain ((d) (/\ (a_h022c5783954683bdcbcacced356fd6a d)
(TLA.bEx M ((a_ca) (/\ (= (TLA.fapply (TLA.fapply d "fres") p)
(Head (TLA.fapply a_ca "sigma"))) (TLA.bAll ProcSet ((q) (=> (-. (= q p))
(= (TLA.fapply (TLA.fapply d "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))) (= (TLA.fapply d "sigma")
(Tail (TLA.fapply a_ca "sigma"))))))))))))
$hyp "v'232" (= (TLA.fapply pc p) "D3")
$hyp "v'233" (= a_xhash_primea
(TLA.except x p (TLA.fapply Q (TLA.fapply j p))))
$hyp "v'234" (= a_Qhash_primea
(TLA.except Q (TLA.fapply j p) BOT))
$hyp "v'235" (= a_Xhash_primea X)
$hyp "v'236" (= a_ihash_primea i)
$hyp "v'237" (= a_lhash_primea l)
$hyp "v'238" (= a_vhash_primea
v)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'241" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'242" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'251" (-. (= (TLA.fapply Q (TLA.fapply j p))
BOT))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'289" (= (TLA.DOMAIN (TLA.fapply (TLA.record "sigma" (Tail (TLA.fapply a_ca "sigma")) "fres" (TLA.except (TLA.fapply a_ca "fres") p (Head (TLA.fapply a_ca "sigma")))) "sigma"))
(arith.intrange (TLA.fapply TLA.Succ 0)
(a_Lena seq)))
$hyp "v'290" (TLA.in (TLA.fapply (TLA.record "sigma" (Tail (TLA.fapply a_ca "sigma")) "fres" (TLA.except (TLA.fapply a_ca "fres") p (Head (TLA.fapply a_ca "sigma")))) "sigma")
(TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N (TLA.set 0)))))))
$hyp "v'291" (= (TLA.DOMAIN seq) (arith.intrange (TLA.fapply TLA.Succ 0)
(a_Lena seq)))
$goal (TLA.in (TLA.fapply (TLA.record "sigma" (Tail (TLA.fapply a_ca "sigma")) "fres" (TLA.except (TLA.fapply a_ca "fres") p (Head (TLA.fapply a_ca "sigma")))) "sigma")
(TLA.FuncSet (TLA.DOMAIN seq) (TLA.setminus arith.N
(TLA.set 0))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hs:"(((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''sigma'']) \\in UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0}))))))" (is "?z_hs")
 using v'290 by blast
 have z_Hr:"(DOMAIN(((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''sigma'']))=isa'dotdot(1, a_Lena(seq)))" (is "?z_hbr=?z_hbs")
 using v'289 by blast
 have z_Ht:"(DOMAIN(seq)=?z_hbs)" (is "?z_hbv=_")
 using v'291 by blast
 have zenon_L1_: "(DOMAIN(Tail((a_ca[''sigma''])))=?z_hbs) ==> (Tail((a_ca[''sigma''])) \\in (CHOOSE zenon_Vn:((zenon_Vn \\in setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))&(((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''sigma'']) \\in zenon_Vn)))) ==> ((CHOOSE zenon_Vn:((zenon_Vn \\in setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))&(((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''sigma'']) \\in zenon_Vn)))=FuncSet(isa'dotdot(1, (CHOOSE zenon_Vab:((zenon_Vab \\in Nat)&((CHOOSE zenon_Vn:((zenon_Vn \\in setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))&(((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''sigma'']) \\in zenon_Vn)))=FuncSet(isa'dotdot(1, zenon_Vab), (Nat \\ {0})))))), (Nat \\ {0}))) ==> (?z_hbs~=isa'dotdot(1, (CHOOSE zenon_Vab:((zenon_Vab \\in Nat)&((CHOOSE zenon_Vn:((zenon_Vn \\in setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))&(((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''sigma'']) \\in zenon_Vn)))=FuncSet(isa'dotdot(1, zenon_Vab), (Nat \\ {0}))))))) ==> FALSE" (is "?z_hbw ==> ?z_hby ==> ?z_hce ==> ?z_hco ==> FALSE")
 proof -
  assume z_Hbw:"?z_hbw" (is "?z_hbx=_")
  assume z_Hby:"?z_hby"
  assume z_Hce:"?z_hce" (is "?z_hbz=?z_hcf")
  assume z_Hco:"?z_hco" (is "_~=?z_hcg")
  show FALSE
  proof (rule zenon_em [of "(?z_hcg=?z_hcg)"])
   assume z_Hcp:"(?z_hcg=?z_hcg)"
   show FALSE
   proof (rule notE [OF z_Hco])
    have z_Hcq: "(?z_hcg=?z_hbs)"
    proof (rule zenon_nnpp [of "(?z_hcg=?z_hbs)"])
     assume z_Hcr:"(?z_hcg~=?z_hbs)"
     show FALSE
     proof (rule notE [OF z_Hcr])
      have z_Hcs: "(?z_hbx=?z_hcg)"
      proof (rule zenon_nnpp [of "(?z_hbx=?z_hcg)"])
       assume z_Hct:"(?z_hbx~=?z_hcg)"
       show FALSE
       proof (rule zenon_em [of "(?z_hcg=?z_hcg)"])
        assume z_Hcp:"(?z_hcg=?z_hcg)"
        show FALSE
        proof (rule notE [OF z_Hct])
         have z_Hcu: "(?z_hcg=?z_hbx)"
         proof (rule zenon_nnpp [of "(?z_hcg=?z_hbx)"])
          assume z_Hcv:"(?z_hcg~=?z_hbx)"
          have z_Hcw: "(\\A zenon_Vjf:((zenon_Vjf \\in ?z_hbz)<=>(zenon_Vjf \\in ?z_hcf)))" (is "\\A x : ?z_hdb(x)")
          by (rule zenon_setequal_0 [of "?z_hbz" "?z_hcf", OF z_Hce])
          have z_Hdc: "?z_hdb(Tail((a_ca[''sigma''])))" (is "_<=>?z_hdd")
          by (rule zenon_all_0 [of "?z_hdb" "Tail((a_ca[''sigma'']))", OF z_Hcw])
          show FALSE
          proof (rule zenon_equiv [OF z_Hdc])
           assume z_Hde:"(~?z_hby)"
           assume z_Hdf:"(~?z_hdd)"
           show FALSE
           by (rule notE [OF z_Hde z_Hby])
          next
           assume z_Hby:"?z_hby"
           assume z_Hdd:"?z_hdd"
           have z_Hcs: "(?z_hbx=?z_hcg)"
           by (rule zenon_in_funcset_1 [of "Tail((a_ca[''sigma'']))" "?z_hcg" "(Nat \\ {0})", OF z_Hdd])
           show FALSE
           by (rule zenon_eqsym [OF z_Hcs z_Hcv])
          qed
         qed
         have z_Hcs: "(?z_hbx=?z_hcg)"
         by (rule subst [where P="(\<lambda>zenon_Vzhj. (zenon_Vzhj=?z_hcg))", OF z_Hcu], fact z_Hcp)
         thus "(?z_hbx=?z_hcg)" .
        qed
       next
        assume z_Hdj:"(?z_hcg~=?z_hcg)"
        show FALSE
        by (rule zenon_noteq [OF z_Hdj])
       qed
      qed
      have z_Hcq: "(?z_hcg=?z_hbs)"
      by (rule subst [where P="(\<lambda>zenon_Vaij. (zenon_Vaij=?z_hbs))", OF z_Hcs], fact z_Hbw)
      thus "(?z_hcg=?z_hbs)" .
     qed
    qed
    have z_Hdn: "(?z_hbs=?z_hcg)"
    by (rule subst [where P="(\<lambda>zenon_Vzhj. (zenon_Vzhj=?z_hcg))", OF z_Hcq], fact z_Hcp)
    thus "(?z_hbs=?z_hcg)" .
   qed
  next
   assume z_Hdj:"(?z_hcg~=?z_hcg)"
   show FALSE
   by (rule zenon_noteq [OF z_Hdj])
  qed
 qed
 assume z_Hu:"(~(((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''sigma'']) \\in FuncSet(?z_hbv, (Nat \\ {0}))))" (is "~?z_hdo")
 have z_Hdq: "(\\E zenon_Vn:((zenon_Vn \\in setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))&(((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''sigma'']) \\in zenon_Vn)))" (is "\\E x : ?z_hdr(x)")
 by (rule zenon_in_UNION_0 [of "((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''sigma''])" "setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0}))))", OF z_Hs])
 have z_Hds: "?z_hdr((CHOOSE zenon_Vn:((zenon_Vn \\in setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))&(((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''sigma'']) \\in zenon_Vn))))" (is "?z_hdt&?z_hdu")
 by (rule zenon_ex_choose_0 [of "?z_hdr", OF z_Hdq])
 have z_Hdt: "?z_hdt"
 by (rule zenon_and_0 [OF z_Hds])
 have z_Hdu: "?z_hdu"
 by (rule zenon_and_1 [OF z_Hds])
 have z_Hdv: "((''sigma'' \\in DOMAIN((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))))&(((''sigma'' :> (Tail((a_ca[''sigma'']))) @@ ''fres'' :> (except((a_ca[''fres'']), p, Head((a_ca[''sigma''])))))[''sigma''])=Tail((a_ca[''sigma'']))))" (is "?z_hdw&?z_hdy")
 by ((rule zenon_recfield_1)+, rule zenon_recfield_2b)
 have z_Hdy: "?z_hdy" (is "?z_hv=?z_hy")
 by (rule conjD2 [OF z_Hdv])
 have z_Hby: "(?z_hy \\in (CHOOSE zenon_Vn:((zenon_Vn \\in setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))&(?z_hv \\in zenon_Vn))))" (is "?z_hby")
 by (rule subst [where P="(\<lambda>zenon_Vwa. (zenon_Vwa \\in (CHOOSE zenon_Vn:((zenon_Vn \\in setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))&(?z_hv \\in zenon_Vn)))))", OF z_Hdy z_Hdu])
 have z_Hdv: "(?z_hdw&?z_hdy)"
 by ((rule zenon_recfield_1)+, rule zenon_recfield_2b)
 have z_Hdy: "?z_hdy"
 by (rule conjD2 [OF z_Hdv])
 have z_Hbw: "(DOMAIN(?z_hy)=?z_hbs)" (is "?z_hbx=_")
 by (rule subst [where P="(\<lambda>zenon_Vj. (DOMAIN(zenon_Vj)=?z_hbs))", OF z_Hdy z_Hr])
 show FALSE
 proof (rule notE [OF z_Hu])
  have z_Heg: "((CHOOSE zenon_Vn:((zenon_Vn \\in setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))&(?z_hv \\in zenon_Vn)))=FuncSet(?z_hbv, (Nat \\ {0})))" (is "?z_hbz=?z_hdp")
  proof (rule zenon_nnpp [of "(?z_hbz=?z_hdp)"])
   assume z_Heh:"(?z_hbz~=?z_hdp)"
   have z_Hei: "(\\E zenon_Vab:((zenon_Vab \\in Nat)&(?z_hbz=FuncSet(isa'dotdot(1, zenon_Vab), (Nat \\ {0})))))" (is "\\E x : ?z_hej(x)")
   by (rule zenon_in_setofall_0 [of "?z_hbz" "Nat" "(\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))", OF z_Hdt])
   have z_Hek: "?z_hej((CHOOSE zenon_Vab:((zenon_Vab \\in Nat)&(?z_hbz=FuncSet(isa'dotdot(1, zenon_Vab), (Nat \\ {0}))))))" (is "?z_hel&?z_hce")
   by (rule zenon_ex_choose_0 [of "?z_hej", OF z_Hei])
   have z_Hce: "?z_hce" (is "_=?z_hcf")
   by (rule zenon_and_1 [OF z_Hek])
   show FALSE
   proof (rule notE [OF z_Heh])
    have z_Hem: "(?z_hcf=?z_hdp)"
    proof (rule zenon_nnpp [of "(?z_hcf=?z_hdp)"])
     assume z_Hen:"(?z_hcf~=?z_hdp)"
     show FALSE
     proof (rule zenon_noteq [of "?z_hdp"])
      have z_Heo: "(isa'dotdot(1, (CHOOSE zenon_Vab:((zenon_Vab \\in Nat)&(?z_hbz=FuncSet(isa'dotdot(1, zenon_Vab), (Nat \\ {0}))))))=?z_hbv)" (is "?z_hcg=_")
      proof (rule zenon_nnpp [of "(?z_hcg=?z_hbv)"])
       assume z_Hep:"(?z_hcg~=?z_hbv)"
       show FALSE
       proof (rule zenon_em [of "(?z_hbv=?z_hbv)"])
        assume z_Heq:"(?z_hbv=?z_hbv)"
        show FALSE
        proof (rule notE [OF z_Hep])
         have z_Her: "(?z_hbv=?z_hcg)"
         proof (rule zenon_nnpp [of "(?z_hbv=?z_hcg)"])
          assume z_Hes:"(?z_hbv~=?z_hcg)"
          show FALSE
          proof (rule notE [OF z_Hes])
           have z_Hdn: "(?z_hbs=?z_hcg)"
           proof (rule zenon_nnpp [of "(?z_hbs=?z_hcg)"])
            assume z_Hco:"(?z_hbs~=?z_hcg)"
            show FALSE
            by (rule zenon_L1_ [OF z_Hbw z_Hby z_Hce z_Hco])
           qed
           have z_Her: "(?z_hbv=?z_hcg)"
           by (rule subst [where P="(\<lambda>zenon_Vcij. (?z_hbv=zenon_Vcij))", OF z_Hdn], fact z_Ht)
           thus "(?z_hbv=?z_hcg)" .
          qed
         qed
         have z_Heo: "(?z_hcg=?z_hbv)"
         by (rule subst [where P="(\<lambda>zenon_Vdij. (zenon_Vdij=?z_hbv))", OF z_Her], fact z_Heq)
         thus "(?z_hcg=?z_hbv)" .
        qed
       next
        assume z_Hez:"(?z_hbv~=?z_hbv)"
        show FALSE
        by (rule zenon_noteq [OF z_Hez])
       qed
      qed
      have z_Hfa: "(?z_hdp~=?z_hdp)"
      by (rule subst [where P="(\<lambda>zenon_Vwhj. (FuncSet(zenon_Vwhj, (Nat \\ {0}))~=?z_hdp))", OF z_Heo], fact z_Hen)
      thus "(?z_hdp~=?z_hdp)" .
     qed
    qed
    have z_Heg: "(?z_hbz=?z_hdp)"
    by (rule subst [where P="(\<lambda>zenon_Vfij. (?z_hbz=zenon_Vfij))", OF z_Hem], fact z_Hce)
    thus "(?z_hbz=?z_hdp)" .
   qed
  qed
  have z_Hdo: "?z_hdo"
  by (rule subst [where P="(\<lambda>zenon_Vgij. (?z_hv \\in zenon_Vgij))", OF z_Heg], fact z_Hdu)
  thus "?z_hdo" .
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 956"; *} qed
lemma ob'1451:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'235: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'236: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'244: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
assumes v'287: "((((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))))) \<in> (Nat)))"
assumes v'288: "(((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))) \<in> ([((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))])))))))))) \<rightarrow> (((Nat) \\ ({((0))})))])))"
shows "(((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))) \<in> ((UNION (setOfAll((Nat), %n. ([((isa_peri_peri_a (((Succ[0])), (n)))) \<rightarrow> (((Nat) \\ ({((0))})))])))))))"(is "PROP ?ob'1451")
proof -
ML_command {* writeln "*** TLAPS ENTER 1451"; *}
show "PROP ?ob'1451"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_2d2289.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_2d2289.znn.out
;; obligation #1451
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'235" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'236" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'244" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'287" (TLA.in (arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))))
arith.N)
$hyp "v'288" (TLA.in (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")
(TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))))) (TLA.setminus arith.N
(TLA.set 0))))
$goal (TLA.in (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")
(TLA.UNION (TLA.setOfAll arith.N ((n) (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
n) (TLA.setminus arith.N
(TLA.set 0)))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hk:"((a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) \\in Nat)" (is "?z_hk")
 using v'287 by blast
 have z_Hl:"(((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma'']) \\in FuncSet(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (Nat \\ {0})))" (is "?z_hl")
 using v'288 by blast
 assume z_Hm:"(~(((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma'']) \\in UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))))" (is "~?z_hde")
 have z_Hdl: "((a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) \\in Nat)" (is "?z_hdl")
 by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vl. ((a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(zenon_Vl, (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) \\in Nat))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hk])
 have z_Hdv: "((''sigma'' \\in DOMAIN((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))))&(((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma''])=Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))))" (is "?z_hdw&?z_hdy")
 by ((rule zenon_recfield_1)+, rule zenon_recfield_2b)
 have z_Hdy: "?z_hdy" (is "?z_hcl=?z_hcn")
 by (rule conjD2 [OF z_Hdv])
 have z_Hdz: "(?z_hcn \\in FuncSet(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (Nat \\ {0})))" (is "?z_hdz")
 by (rule subst [where P="(\<lambda>zenon_Vi. (zenon_Vi \\in FuncSet(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (Nat \\ {0}))))", OF z_Hdy z_Hl])
 have z_Hed: "(Concat((a_ca[''sigma'']), Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))) \\in FuncSet(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (Nat \\ {0})))" (is "?z_hed")
 by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vya. (Concat((a_ca[''sigma'']), Fcn(zenon_Vya, (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))) \\in FuncSet(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (Nat \\ {0}))))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hdz])
 have z_Hek: "(Concat((a_ca[''sigma'']), Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))) \\in FuncSet(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (Nat \\ {0})))" (is "?z_hek")
 by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vbb. (Concat((a_ca[''sigma'']), Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))) \\in FuncSet(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(zenon_Vbb, (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (Nat \\ {0}))))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hed])
 have z_Hdv: "(?z_hdw&?z_hdy)"
 by ((rule zenon_recfield_1)+, rule zenon_recfield_2b)
 have z_Hdy: "?z_hdy"
 by (rule conjD2 [OF z_Hdv])
 have z_Hev: "(~(?z_hcn \\in UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))))" (is "~?z_hew")
 by (rule subst [where P="(\<lambda>zenon_Vf. (~(zenon_Vf \\in UNION(setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0}))))))))", OF z_Hdy z_Hm])
 have z_Hfb: "(~(\\E zenon_Vbc:((zenon_Vbc \\in setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))))&(?z_hcn \\in zenon_Vbc))))" (is "~(\\E x : ?z_hfh(x))")
 by (rule zenon_notin_UNION_0 [of "?z_hcn" "setOfAll(Nat, (\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0}))))", OF z_Hev])
 have z_Hfi: "~?z_hfh(FuncSet(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (Nat \\ {0})))" (is "~(?z_hfj&?z_hfk)")
 by (rule zenon_notex_0 [of "?z_hfh" "FuncSet(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (Nat \\ {0}))", OF z_Hfb])
 show FALSE
 proof (rule zenon_notand [OF z_Hfi])
  assume z_Hfl:"(~?z_hfj)"
  have z_Hfm: "(~(\\E zenon_Veg:((zenon_Veg \\in Nat)&(FuncSet(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (Nat \\ {0}))=FuncSet(isa'dotdot(1, zenon_Veg), (Nat \\ {0}))))))" (is "~(\\E x : ?z_hfu(x))")
  by (rule zenon_notin_setofall_0 [of "FuncSet(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (Nat \\ {0}))" "Nat" "(\<lambda>n. FuncSet(isa'dotdot(1, n), (Nat \\ {0})))", OF z_Hfl])
  have z_Hfv: "~?z_hfu((a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))))" (is "~(_&?z_hfw)")
  by (rule zenon_notex_0 [of "?z_hfu" "(a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))", OF z_Hfm])
  show FALSE
  proof (rule zenon_notand [OF z_Hfv])
   assume z_Hfx:"(~?z_hdl)"
   show FALSE
   by (rule notE [OF z_Hfx z_Hdl])
  next
   assume z_Hfy:"(FuncSet(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (Nat \\ {0}))~=FuncSet(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (Nat \\ {0})))" (is "?z_hel~=_")
   show FALSE
   by (rule zenon_noteq [OF z_Hfy])
  qed
 next
  assume z_Hfz:"(~?z_hfk)"
  have z_Hga: "(~?z_hek)"
  by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vzf. (~(Concat((a_ca[''sigma'']), Fcn(zenon_Vzf, (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))) \\in FuncSet(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (Nat \\ {0})))))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hfz])
  show FALSE
  by (rule notE [OF z_Hga z_Hek])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1451"; *} qed
lemma ob'1448:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
assumes v'272: "(((((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))) \<in> ((a_Mhash_primea :: c)))) \<Leftrightarrow> (((((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))) \<in> (CDomain))) \<and> (((a_h022c5783954683bdcbcacced356fd6a ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply (((a_vhash_primea :: c)), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))]))))) :: c)) & (\<exists> y \<in> (M) : (\<exists> B \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((y)) :: c)))) : (\<exists> pi \<in> ((Perm ((B)))) : ((((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))) = ((Concat ((fapply ((y), (''sigma''))), ([ m \<in> ((DOMAIN (pi)))  \<mapsto> (fapply ((v), (fapply ((pi), (m)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (B))), (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (fapply ((fapply ((y), (''fres''))), (q)))))))))))))))))"
shows "(((((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))) \<in> ((a_Mhash_primea :: c)))) \<Leftrightarrow> ((((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))) \<in> (CDomain))) & ((a_h022c5783954683bdcbcacced356fd6a ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply (((a_vhash_primea :: c)), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))]))))) :: c)) & (\<exists> y \<in> (M) : (\<exists> B \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((y)) :: c)))) : (\<exists> pi \<in> ((Perm ((B)))) : ((((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))) = ((Concat ((fapply ((y), (''sigma''))), ([ m \<in> ((DOMAIN (pi)))  \<mapsto> (fapply ((v), (fapply ((pi), (m)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (B))), (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (fapply ((fapply ((y), (''fres''))), (q)))))))))))))))"(is "PROP ?ob'1448")
proof -
ML_command {* writeln "*** TLAPS ENTER 1448"; *}
show "PROP ?ob'1448"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_dd4e57.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_dd4e57.znn.out
;; obligation #1448
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'272" (<=> (TLA.in (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q)))))
a_Mhash_primea)
(/\ (TLA.in (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q)))))
CDomain)
(/\ (a_h022c5783954683bdcbcacced356fd6a (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply a_vhash_primea (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))))
(TLA.bEx M ((y) (TLA.bEx (TLA.SUBSET (hc4e622ce2e33ef1c6a9f10c01956cd y)) ((B) (TLA.bEx (Perm B) ((pi) (/\ (= (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")
(Concat (TLA.fapply y "sigma")
(TLA.Fcn (TLA.DOMAIN pi) ((m) (TLA.fapply v (TLA.fapply pi m))))))
(TLA.bAll ProcSet ((q) (TLA.cond (TLA.in q
B) (= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
ACK) (= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
(TLA.fapply (TLA.fapply y "fres") q)))))))))))))))
$goal (<=> (TLA.in (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q)))))
a_Mhash_primea)
(/\ (TLA.in (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q)))))
CDomain)
(a_h022c5783954683bdcbcacced356fd6a (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply a_vhash_primea (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))))
(TLA.bEx M ((y) (TLA.bEx (TLA.SUBSET (hc4e622ce2e33ef1c6a9f10c01956cd y)) ((B) (TLA.bEx (Perm B) ((pi) (/\ (= (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")
(Concat (TLA.fapply y "sigma")
(TLA.Fcn (TLA.DOMAIN pi) ((m) (TLA.fapply v (TLA.fapply pi m))))))
(TLA.bAll ProcSet ((q) (TLA.cond (TLA.in q
B) (= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
ACK) (= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
(TLA.fapply (TLA.fapply y "fres") q))))))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hk:"(((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q])))))) \\in a_Mhash_primea)<=>(((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q])))))) \\in CDomain)&(a_h022c5783954683bdcbcacced356fd6a((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(a_Xhash_primea=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (a_vhash_primea[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(a_Xhash_primea=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(a_Xhash_primea=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(a_Xhash_primea=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q])))))))&bEx(M, (\<lambda>y. bEx(SUBSET(hc4e622ce2e33ef1c6a9f10c01956cd(y)), (\<lambda>B. bEx(Perm(B), (\<lambda>pi. ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma''])=Concat((y[''sigma'']), Fcn(DOMAIN(pi), (\<lambda>m. (v[(pi[m])])))))&bAll(ProcSet, (\<lambda>q. cond((q \\in B), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[q])=ACK), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[q])=((y[''fres''])[q])))))))))))))))" (is "?z_hm<=>?z_hcv")
 using v'272 by blast
 assume z_Hl:"(~(?z_hm<=>?z_hcv))"
 show FALSE
 by (rule notE [OF z_Hl z_Hk])
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1448"; *} qed
lemma ob'1439:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
assumes v'232: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'233: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'234: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'235: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'236: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'237: "((((a_jhash_primea :: c)) = (j)))"
assumes v'238: "((((a_lhash_primea :: c)) = (l)))"
assumes v'239: "((((a_xhash_primea :: c)) = (x)))"
assumes v'240: "((((a_vhash_primea :: c)) = (v)))"
assumes v'241: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca)) :: c)) & (\<exists> d \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d)) :: c)))) : (\<exists> seq \<in> ((Perm ((S)))) : ((((fapply ((a_ca), (''sigma''))) = ((Concat ((fapply ((d), (''sigma''))), ([ k \<in> ((DOMAIN (seq)))  \<mapsto> (fapply ((v), (fapply ((seq), (k)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (S))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((a_ca), (''fres''))), (q))) = (fapply ((fapply ((d), (''fres''))), (q)))))))))))))))))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'244: "(\<forall> k \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))) : ((((((fapply (((a_Qhash_primea :: c)), (k))) \<noteq> (BOT))) \<Rightarrow> (((k) \<in> (A))))) & (((((((k) \<in> (A))) \<and> (((fapply (((a_Qhash_primea :: c)), (k))) = (BOT))))) \<Rightarrow> (\<exists> q \<in> (ProcSet) : (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (k))))))))))"
assumes v'245: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'253: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
fixes z
assumes z_in : "(z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]))))"
assumes v'282: "(((fapply ((Q), (fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0]))))))))))))))) = (BOT)))"
assumes v'283: "(((fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0]))))))))))))) \<in> (A)))"
shows "(\<exists> r \<in> (ProcSet) : (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0]))))))))))))))))))"(is "PROP ?ob'1439")
proof -
ML_command {* writeln "*** TLAPS ENTER 1439"; *}
show "PROP ?ob'1439"
using assms by auto
ML_command {* writeln "*** TLAPS EXIT 1439"; *} qed
lemma ob'1492:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
fixes z
assumes z_in : "(z \<in> ((DOMAIN (fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))))))"
assumes v'293: "(((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]))), %z_1. (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))) = ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]))))))))))  \<mapsto> (cond(((leq ((z_1), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))), (fapply ((fapply ((a_ca), (''sigma''))), (z_1))), (fapply (([ z_2 \<in> ((DOMAIN ([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_4 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_4), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_3))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_4 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_4), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_3)))))))))))]), (z_2)))))]), ((arith_add ((z_1), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))])))"
shows "(((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]))), %z_1. (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))), (z))) = (cond(((leq ((z), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))), (fapply ((fapply ((a_ca), (''sigma''))), (z))), (fapply (([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]), ((arith_add ((z), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))))"(is "PROP ?ob'1492")
proof -
ML_command {* writeln "*** TLAPS ENTER 1492"; *}
show "PROP ?ob'1492"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_cb007c.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_cb007c.znn.out
;; obligation #1492
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "z_in" (TLA.in z (TLA.DOMAIN (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")))
$hyp "v'293" (= (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")
(TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1))))))) ((z_1) (TLA.cond (arith.le z_1
(a_Lena (TLA.fapply a_ca "sigma"))) (TLA.fapply (TLA.fapply a_ca "sigma") z_1) (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2))))))))) ((z_2) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_4) (TLA.fapply seq (arith.add z_4
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_3)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_4) (TLA.fapply seq (arith.add z_4
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_3)))))))) z_2)))) (arith.add z_1
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))))))
$goal (= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma") z)
(TLA.cond (arith.le z
(a_Lena (TLA.fapply a_ca "sigma"))) (TLA.fapply (TLA.fapply a_ca "sigma") z) (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1)))) (arith.add z
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hk:"(z \\in DOMAIN(((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma''])))" (is "?z_hk")
 using z_in by blast
 have z_Hl:"(((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma''])=Fcn(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (\<lambda>z_1. cond((z_1 <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[z_1]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(z_1 +  -.(a_Lena((a_ca[''sigma'']))))])))))" (is "?z_hp=?z_hcw")
 using v'293 by blast
 assume z_Hm:"((?z_hp[z])~=cond((z <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[z]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(z +  -.(a_Lena((a_ca[''sigma'']))))])))" (is "?z_hdi~=?z_hdj")
 have z_Hdo: "(z \\in DOMAIN(?z_hcw))" (is "?z_hdo")
 by (rule subst [where P="(\<lambda>zenon_Vk. (z \\in DOMAIN(zenon_Vk)))", OF z_Hl z_Hk])
 have z_Hdu: "(z \\in isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))))" (is "?z_hdu")
 by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vj. (z \\in zenon_Vj))" "isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))))" "(\<lambda>z_1. cond((z_1 <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[z_1]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(z_1 +  -.(a_Lena((a_ca[''sigma'']))))])))", OF z_Hdo])
 have z_Hdy: "((''sigma'' \\in DOMAIN((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))))&(?z_hp=Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))))" (is "?z_hdz&?z_heb")
 by ((rule zenon_recfield_1)+, rule zenon_recfield_2b)
 have z_Heb: "?z_heb" (is "_=?z_hs")
 by (rule conjD2 [OF z_Hdy])
 have z_Hec: "((?z_hs[z])~=?z_hdj)" (is "?z_hed~=_")
 by (rule subst [where P="(\<lambda>zenon_Vf. ((zenon_Vf[z])~=?z_hdj))", OF z_Heb z_Hm])
 have z_Hei: "((Concat((a_ca[''sigma'']), Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))[z])~=?z_hdj)" (is "?z_hej~=_")
 by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vgb. ((Concat((a_ca[''sigma'']), Fcn(zenon_Vgb, (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))[z])~=?z_hdj))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hec])
 have z_Hes: "(((isAFcn(?z_hp)<=>isAFcn(?z_hcw))&(DOMAIN(?z_hp)=DOMAIN(?z_hcw)))&(\\A zenon_Vh:((?z_hp[zenon_Vh])=(?z_hcw[zenon_Vh]))))" (is "?z_het&?z_hey")
 by (rule zenon_funequal_0 [of "?z_hp" "?z_hcw", OF z_Hl])
 have z_Hey: "?z_hey" (is "\\A x : ?z_hfd(x)")
 by (rule zenon_and_1 [OF z_Hes])
 have z_Hfe: "?z_hfd(z)" (is "_=?z_hff")
 by (rule zenon_all_0 [of "?z_hfd" "z", OF z_Hey])
 have z_Hdy: "(?z_hdz&?z_heb)"
 by ((rule zenon_recfield_1)+, rule zenon_recfield_2b)
 have z_Heb: "?z_heb"
 by (rule conjD2 [OF z_Hdy])
 have z_Hfg: "(?z_hed=?z_hff)"
 by (rule subst [where P="(\<lambda>zenon_Vvn. ((zenon_Vvn[z])=?z_hff))", OF z_Heb z_Hfe])
 have z_Hfl: "(?z_hej=?z_hff)"
 by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vwn. ((Concat((a_ca[''sigma'']), Fcn(zenon_Vwn, (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))[z])=?z_hff))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hfg])
 show FALSE
 proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vxn. (?z_hej=zenon_Vxn))" "isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))))" "(\<lambda>z_1. cond((z_1 <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[z_1]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(z_1 +  -.(a_Lena((a_ca[''sigma'']))))])))" "z", OF z_Hfl])
  assume z_Hfv:"(~?z_hdu)"
  show FALSE
  by (rule notE [OF z_Hfv z_Hdu])
 next
  assume z_Hfw:"(?z_hej=?z_hdj)"
  show FALSE
  by (rule notE [OF z_Hei z_Hfw])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1492"; *} qed
lemma ob'1480:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
assumes v'285: "((\<And> z :: c. z \<in> ((DOMAIN ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))) \<Longrightarrow> (((fapply (([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]), (z))) \<in> (((Nat) \\ ({((0))})))))))"
shows "(\<forall> z \<in> ((DOMAIN ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))) : (((fapply (([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]), (z))) \<in> (((Nat) \\ ({((0))}))))))"(is "PROP ?ob'1480")
proof -
ML_command {* writeln "*** TLAPS ENTER 1480"; *}
show "PROP ?ob'1480"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_d092b1.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_d092b1.znn.out
;; obligation #1480
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'285" (TLA.bAll (TLA.DOMAIN (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) ((z) (TLA.in (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1)))) z)
(TLA.setminus arith.N
(TLA.set 0)))))
$goal (TLA.bAll (TLA.DOMAIN (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) ((z) (TLA.in (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1)))) z)
(TLA.setminus arith.N
(TLA.set 0)))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hk:"bAll(DOMAIN(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))), (\<lambda>z. ((Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[z]) \\in (Nat \\ {0}))))" (is "?z_hk")
 using v'285 by blast
 assume z_Hl:"(~?z_hk)"
 show FALSE
 by (rule notE [OF z_Hl z_Hk])
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1480"; *} qed
lemma ob'1458:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'235: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'236: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'244: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
shows "(((fapply ((((''sigma'' :> ([ k_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))))))))  \<mapsto> (cond(((leq ((k_1), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))), (fapply ((fapply ((a_ca), (''sigma''))), (k_1))), (fapply (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]), ((arith_add ((k_1), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))])) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))) = ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))))))))  \<mapsto> (cond(((leq ((z), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))), (fapply ((fapply ((a_ca), (''sigma''))), (z))), (fapply (([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]), ((arith_add ((z), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))])))"(is "PROP ?ob'1458")
proof -
ML_command {* writeln "*** TLAPS ENTER 1458"; *}
show "PROP ?ob'1458"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_6520bd.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_6520bd.znn.out
;; obligation #1458
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'235" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'236" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'244" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$goal (= (TLA.fapply (TLA.record "sigma" (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))))) ((k_1) (TLA.cond (arith.le k_1
(a_Lena (TLA.fapply a_ca "sigma"))) (TLA.fapply (TLA.fapply a_ca "sigma") k_1) (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) (arith.add k_1
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")
(TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))))) ((z) (TLA.cond (arith.le z
(a_Lena (TLA.fapply a_ca "sigma"))) (TLA.fapply (TLA.fapply a_ca "sigma") z) (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1)))) (arith.add z
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 assume z_Hk:"(((''sigma'' :> (Fcn(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (\<lambda>k_1. cond((k_1 <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[k_1]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(k_1 +  -.(a_Lena((a_ca[''sigma'']))))]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma''])~=Fcn(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (\<lambda>k_1. cond((k_1 <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[k_1]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(k_1 +  -.(a_Lena((a_ca[''sigma'']))))])))))" (is "?z_hl~=?z_ho")
 have z_Hdf: "((''sigma'' \\in DOMAIN((''sigma'' :> (?z_ho) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))))&(?z_hl=?z_ho))" (is "?z_hdg&?z_hdi")
 by ((rule zenon_recfield_1)+, rule zenon_recfield_2b)
 have z_Hdi: "?z_hdi"
 by (rule conjD2 [OF z_Hdf])
 have z_Hdj: "(?z_ho~=?z_ho)"
 by (rule subst [where P="(\<lambda>zenon_Vf. (zenon_Vf~=?z_ho))", OF z_Hdi z_Hk])
 show FALSE
 by (rule zenon_noteq [OF z_Hdj])
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1458"; *} qed
lemma ob'1532:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
fixes z
assumes z_in : "(z \<in> ((DOMAIN (fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))))))"
assumes v'293: "(((z) \<in> (Nat)))"
assumes v'298: "((greater ((z), ((a_Lena ((fapply ((a_ca), (''sigma'')))))))))"
assumes v'305: "(((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]))), %z_1. (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))) = ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]))))))))))  \<mapsto> (cond(((leq ((z_1), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))), (fapply ((fapply ((a_ca), (''sigma''))), (z_1))), (fapply (([ z_2 \<in> ((DOMAIN ([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_4 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_4), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_3))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_4 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_4), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_3)))))))))))]), (z_2)))))]), ((arith_add ((z_1), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))])))"
assumes v'306: "((((a_Lena ((fapply ((a_ca), (''sigma'')))))) \<in> (Nat)))"
assumes v'307: "((((a_Lena (([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))])))) \<in> (Nat)))"
assumes v'308: "((((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]))))))) \<in> (Nat)))"
assumes v'309: "(\<forall> q \<in> (Nat) : (\<forall> m \<in> (Nat) : (\<forall> n \<in> (Nat) : (((((((((m) \<in> ((isa_peri_peri_a (((Succ[0])), (q)))))) \<and> (((n) \<in> ((isa_peri_peri_a (((0)), (q)))))))) \<and> ((greater ((m), (n)))))) \<Rightarrow> (((m) \<in> ((isa_peri_peri_a (((arith_add ((n), ((Succ[0]))))), (q)))))))))))"
shows "((((((a_Lena ((fapply ((a_ca), (''sigma'')))))) \<in> ((isa_peri_peri_a (((0)), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))])))))))))))) \<Rightarrow> (((z) \<in> ((isa_peri_peri_a (((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((Succ[0]))))), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]))))))))))))))"(is "PROP ?ob'1532")
proof -
ML_command {* writeln "*** TLAPS ENTER 1532"; *}
show "PROP ?ob'1532"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_c9faa2.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_c9faa2.znn.out
;; obligation #1532
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "z_in" (TLA.in z (TLA.DOMAIN (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")))
$hyp "v'293" (TLA.in z
arith.N)
$hyp "v'298" (arith.lt (a_Lena (TLA.fapply a_ca "sigma"))
z)
$hyp "v'305" (= (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")
(TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1))))))) ((z_1) (TLA.cond (arith.le z_1
(a_Lena (TLA.fapply a_ca "sigma"))) (TLA.fapply (TLA.fapply a_ca "sigma") z_1) (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2))))))))) ((z_2) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_4) (TLA.fapply seq (arith.add z_4
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_3)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_4) (TLA.fapply seq (arith.add z_4
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_3)))))))) z_2)))) (arith.add z_1
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))))))
$hyp "v'306" (TLA.in (a_Lena (TLA.fapply a_ca "sigma"))
arith.N)
$hyp "v'307" (TLA.in (a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1)))))
arith.N)
$hyp "v'308" (TLA.in (arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1))))))
arith.N)
$hyp "v'309" (TLA.bAll arith.N ((q) (TLA.bAll arith.N ((m) (TLA.bAll arith.N ((n) (=> (/\ (/\ (TLA.in m
(arith.intrange (TLA.fapply TLA.Succ 0) q)) (TLA.in n (arith.intrange 0 q)))
(arith.lt n m)) (TLA.in m (arith.intrange (arith.add n
(TLA.fapply TLA.Succ 0))
q)))))))))
$goal (=> (TLA.in (a_Lena (TLA.fapply a_ca "sigma")) (arith.intrange 0
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1)))))))) (TLA.in z
(arith.intrange (arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(TLA.fapply TLA.Succ 0)) (arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1)))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hr:"bAll(Nat, (\<lambda>q. bAll(Nat, (\<lambda>m. bAll(Nat, (\<lambda>n. ((((m \\in isa'dotdot(1, q))&(n \\in isa'dotdot(0, q)))&(n < m))=>(m \\in isa'dotdot((n + 1), q)))))))))" (is "?z_hr")
 using v'309 by blast
 have z_Hn:"(((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma''])=Fcn(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (\<lambda>z_1. cond((z_1 <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[z_1]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(z_1 +  -.(a_Lena((a_ca[''sigma'']))))])))))" (is "?z_hbp=?z_hdv")
 using v'305 by blast
 have z_Hk:"(z \\in DOMAIN(?z_hbp))" (is "?z_hk")
 using z_in by blast
 have z_Ho:"(a_Lena((a_ca[''sigma''])) \\in Nat)" (is "?z_ho")
 using v'306 by blast
 have z_Hm:"(a_Lena((a_ca[''sigma''])) < z)" (is "?z_hm")
 using v'298 by blast
 have z_Hl:"(z \\in Nat)" (is "?z_hl")
 using v'293 by blast
 have z_Hq:"((a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) \\in Nat)" (is "?z_hq")
 using v'308 by blast
 assume z_Hs:"(~((a_Lena((a_ca[''sigma''])) \\in isa'dotdot(0, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))))=>(z \\in isa'dotdot((a_Lena((a_ca[''sigma''])) + 1), (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))))))" (is "~(?z_hej=>?z_hel)")
 have z_Heo_z_Hr: "(\\A x:((x \\in Nat)=>bAll(Nat, (\<lambda>m. bAll(Nat, (\<lambda>n. ((((m \\in isa'dotdot(1, x))&(n \\in isa'dotdot(0, x)))&(n < m))=>(m \\in isa'dotdot((n + 1), x))))))))) == ?z_hr" (is "?z_heo == _")
 by (unfold bAll_def)
 have z_Heo: "?z_heo" (is "\\A x : ?z_hff(x)")
 by (unfold z_Heo_z_Hr, fact z_Hr)
 have z_Hej: "?z_hej"
 by (rule zenon_notimply_0 [OF z_Hs])
 have z_Hfg: "(~?z_hel)"
 by (rule zenon_notimply_1 [OF z_Hs])
 have z_Hfh: "(a_Lena((a_ca[''sigma''])) \\in isa'dotdot(0, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))))" (is "?z_hfh")
 by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vcb. (a_Lena((a_ca[''sigma''])) \\in isa'dotdot(0, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(zenon_Vcb, (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))))))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hej])
 have z_Hft: "(~(z \\in isa'dotdot((a_Lena((a_ca[''sigma''])) + 1), (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))))))" (is "~?z_hfu")
 by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vab. (~(z \\in isa'dotdot((a_Lena((a_ca[''sigma''])) + 1), (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(zenon_Vab, (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))))))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hfg])
 have z_Hge: "(z \\in DOMAIN(?z_hdv))" (is "?z_hge")
 by (rule subst [where P="(\<lambda>zenon_Vu. (z \\in DOMAIN(zenon_Vu)))", OF z_Hn z_Hk])
 have z_Hgk: "(z \\in isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))))" (is "?z_hgk")
 by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vr. (z \\in zenon_Vr))" "isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))))" "(\<lambda>z_1. cond((z_1 <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[z_1]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(z_1 +  -.(a_Lena((a_ca[''sigma'']))))])))", OF z_Hge])
 have z_Hgo: "(z \\in isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))))" (is "?z_hgo")
 by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vzb. (z \\in isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(zenon_Vzb, (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))))))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hgk])
 have z_Hgx: "((a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) \\in Nat)" (is "?z_hgx")
 by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vh. ((a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(zenon_Vh, (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) \\in Nat))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hq])
 have z_Hhe: "?z_hff((a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))))" (is "_=>?z_hhf")
 by (rule zenon_all_0 [of "?z_hff" "(a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))", OF z_Heo])
 show FALSE
 proof (rule zenon_imply [OF z_Hhe])
  assume z_Hhg:"(~?z_hgx)"
  show FALSE
  by (rule notE [OF z_Hhg z_Hgx])
 next
  assume z_Hhf:"?z_hhf"
  have z_Hhh_z_Hhf: "(\\A x:((x \\in Nat)=>bAll(Nat, (\<lambda>n. ((((x \\in isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))))&(n \\in isa'dotdot(0, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))))))&(n < x))=>(x \\in isa'dotdot((n + 1), (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))))))))) == ?z_hhf" (is "?z_hhh == _")
  by (unfold bAll_def)
  have z_Hhh: "?z_hhh" (is "\\A x : ?z_hht(x)")
  by (unfold z_Hhh_z_Hhf, fact z_Hhf)
  have z_Hhu: "?z_hht(z)" (is "_=>?z_hhv")
  by (rule zenon_all_0 [of "?z_hht" "z", OF z_Hhh])
  show FALSE
  proof (rule zenon_imply [OF z_Hhu])
   assume z_Hhw:"(~?z_hl)"
   show FALSE
   by (rule notE [OF z_Hhw z_Hl])
  next
   assume z_Hhv:"?z_hhv"
   have z_Hhx_z_Hhv: "(\\A x:((x \\in Nat)=>(((?z_hgo&(x \\in isa'dotdot(0, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))))))&(x < z))=>(z \\in isa'dotdot((x + 1), (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))))))) == ?z_hhv" (is "?z_hhx == _")
   by (unfold bAll_def)
   have z_Hhx: "?z_hhx" (is "\\A x : ?z_hih(x)")
   by (unfold z_Hhx_z_Hhv, fact z_Hhv)
   have z_Hii: "?z_hih(a_Lena((a_ca[''sigma''])))" (is "_=>?z_hij")
   by (rule zenon_all_0 [of "?z_hih" "a_Lena((a_ca[''sigma'']))", OF z_Hhx])
   show FALSE
   proof (rule zenon_imply [OF z_Hii])
    assume z_Hik:"(~?z_ho)"
    show FALSE
    by (rule notE [OF z_Hik z_Ho])
   next
    assume z_Hij:"?z_hij" (is "?z_hil=>_")
    show FALSE
    proof (rule zenon_imply [OF z_Hij])
     assume z_Him:"(~?z_hil)" (is "~(?z_hin&_)")
     show FALSE
     proof (rule zenon_notand [OF z_Him])
      assume z_Hio:"(~?z_hin)"
      show FALSE
      proof (rule zenon_notand [OF z_Hio])
       assume z_Hip:"(~?z_hgo)"
       show FALSE
       by (rule notE [OF z_Hip z_Hgo])
      next
       assume z_Hiq:"(~?z_hfh)"
       show FALSE
       by (rule notE [OF z_Hiq z_Hfh])
      qed
     next
      assume z_Hir:"(~?z_hm)"
      show FALSE
      by (rule notE [OF z_Hir z_Hm])
     qed
    next
     assume z_Hfu:"?z_hfu"
     show FALSE
     by (rule notE [OF z_Hft z_Hfu])
    qed
   qed
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1532"; *} qed
lemma ob'1528:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
fixes z
assumes z_in : "(z \<in> ((DOMAIN (fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))))))"
assumes v'293: "(((z) \<in> (Nat)))"
assumes v'298: "((greater ((z), ((a_Lena ((fapply ((a_ca), (''sigma'')))))))))"
shows "((((((arith_add ((z), ((minus (((a_Lena ((fapply ((a_ca), (''sigma'')))))))))))) \<in> ((DOMAIN ([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]))))) \<Rightarrow> (((fapply (([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]), ((arith_add ((z), ((minus (((a_Lena ((fapply ((a_ca), (''sigma'')))))))))))))) = (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), ((arith_add ((z), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))))))"(is "PROP ?ob'1528")
proof -
ML_command {* writeln "*** TLAPS ENTER 1528"; *}
show "PROP ?ob'1528"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_432994.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_432994.znn.out
;; obligation #1528
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "z_in" (TLA.in z (TLA.DOMAIN (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")))
$hyp "v'293" (TLA.in z
arith.N)
$hyp "v'298" (arith.lt (a_Lena (TLA.fapply a_ca "sigma"))
z)
$goal (=> (TLA.in (arith.add z
(arith.minus (a_Lena (TLA.fapply a_ca "sigma"))))
(TLA.DOMAIN (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1))))))
(= (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1)))) (arith.add z
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))
(TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) (arith.add z
(arith.minus (a_Lena (TLA.fapply a_ca "sigma"))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 assume z_Hn:"(~(((z +  -.(a_Lena((a_ca[''sigma''])))) \\in DOMAIN(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))=>((Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(z +  -.(a_Lena((a_ca[''sigma'']))))])=(v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[(z +  -.(a_Lena((a_ca[''sigma'']))))])]))))" (is "~(?z_hp=>?z_hco)")
 have z_Hp: "?z_hp"
 by (rule zenon_notimply_0 [OF z_Hn])
 have z_Hcs: "((Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(z +  -.(a_Lena((a_ca[''sigma'']))))])~=(v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[(z +  -.(a_Lena((a_ca[''sigma'']))))])]))" (is "?z_hcp~=?z_hcq")
 by (rule zenon_notimply_1 [OF z_Hn])
 have z_Hct: "((z +  -.(a_Lena((a_ca[''sigma''])))) \\in DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))))" (is "?z_hct")
 by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vsa. ((z +  -.(a_Lena((a_ca[''sigma''])))) \\in zenon_Vsa))" "DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))))" "(\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))", OF z_Hp])
 show FALSE
 proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vqa. (zenon_Vqa~=?z_hcq))" "DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))))" "(\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))" "(z +  -.(a_Lena((a_ca[''sigma'']))))", OF z_Hcs])
  assume z_Hda:"(~?z_hct)"
  show FALSE
  by (rule notE [OF z_Hda z_Hct])
 next
  assume z_Hdb:"(?z_hcq~=?z_hcq)"
  show FALSE
  by (rule zenon_noteq [OF z_Hdb])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1528"; *} qed
lemma ob'1495:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
fixes z
assumes z_in : "(z \<in> ((DOMAIN (fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))))))"
assumes v'294: "(((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]))), %z_1. (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))) = ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]))))))))))  \<mapsto> (cond(((leq ((z_1), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))), (fapply ((fapply ((a_ca), (''sigma''))), (z_1))), (fapply (([ z_2 \<in> ((DOMAIN ([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_4 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_4), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_3))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_4 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_4), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_3)))))))))))]), (z_2)))))]), ((arith_add ((z_1), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))])))"
shows "(((z) \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]))))))))))))"(is "PROP ?ob'1495")
proof -
ML_command {* writeln "*** TLAPS ENTER 1495"; *}
show "PROP ?ob'1495"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_ef39ca.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_ef39ca.znn.out
;; obligation #1495
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "z_in" (TLA.in z (TLA.DOMAIN (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")))
$hyp "v'294" (= (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")
(TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1))))))) ((z_1) (TLA.cond (arith.le z_1
(a_Lena (TLA.fapply a_ca "sigma"))) (TLA.fapply (TLA.fapply a_ca "sigma") z_1) (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2))))))))) ((z_2) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_4) (TLA.fapply seq (arith.add z_4
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_3)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_4) (TLA.fapply seq (arith.add z_4
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_3)))))))) z_2)))) (arith.add z_1
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))))))
$goal (TLA.in z (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hl:"(((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma''])=Fcn(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (\<lambda>z_1. cond((z_1 <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[z_1]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(z_1 +  -.(a_Lena((a_ca[''sigma'']))))])))))" (is "?z_hn=?z_hcv")
 using v'294 by blast
 have z_Hk:"(z \\in DOMAIN(?z_hn))" (is "?z_hk")
 using z_in by blast
 assume z_Hm:"(~(z \\in isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))))))" (is "~?z_hdi")
 have z_Hdj: "(z \\in DOMAIN(?z_hcv))" (is "?z_hdj")
 by (rule subst [where P="(\<lambda>zenon_Vl. (z \\in DOMAIN(zenon_Vl)))", OF z_Hl z_Hk])
 have z_Hdi: "?z_hdi"
 by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vk. (z \\in zenon_Vk))" "isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))))" "(\<lambda>z_1. cond((z_1 <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[z_1]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(z_1 +  -.(a_Lena((a_ca[''sigma'']))))])))", OF z_Hdj])
 show FALSE
 by (rule notE [OF z_Hm z_Hdi])
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1495"; *} qed
lemma ob'1576:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
assumes v'289: "(((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))) = ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))))))))  \<mapsto> (cond(((leq ((z), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))), (fapply ((fapply ((a_ca), (''sigma''))), (z))), (fapply (([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]), ((arith_add ((z), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))])))"
assumes v'290: "(\<forall> z \<in> ((DOMAIN (fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))))) : (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]))), %z_1. (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))), (z))) \<in> (((Nat) \\ ({((0))}))))))"
assumes v'291: "((((DOMAIN (fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))))) = ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))))))))))"
shows "(((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))) \<in> ([((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))])))))))))) \<rightarrow> (((Nat) \\ ({((0))})))])))"(is "PROP ?ob'1576")
proof -
ML_command {* writeln "*** TLAPS ENTER 1576"; *}
show "PROP ?ob'1576"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_b67785.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_b67785.znn.out
;; obligation #1576
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'289" (= (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")
(TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))))) ((z) (TLA.cond (arith.le z
(a_Lena (TLA.fapply a_ca "sigma"))) (TLA.fapply (TLA.fapply a_ca "sigma") z) (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1)))) (arith.add z
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))))))
$hyp "v'290" (TLA.bAll (TLA.DOMAIN (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")) ((z) (TLA.in (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma") z)
(TLA.setminus arith.N
(TLA.set 0)))))
$hyp "v'291" (= (TLA.DOMAIN (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma"))
(arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))))))
$goal (TLA.in (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")
(TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))))) (TLA.setminus arith.N
(TLA.set 0))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hk:"(((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma''])=Fcn(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (\<lambda>z. cond((z <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[z]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(z +  -.(a_Lena((a_ca[''sigma'']))))])))))" (is "?z_ho=?z_hcw")
 using v'289 by blast
 have z_Hm:"(DOMAIN(?z_ho)=isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))))" (is "?z_hdi=?z_hcx")
 using v'291 by blast
 have z_Hl:"bAll(?z_hdi, (\<lambda>z. ((?z_ho[z]) \\in (Nat \\ {0}))))" (is "?z_hl")
 using v'290 by blast
 assume z_Hn:"(~(?z_ho \\in FuncSet(?z_hcx, (Nat \\ {0}))))" (is "~?z_hdq")
 have z_Hds: "((''sigma'' \\in DOMAIN((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))))&(?z_ho=Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))))" (is "?z_hdt&?z_hdv")
 by ((rule zenon_recfield_1)+, rule zenon_recfield_2b)
 have z_Hdv: "?z_hdv" (is "_=?z_hr")
 by (rule conjD2 [OF z_Hds])
 have z_Hdw: "(?z_hr=?z_hcw)"
 by (rule subst [where P="(\<lambda>zenon_Vn. (zenon_Vn=?z_hcw))", OF z_Hdv z_Hk])
 have z_Hds: "(?z_hdt&?z_hdv)"
 by ((rule zenon_recfield_1)+, rule zenon_recfield_2b)
 have z_Hdv: "?z_hdv"
 by (rule conjD2 [OF z_Hds])
 have z_Hea: "bAll(DOMAIN(?z_hr), (\<lambda>z. ((?z_ho[z]) \\in (Nat \\ {0}))))" (is "?z_hea")
 by (rule subst [where P="(\<lambda>zenon_Vm. bAll(DOMAIN(zenon_Vm), (\<lambda>z. ((?z_ho[z]) \\in (Nat \\ {0})))))", OF z_Hdv z_Hl])
 have z_Heg: "bAll(DOMAIN(?z_hcw), (\<lambda>z. ((?z_ho[z]) \\in (Nat \\ {0}))))" (is "?z_heg")
 by (rule subst [where P="(\<lambda>zenon_Vm. bAll(DOMAIN(zenon_Vm), (\<lambda>z. ((?z_ho[z]) \\in (Nat \\ {0})))))", OF z_Hdw z_Hea])
 have z_Hei: "bAll(?z_hcx, (\<lambda>z. ((?z_ho[z]) \\in (Nat \\ {0}))))" (is "?z_hei")
 by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vl. bAll(zenon_Vl, (\<lambda>z. ((?z_ho[z]) \\in (Nat \\ {0})))))" "?z_hcx" "(\<lambda>z. cond((z <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[z]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(z +  -.(a_Lena((a_ca[''sigma'']))))])))", OF z_Heg])
 have z_Hem_z_Hei: "(\\A zenon_Vh:((zenon_Vh \\in ?z_hcx)=>((?z_ho[zenon_Vh]) \\in (Nat \\ {0})))) == ?z_hei" (is "?z_hem == _")
 by (unfold bAll_def)
 have z_Hem: "?z_hem" (is "\\A x : ?z_hes(x)")
 by (unfold z_Hem_z_Hei, fact z_Hei)
 show FALSE
 proof (rule zenon_notin_funcset [of "?z_ho" "?z_hcx" "(Nat \\ {0})", OF z_Hn])
  assume z_Het:"(~isAFcn(?z_ho))" (is "~?z_heu")
  have z_Hev: "(~isAFcn(?z_hcw))" (is "~?z_hew")
  by (rule subst [where P="(\<lambda>zenon_Vng. (~isAFcn(zenon_Vng)))", OF z_Hk z_Het])
  show FALSE
  by (rule zenon_notisafcn_fcn [of "?z_hcx" "(\<lambda>z. cond((z <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[z]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(z +  -.(a_Lena((a_ca[''sigma'']))))])))", OF z_Hev])
 next
  assume z_Hfb:"(?z_hdi~=?z_hcx)"
  show FALSE
  by (rule notE [OF z_Hfb z_Hm])
 next
  assume z_Hfc:"(~?z_hem)"
  show FALSE
  by (rule notE [OF z_Hfc z_Hem])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1576"; *} qed
lemma ob'1573:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
assumes v'288: "(((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))) = ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))))))))  \<mapsto> (cond(((leq ((z), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))), (fapply ((fapply ((a_ca), (''sigma''))), (z))), (fapply (([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]), ((arith_add ((z), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))])))"
shows "((((DOMAIN (fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))))) = ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))))))))))"(is "PROP ?ob'1573")
proof -
ML_command {* writeln "*** TLAPS ENTER 1573"; *}
show "PROP ?ob'1573"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_3af996.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_3af996.znn.out
;; obligation #1573
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'288" (= (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")
(TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))))) ((z) (TLA.cond (arith.le z
(a_Lena (TLA.fapply a_ca "sigma"))) (TLA.fapply (TLA.fapply a_ca "sigma") z) (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1)))) (arith.add z
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))))))
$goal (= (TLA.DOMAIN (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma"))
(arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hk:"(((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma''])=Fcn(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (\<lambda>z. cond((z <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[z]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(z +  -.(a_Lena((a_ca[''sigma'']))))])))))" (is "?z_hm=?z_hcu")
 using v'288 by blast
 assume z_Hl:"(DOMAIN(?z_hm)~=isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))))" (is "?z_hdg~=?z_hcv")
 have z_Hdh: "((''sigma'' \\in DOMAIN((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))))&(?z_hm=Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))))" (is "?z_hdi&?z_hdk")
 by ((rule zenon_recfield_1)+, rule zenon_recfield_2b)
 have z_Hdk: "?z_hdk" (is "_=?z_hp")
 by (rule conjD2 [OF z_Hdh])
 have z_Hdl: "(?z_hp=?z_hcu)"
 by (rule subst [where P="(\<lambda>zenon_Vi. (zenon_Vi=?z_hcu))", OF z_Hdk z_Hk])
 have z_Hdh: "(?z_hdi&?z_hdk)"
 by ((rule zenon_recfield_1)+, rule zenon_recfield_2b)
 have z_Hdk: "?z_hdk"
 by (rule conjD2 [OF z_Hdh])
 have z_Hdp: "(DOMAIN(?z_hp)~=?z_hcv)" (is "?z_hdq~=_")
 by (rule subst [where P="(\<lambda>zenon_Vg. (DOMAIN(zenon_Vg)~=?z_hcv))", OF z_Hdk z_Hl])
 have z_Hdv: "(DOMAIN(?z_hcu)~=?z_hcv)" (is "?z_hdw~=_")
 by (rule subst [where P="(\<lambda>zenon_Vg. (DOMAIN(zenon_Vg)~=?z_hcv))", OF z_Hdl z_Hdp])
 have z_Hdx: "(?z_hcv~=?z_hcv)"
 by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vf. (zenon_Vf~=?z_hcv))" "?z_hcv" "(\<lambda>z. cond((z <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[z]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(z +  -.(a_Lena((a_ca[''sigma'']))))])))", OF z_Hdv])
 show FALSE
 by (rule zenon_noteq [OF z_Hdx])
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1573"; *} qed
lemma ob'1564:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition vseqp suppressed *)
(* usable definition P suppressed *)
fixes z
assumes z_in : "(z \<in> ((DOMAIN (fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), (vseqp))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))))))"
assumes v'294: "(((z) \<in> (Nat)))"
assumes v'299: "((greater ((z), ((a_Lena ((fapply ((a_ca), (''sigma'')))))))))"
assumes v'315: "(\<forall> n \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]))) : (((fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (n))) \<in> (ProcSet))))"
assumes v'316: "((((arith_add ((z), ((minus (((a_Lena ((fapply ((a_ca), (''sigma'')))))))))))) \<in> ((isa_peri_peri_a (((Succ[0])), ((a_Lena ((vseqp)))))))))"
assumes v'317: "((((DOMAIN (vseqp))) = ((isa_peri_peri_a (((Succ[0])), ((a_Lena ((vseqp)))))))))"
assumes v'318: "((((DOMAIN (vseqp))) = ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))))"
shows "(((fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), ((arith_add ((z), ((minus (((a_Lena ((fapply ((a_ca), (''sigma'')))))))))))))) \<in> (ProcSet)))"(is "PROP ?ob'1564")
proof -
ML_command {* writeln "*** TLAPS ENTER 1564"; *}
show "PROP ?ob'1564"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_b22b7e.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_b22b7e.znn.out
;; obligation #1564
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "z_in" (TLA.in z (TLA.DOMAIN (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
vseqp) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")))
$hyp "v'294" (TLA.in z
arith.N)
$hyp "v'299" (arith.lt (a_Lena (TLA.fapply a_ca "sigma"))
z)
$hyp "v'315" (TLA.bAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((n) (TLA.in (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) n)
ProcSet)))
$hyp "v'316" (TLA.in (arith.add z
(arith.minus (a_Lena (TLA.fapply a_ca "sigma"))))
(arith.intrange (TLA.fapply TLA.Succ 0)
(a_Lena vseqp)))
$hyp "v'317" (= (TLA.DOMAIN vseqp) (arith.intrange (TLA.fapply TLA.Succ 0)
(a_Lena vseqp)))
$hyp "v'318" (= (TLA.DOMAIN vseqp)
(TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))))
$goal (TLA.in (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) (arith.add z
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))
ProcSet)
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hn:"bAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>n. ((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[n]) \\in ProcSet)))" (is "?z_hn")
 using v'315 by blast
 have z_Hq:"(DOMAIN(vseqp)=DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))))" (is "?z_hci=?z_hs")
 using v'318 by blast
 have z_Hp:"(?z_hci=isa'dotdot(1, a_Lena(vseqp)))" (is "_=?z_hck")
 using v'317 by blast
 have z_Ho:"((z +  -.(a_Lena((a_ca[''sigma''])))) \\in ?z_hck)" (is "?z_ho")
 using v'316 by blast
 assume z_Hr:"(~((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[(z +  -.(a_Lena((a_ca[''sigma'']))))]) \\in ProcSet))" (is "~?z_hcs")
 have z_Hcu: "bAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>n. ((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[n]) \\in ProcSet)))" (is "?z_hcu")
 by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vp. bAll(zenon_Vp, (\<lambda>n. ((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[n]) \\in ProcSet))))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hn])
 have z_Hcy_z_Hcu: "(\\A x:((x \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))=>((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[x]) \\in ProcSet))) == ?z_hcu" (is "?z_hcy == _")
 by (unfold bAll_def)
 have z_Hcy: "?z_hcy" (is "\\A x : ?z_hde(x)")
 by (unfold z_Hcy_z_Hcu, fact z_Hcu)
 have z_Hdf: "(?z_hci=isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))" (is "_=?z_hu")
 by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vh. (?z_hci=zenon_Vh))" "?z_hu" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(?z_hu, (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(?z_hu, (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hq])
 have z_Hdj: "?z_hde((z +  -.(a_Lena((a_ca[''sigma''])))))" (is "?z_hdk=>_")
 by (rule zenon_all_0 [of "?z_hde" "(z +  -.(a_Lena((a_ca[''sigma'']))))", OF z_Hcy])
 show FALSE
 proof (rule zenon_imply [OF z_Hdj])
  assume z_Hdl:"(~?z_hdk)"
  show FALSE
  proof (rule notE [OF z_Hdl])
   have z_Hdm: "(?z_hck=?z_hu)"
   proof (rule zenon_nnpp [of "(?z_hck=?z_hu)"])
    assume z_Hdn:"(?z_hck~=?z_hu)"
    show FALSE
    proof (rule zenon_em [of "(?z_hu=?z_hu)"])
     assume z_Hdo:"(?z_hu=?z_hu)"
     show FALSE
     proof (rule notE [OF z_Hdn])
      have z_Hdp: "(?z_hu=?z_hck)"
      proof (rule zenon_nnpp [of "(?z_hu=?z_hck)"])
       assume z_Hdq:"(?z_hu~=?z_hck)"
       show FALSE
       proof (rule notE [OF z_Hdq])
        have z_Hdp: "(?z_hu=?z_hck)"
        by (rule subst [where P="(\<lambda>zenon_Vk. (zenon_Vk=?z_hck))", OF z_Hdf], fact z_Hp)
        thus "(?z_hu=?z_hck)" .
       qed
      qed
      have z_Hdm: "(?z_hck=?z_hu)"
      by (rule subst [where P="(\<lambda>zenon_Vrb. (zenon_Vrb=?z_hu))", OF z_Hdp], fact z_Hdo)
      thus "(?z_hck=?z_hu)" .
     qed
    next
     assume z_Hdx:"(?z_hu~=?z_hu)"
     show FALSE
     by (rule zenon_noteq [OF z_Hdx])
    qed
   qed
   have z_Hdk: "?z_hdk"
   by (rule subst [where P="(\<lambda>zenon_Vo. ((z +  -.(a_Lena((a_ca[''sigma''])))) \\in zenon_Vo))", OF z_Hdm], fact z_Ho)
   thus "?z_hdk" .
  qed
 next
  assume z_Hcs:"?z_hcs"
  show FALSE
  by (rule notE [OF z_Hr z_Hcs])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1564"; *} qed
lemma ob'1559:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition vseqp suppressed *)
(* usable definition P suppressed *)
fixes z
assumes z_in : "(z \<in> ((DOMAIN (fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), (vseqp))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))))))"
assumes v'294: "(((z) \<in> (Nat)))"
assumes v'299: "((greater ((z), ((a_Lena ((fapply ((a_ca), (''sigma'')))))))))"
fixes n
assumes n_in : "(n \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]))))"
fixes r
assumes r_in : "(r \<in> (ProcSet))"
assumes v'322: "(((r) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r_1. (((((((r_1) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r_1))) = (''E2''))) \<and> (((fapply ((i), (r_1))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (n)))))"
shows "(((fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r_1. (((((((r_1) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r_1))) = (''E2''))) \<and> (((fapply ((i), (r_1))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (n))) \<in> (ProcSet)))"(is "PROP ?ob'1559")
proof -
ML_command {* writeln "*** TLAPS ENTER 1559"; *}
show "PROP ?ob'1559"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_b5ccbb.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_b5ccbb.znn.out
;; obligation #1559
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "z_in" (TLA.in z (TLA.DOMAIN (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
vseqp) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")))
$hyp "v'294" (TLA.in z
arith.N)
$hyp "v'299" (arith.lt (a_Lena (TLA.fapply a_ca "sigma"))
z)
$hyp "n_in" (TLA.in n (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))))
$hyp "r_in" (TLA.in r ProcSet)
$hyp "v'322" (= r
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r_1) (\/ (/\ (= r_1
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r_1) "E2") (= (TLA.fapply i r_1)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) n))
$goal (TLA.in (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r_1) (\/ (/\ (= r_1
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r_1) "E2") (= (TLA.fapply i r_1)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) n)
ProcSet)
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hp:"(r=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[n]))" (is "_=?z_hs")
 using v'322 by blast
 have z_Ho:"(r \\in ProcSet)" (is "?z_ho")
 using r_in by blast
 assume z_Hq:"(~(?z_hs \\in ProcSet))" (is "~?z_hce")
 have z_Hce: "?z_hce"
 by (rule subst [where P="(\<lambda>zenon_Vh. (zenon_Vh \\in ProcSet))", OF z_Hp z_Ho])
 show FALSE
 by (rule notE [OF z_Hq z_Hce])
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1559"; *} qed
lemma ob'1619:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition seqp suppressed *)
(* usable definition P suppressed *)
assumes v'281: "(((v) = ((a_vhash_primea :: c))))"
assumes v'282: "(((seqp) = ((a_h6b857f034661d44d3a40954f58ee32a :: c))))"
shows "(((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN (seqp)))  \<mapsto> (fapply ((v), (fapply ((seqp), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN (seqp))), %z. (fapply ((seqp), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))) = (fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ((a_h6b857f034661d44d3a40954f58ee32a :: c))))  \<mapsto> (fapply (((a_vhash_primea :: c)), (fapply (((a_h6b857f034661d44d3a40954f58ee32a :: c)), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ((a_h6b857f034661d44d3a40954f58ee32a :: c)))), %z. (fapply (((a_h6b857f034661d44d3a40954f58ee32a :: c)), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma'')))))"(is "PROP ?ob'1619")
proof -
ML_command {* writeln "*** TLAPS ENTER 1619"; *}
show "PROP ?ob'1619"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_e33c45.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_e33c45.znn.out
;; obligation #1619
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'281" (= v a_vhash_primea)
$hyp "v'282" (= seqp
a_h6b857f034661d44d3a40954f58ee32a)
$goal (= (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN seqp) ((z) (TLA.fapply v (TLA.fapply seqp z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN seqp) ((z) (TLA.fapply seqp z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")
(TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN a_h6b857f034661d44d3a40954f58ee32a) ((z) (TLA.fapply a_vhash_primea (TLA.fapply a_h6b857f034661d44d3a40954f58ee32a z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN a_h6b857f034661d44d3a40954f58ee32a) ((z) (TLA.fapply a_h6b857f034661d44d3a40954f58ee32a z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma"))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hk:"(v=a_vhash_primea)"
 using v'281 by blast
 have z_Hl:"(seqp=a_h6b857f034661d44d3a40954f58ee32a)"
 using v'282 by blast
 assume z_Hm:"(((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(seqp), (\<lambda>z. (v[(seqp[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(seqp), (\<lambda>z. (seqp[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma''])~=((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(a_h6b857f034661d44d3a40954f58ee32a), (\<lambda>z. (a_vhash_primea[(a_h6b857f034661d44d3a40954f58ee32a[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(a_h6b857f034661d44d3a40954f58ee32a), (\<lambda>z. (a_h6b857f034661d44d3a40954f58ee32a[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma'']))" (is "?z_hr~=?z_hbp")
 have z_Hcd: "((''sigma'' \\in DOMAIN((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(seqp), (\<lambda>z. (v[(seqp[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(seqp), (\<lambda>z. (seqp[z])))), ACK, ((a_ca[''fres''])[q]))))))))&(?z_hr=Concat((a_ca[''sigma'']), Fcn(DOMAIN(seqp), (\<lambda>z. (v[(seqp[z])]))))))" (is "?z_hce&?z_hcg")
 by ((rule zenon_recfield_1)+, rule zenon_recfield_2b)
 have z_Hcg: "?z_hcg" (is "_=?z_hu")
 by (rule conjD2 [OF z_Hcd])
 have z_Hch: "(?z_hu~=?z_hbp)"
 by (rule subst [where P="(\<lambda>zenon_Vf. (zenon_Vf~=?z_hbp))", OF z_Hcg z_Hm])
 have z_Hcl: "(Concat((a_ca[''sigma'']), Fcn(DOMAIN(a_h6b857f034661d44d3a40954f58ee32a), (\<lambda>z. (v[(seqp[z])]))))~=?z_hbp)" (is "?z_hcm~=_")
 by (rule subst [where P="(\<lambda>zenon_Vqa. (Concat((a_ca[''sigma'']), Fcn(DOMAIN(zenon_Vqa), (\<lambda>z. (v[(seqp[z])]))))~=?z_hbp))", OF z_Hl z_Hch])
 have z_Hcu: "((''sigma'' \\in DOMAIN((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(a_h6b857f034661d44d3a40954f58ee32a), (\<lambda>z. (a_vhash_primea[(a_h6b857f034661d44d3a40954f58ee32a[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(a_h6b857f034661d44d3a40954f58ee32a), (\<lambda>z. (a_h6b857f034661d44d3a40954f58ee32a[z])))), ACK, ((a_ca[''fres''])[q]))))))))&(?z_hbp=Concat((a_ca[''sigma'']), Fcn(DOMAIN(a_h6b857f034661d44d3a40954f58ee32a), (\<lambda>z. (a_vhash_primea[(a_h6b857f034661d44d3a40954f58ee32a[z])]))))))" (is "?z_hcv&?z_hcx")
 by ((rule zenon_recfield_1)+, rule zenon_recfield_2b)
 have z_Hcx: "?z_hcx" (is "_=?z_hbr")
 by (rule conjD2 [OF z_Hcu])
 have z_Hcy: "(?z_hcm~=?z_hbr)"
 by (rule subst [where P="(\<lambda>zenon_Vra. (?z_hcm~=zenon_Vra))", OF z_Hcx z_Hcl])
 show FALSE
 proof (rule zenon_noteq [of "?z_hbr"])
  have z_Hdc: "(Fcn(DOMAIN(a_h6b857f034661d44d3a40954f58ee32a), (\<lambda>z. (v[(seqp[z])])))=Fcn(DOMAIN(a_h6b857f034661d44d3a40954f58ee32a), (\<lambda>z. (a_vhash_primea[(a_h6b857f034661d44d3a40954f58ee32a[z])]))))" (is "?z_hcn=?z_hbs")
  proof (rule zenon_nnpp [of "(?z_hcn=?z_hbs)"])
   assume z_Hdd:"(?z_hcn~=?z_hbs)"
   have z_Hde: "(~(((isAFcn(?z_hcn)&isAFcn(?z_hbs))&(DOMAIN(?z_hcn)=DOMAIN(?z_hbs)))&(\\A zenon_Vza:((zenon_Vza \\in DOMAIN(?z_hbs))=>((?z_hcn[zenon_Vza])=(?z_hbs[zenon_Vza]))))))" (is "~(?z_hdg&?z_hdn)")
   by (rule zenon_notfunequal_0 [of "?z_hcn" "?z_hbs", OF z_Hdd])
   show FALSE
   proof (rule zenon_notand [OF z_Hde])
    assume z_Hdu:"(~?z_hdg)" (is "~(?z_hdh&?z_hdk)")
    show FALSE
    proof (rule zenon_notand [OF z_Hdu])
     assume z_Hdv:"(~?z_hdh)" (is "~(?z_hdi&?z_hdj)")
     show FALSE
     proof (rule zenon_notand [OF z_Hdv])
      assume z_Hdw:"(~?z_hdi)"
      show FALSE
      by (rule zenon_notisafcn_fcn [of "DOMAIN(a_h6b857f034661d44d3a40954f58ee32a)" "(\<lambda>z. (v[(seqp[z])]))", OF z_Hdw])
     next
      assume z_Hdx:"(~?z_hdj)"
      show FALSE
      by (rule zenon_notisafcn_fcn [of "DOMAIN(a_h6b857f034661d44d3a40954f58ee32a)" "(\<lambda>z. (a_vhash_primea[(a_h6b857f034661d44d3a40954f58ee32a[z])]))", OF z_Hdx])
     qed
    next
     assume z_Hdy:"(DOMAIN(?z_hcn)~=DOMAIN(?z_hbs))" (is "?z_hdl~=?z_hdm")
     have z_Hdz: "(DOMAIN(a_h6b857f034661d44d3a40954f58ee32a)~=?z_hdm)" (is "?z_hbt~=_")
     by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vnc. (zenon_Vnc~=?z_hdm))" "?z_hbt" "(\<lambda>z. (v[(seqp[z])]))", OF z_Hdy])
     have z_Hed: "(?z_hbt~=?z_hbt)"
     by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vpc. (?z_hbt~=zenon_Vpc))" "?z_hbt" "(\<lambda>z. (a_vhash_primea[(a_h6b857f034661d44d3a40954f58ee32a[z])]))", OF z_Hdz])
     show FALSE
     by (rule zenon_noteq [OF z_Hed])
    qed
   next
    assume z_Heh:"(~?z_hdn)" (is "~(\\A x : ?z_hei(x))")
    have z_Hej: "(\\E zenon_Vza:(~((zenon_Vza \\in DOMAIN(?z_hbs))=>((?z_hcn[zenon_Vza])=(?z_hbs[zenon_Vza])))))" (is "\\E x : ?z_hel(x)")
    by (rule zenon_notallex_0 [of "?z_hei", OF z_Heh])
    have z_Hem: "?z_hel((CHOOSE zenon_Vza:(~((zenon_Vza \\in DOMAIN(?z_hbs))=>((?z_hcn[zenon_Vza])=(?z_hbs[zenon_Vza]))))))" (is "~(?z_heo=>?z_hep)")
    by (rule zenon_ex_choose_0 [of "?z_hel", OF z_Hej])
    have z_Heo: "?z_heo"
    by (rule zenon_notimply_0 [OF z_Hem])
    have z_Heq: "((?z_hcn[(CHOOSE zenon_Vza:(~((zenon_Vza \\in DOMAIN(?z_hbs))=>((?z_hcn[zenon_Vza])=(?z_hbs[zenon_Vza])))))])~=(?z_hbs[(CHOOSE zenon_Vza:(~((zenon_Vza \\in DOMAIN(?z_hbs))=>((?z_hcn[zenon_Vza])=(?z_hbs[zenon_Vza])))))]))" (is "?z_her~=?z_hes")
    by (rule zenon_notimply_1 [OF z_Hem])
    have z_Het: "((CHOOSE zenon_Vza:(~((zenon_Vza \\in DOMAIN(?z_hbs))=>((?z_hcn[zenon_Vza])=(?z_hbs[zenon_Vza]))))) \\in DOMAIN(a_h6b857f034661d44d3a40954f58ee32a))" (is "?z_het")
    by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vzb. ((CHOOSE zenon_Vza:(~((zenon_Vza \\in DOMAIN(?z_hbs))=>((?z_hcn[zenon_Vza])=(?z_hbs[zenon_Vza]))))) \\in zenon_Vzb))" "DOMAIN(a_h6b857f034661d44d3a40954f58ee32a)" "(\<lambda>z. (a_vhash_primea[(a_h6b857f034661d44d3a40954f58ee32a[z])]))", OF z_Heo])
    show FALSE
    proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vxb. (zenon_Vxb~=?z_hes))" "DOMAIN(a_h6b857f034661d44d3a40954f58ee32a)" "(\<lambda>z. (v[(seqp[z])]))" "(CHOOSE zenon_Vza:(~((zenon_Vza \\in DOMAIN(?z_hbs))=>((?z_hcn[zenon_Vza])=(?z_hbs[zenon_Vza])))))", OF z_Heq])
     assume z_Hfa:"(~?z_het)"
     show FALSE
     by (rule notE [OF z_Hfa z_Het])
    next
     assume z_Hfb:"((v[(seqp[(CHOOSE zenon_Vza:(~((zenon_Vza \\in DOMAIN(?z_hbs))=>((?z_hcn[zenon_Vza])=(?z_hbs[zenon_Vza])))))])])~=?z_hes)" (is "?z_hfc~=_")
     have z_Hfe: "((a_vhash_primea[(seqp[(CHOOSE zenon_Vza:(~((zenon_Vza \\in DOMAIN(?z_hbs))=>((?z_hcn[zenon_Vza])=(?z_hbs[zenon_Vza])))))])])~=?z_hes)" (is "?z_hff~=_")
     by (rule subst [where P="(\<lambda>zenon_Vdc. ((zenon_Vdc[(seqp[(CHOOSE zenon_Vza:(~((zenon_Vza \\in DOMAIN(?z_hbs))=>((?z_hcn[zenon_Vza])=(?z_hbs[zenon_Vza])))))])])~=?z_hes))", OF z_Hk z_Hfb])
     have z_Hfk: "((a_vhash_primea[(a_h6b857f034661d44d3a40954f58ee32a[(CHOOSE zenon_Vza:(~((zenon_Vza \\in DOMAIN(?z_hbs))=>((?z_hcn[zenon_Vza])=(?z_hbs[zenon_Vza])))))])])~=?z_hes)" (is "?z_hfl~=_")
     by (rule subst [where P="(\<lambda>zenon_Vec. ((a_vhash_primea[(zenon_Vec[(CHOOSE zenon_Vza:(~((zenon_Vza \\in DOMAIN(?z_hbs))=>((?z_hcn[zenon_Vza])=(?z_hbs[zenon_Vza])))))])])~=?z_hes))", OF z_Hl z_Hfe])
     show FALSE
     proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vfc. (?z_hfl~=zenon_Vfc))" "DOMAIN(a_h6b857f034661d44d3a40954f58ee32a)" "(\<lambda>z. (a_vhash_primea[(a_h6b857f034661d44d3a40954f58ee32a[z])]))" "(CHOOSE zenon_Vza:(~((zenon_Vza \\in DOMAIN(?z_hbs))=>((?z_hcn[zenon_Vza])=(?z_hbs[zenon_Vza])))))", OF z_Hfk])
      assume z_Hfa:"(~?z_het)"
      show FALSE
      by (rule notE [OF z_Hfa z_Het])
     next
      assume z_Hfv:"(?z_hfl~=?z_hfl)"
      show FALSE
      by (rule zenon_noteq [OF z_Hfv])
     qed
    qed
   qed
  qed
  have z_Hfw: "(?z_hbr~=?z_hbr)"
  by (rule subst [where P="(\<lambda>zenon_Vta. (Concat((a_ca[''sigma'']), zenon_Vta)~=?z_hbr))", OF z_Hdc], fact z_Hcy)
  thus "(?z_hbr~=?z_hbr)" .
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1619"; *} qed
lemma ob'1711:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'235: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'236: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'244: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
assumes v'276: "((\<And> q :: c. q \<in> (ProcSet) \<Longrightarrow> ((((((fapply (((a_pchash_primea :: c)), (q))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (q))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (q))) = (''D4''))) \<Rightarrow> (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)}))))))))))"
assumes v'277: "(((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))) = (((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply (((a_vhash_primea :: c)), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))]))))))"
shows "(\<forall> p_1 \<in> (ProcSet) : ((((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply (((a_vhash_primea :: c)), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''fres''))), (p_1))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply (((a_vhash_primea :: c)), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''fres''))), (p_1))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (p_1))) \<in> ({(''D4'')}))) \<Rightarrow> (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply (((a_vhash_primea :: c)), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''fres''))), (p_1))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))))))))"(is "PROP ?ob'1711")
proof -
ML_command {* writeln "*** TLAPS ENTER 1711"; *}
show "PROP ?ob'1711"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_32ded0.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_32ded0.znn.out
;; obligation #1711
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'235" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'236" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'244" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'276" (TLA.bAll ProcSet ((q) (/\ (=> (TLA.in (TLA.fapply a_pchash_primea q)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
BOT)) (=> (TLA.in (TLA.fapply a_pchash_primea q) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
(TLA.set ACK BOT))) (=> (= (TLA.fapply a_pchash_primea q) "D4")
(TLA.in (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))))))
$hyp "v'277" (= (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q)))))
(TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply a_vhash_primea (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))))
$goal (TLA.bAll ProcSet ((p_1) (/\ (=> (TLA.in (TLA.fapply a_pchash_primea p_1)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply a_vhash_primea (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "fres") p_1)
BOT)) (=> (TLA.in (TLA.fapply a_pchash_primea p_1) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply a_vhash_primea (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "fres") p_1)
(TLA.set ACK BOT))) (=> (TLA.in (TLA.fapply a_pchash_primea p_1)
(TLA.set "D4"))
(TLA.in (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply a_vhash_primea (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "fres") p_1)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hk:"bAll(ProcSet, (\<lambda>q. ((((a_pchash_primea[q]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q_1. cond((q_1 \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q_1]))))))[''fres''])[q])=BOT))&((((a_pchash_primea[q]) \\in {''E2'', ''E3''})=>((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q_1. cond((q_1 \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q_1]))))))[''fres''])[q]) \\in {ACK, BOT}))&(((a_pchash_primea[q])=''D4'')=>((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q_1. cond((q_1 \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q_1]))))))[''fres''])[q]) \\in ((Nat \\ {0}) \\cup {BOT})))))))" (is "?z_hk")
 using v'276 by blast
 have z_Hl:"((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q_1. cond((q_1 \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q_1]))))))=(''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(a_Xhash_primea=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (a_vhash_primea[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(a_Xhash_primea=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(a_Xhash_primea=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(a_Xhash_primea=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q])))))))" (is "?z_hbe=?z_hec")
 using v'277 by blast
 have zenon_L1_: "((Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(a_Xhash_primea=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(a_Xhash_primea=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=((?z_hbe[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])) ==> (Fcn(ProcSet, (\<lambda>q_1. cond((q_1 \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q_1]))))=Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(a_Xhash_primea=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(a_Xhash_primea=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))) ==> FALSE" (is "?z_hff ==> ?z_hgc ==> FALSE")
 proof -
  assume z_Hff:"?z_hff" (is "?z_hfg~=?z_hgb")
  assume z_Hgc:"?z_hgc" (is "?z_hda=?z_hey")
  show FALSE
  proof (rule zenon_noteq [of "?z_hgb"])
   have z_Hgd: "(?z_hey=(?z_hbe[''fres'']))" (is "_=?z_hbd")
   proof (rule zenon_nnpp [of "(?z_hey=?z_hbd)"])
    assume z_Hge:"(?z_hey~=?z_hbd)"
    have z_Hgf: "((''fres'' \\in DOMAIN(?z_hbe))&(?z_hbd=?z_hda))" (is "?z_hgg&?z_hgi")
    by (rule zenon_recfield_2, ((rule zenon_recfield_3)+)?, rule zenon_recfield_3b, auto)
    have z_Hgi: "?z_hgi"
    by (rule conjD2 [OF z_Hgf])
    have z_Hgj: "(?z_hey~=?z_hda)"
    by (rule subst [where P="(\<lambda>zenon_Vow. (?z_hey~=zenon_Vow))", OF z_Hgi z_Hge])
    show FALSE
    by (rule zenon_eqsym [OF z_Hgc z_Hgj])
   qed
   have z_Hgn: "(?z_hgb~=?z_hgb)"
   by (rule subst [where P="(\<lambda>zenon_Vlw. ((zenon_Vlw[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=?z_hgb))", OF z_Hgd], fact z_Hff)
   thus "(?z_hgb~=?z_hgb)" .
  qed
 qed
 have zenon_L2_: "((Fcn(ProcSet, (\<lambda>q_1. cond((q_1 \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q_1]))))[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=((?z_hec[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])) ==> (Fcn(ProcSet, (\<lambda>q_1. cond((q_1 \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q_1]))))=Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(a_Xhash_primea=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(a_Xhash_primea=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))) ==> FALSE" (is "?z_hgs ==> ?z_hgc ==> FALSE")
 proof -
  assume z_Hgs:"?z_hgs" (is "?z_hgt~=?z_hgu")
  assume z_Hgc:"?z_hgc" (is "?z_hda=?z_hey")
  show FALSE
  proof (rule zenon_noteq [of "?z_hgu"])
   have z_Hgv: "(?z_hda=(?z_hec[''fres'']))" (is "_=?z_hfs")
   proof (rule zenon_nnpp [of "(?z_hda=?z_hfs)"])
    assume z_Hgw:"(?z_hda~=?z_hfs)"
    have z_Hgx: "((''fres'' \\in DOMAIN(?z_hec))&(?z_hfs=?z_hey))" (is "?z_hgy&?z_hha")
    by (rule zenon_recfield_2, ((rule zenon_recfield_3)+)?, rule zenon_recfield_3b, auto)
    have z_Hha: "?z_hha"
    by (rule conjD2 [OF z_Hgx])
    have z_Hhb: "(?z_hda~=?z_hey)"
    by (rule subst [where P="(\<lambda>zenon_Vzg. (?z_hda~=zenon_Vzg))", OF z_Hha z_Hgw])
    show FALSE
    by (rule notE [OF z_Hhb z_Hgc])
   qed
   have z_Hhf: "(?z_hgu~=?z_hgu)"
   by (rule subst [where P="(\<lambda>zenon_Vdla. ((zenon_Vdla[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>((?z_hfs[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((?z_hfs[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((?z_hfs[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=?z_hgu))", OF z_Hgv], fact z_Hgs)
   thus "(?z_hgu~=?z_hgu)" .
  qed
 qed
 assume z_Hm:"(~bAll(ProcSet, (\<lambda>p_1. ((((a_pchash_primea[p_1]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[p_1])=BOT))&((((a_pchash_primea[p_1]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[p_1]) \\in {ACK, BOT}))&(((a_pchash_primea[p_1]) \\in {''D4''})=>(((?z_hec[''fres''])[p_1]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))" (is "~?z_hhk")
 have z_Hia_z_Hk: "(\\A x:((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hbe[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hbe[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x])=''D4'')=>(((?z_hbe[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))) == ?z_hk" (is "?z_hia == _")
 by (unfold bAll_def)
 have z_Hia: "?z_hia" (is "\\A x : ?z_him(x)")
 by (unfold z_Hia_z_Hk, fact z_Hk)
 have z_Hgc: "(Fcn(ProcSet, (\<lambda>q_1. cond((q_1 \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q_1]))))=Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(a_Xhash_primea=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(a_Xhash_primea=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q])))))" (is "?z_hda=?z_hey")
 using z_Hl by auto
 have z_Hin_z_Hm: "(~(\\A x:((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))) == (~?z_hhk)" (is "?z_hin == ?z_hm")
 by (unfold bAll_def)
 have z_Hin: "?z_hin" (is "~(\\A x : ?z_hip(x))")
 by (unfold z_Hin_z_Hm, fact z_Hm)
 have z_Hiq: "(\\E x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))" (is "\\E x : ?z_hir(x)")
 by (rule zenon_notallex_0 [of "?z_hip", OF z_Hin])
 have z_His: "?z_hir((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))" (is "~(?z_hit=>?z_hiu)")
 by (rule zenon_ex_choose_0 [of "?z_hir", OF z_Hiq])
 have z_Hit: "?z_hit"
 by (rule zenon_notimply_0 [OF z_His])
 have z_Hiv: "(~?z_hiu)" (is "~(?z_hiw&?z_hix)")
 by (rule zenon_notimply_1 [OF z_His])
 show FALSE
 proof (rule zenon_notand [OF z_Hiv])
  assume z_Hiy:"(~?z_hiw)" (is "~(?z_hiz=>?z_hja)")
  have z_Hiz: "?z_hiz"
  by (rule zenon_notimply_0 [OF z_Hiy])
  have z_Hjb: "(((?z_hec[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=BOT)" (is "?z_hgu~=_")
  by (rule zenon_notimply_1 [OF z_Hiy])
  have z_Hgx: "((''fres'' \\in DOMAIN(?z_hec))&((?z_hec[''fres''])=?z_hey))" (is "?z_hgy&?z_hha")
  by (rule zenon_recfield_2, ((rule zenon_recfield_3)+)?, rule zenon_recfield_3b, auto)
  have z_Hha: "?z_hha" (is "?z_hfs=_")
  by (rule conjD2 [OF z_Hgx])
  have z_Hjc: "((?z_hey[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>((?z_hfs[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((?z_hfs[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((?z_hfs[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=BOT)" (is "?z_hfg~=_")
  by (rule subst [where P="(\<lambda>zenon_Vgb. ((zenon_Vgb[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>((?z_hfs[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((?z_hfs[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((?z_hfs[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])~=BOT))", OF z_Hha z_Hjb])
  have z_Hjh: "?z_him((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>((?z_hfs[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((?z_hfs[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((?z_hfs[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))" (is "_=>?z_hji")
  by (rule zenon_all_0 [of "?z_him" "(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>((?z_hfs[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>((?z_hfs[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>((?z_hfs[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hia])
  show FALSE
  proof (rule zenon_imply [OF z_Hjh])
   assume z_Hjj:"(~?z_hit)"
   show FALSE
   by (rule notE [OF z_Hjj z_Hit])
  next
   assume z_Hji:"?z_hji" (is "?z_hjk&?z_hjl")
   have z_Hjk: "?z_hjk" (is "_=>?z_hjm")
   by (rule zenon_and_0 [OF z_Hji])
   show FALSE
   proof (rule zenon_imply [OF z_Hjk])
    assume z_Hjn:"(~?z_hiz)"
    show FALSE
    by (rule notE [OF z_Hjn z_Hiz])
   next
    assume z_Hjm:"?z_hjm" (is "?z_hgb=_")
    show FALSE
    proof (rule notE [OF z_Hjc])
     have z_Hjo: "(?z_hgb=?z_hfg)"
     proof (rule zenon_nnpp [of "(?z_hgb=?z_hfg)"])
      assume z_Hjp:"(?z_hgb~=?z_hfg)"
      show FALSE
      proof (rule zenon_em [of "(?z_hfg=?z_hfg)"])
       assume z_Hjq:"(?z_hfg=?z_hfg)"
       show FALSE
       proof (rule notE [OF z_Hjp])
        have z_Hjr: "(?z_hfg=?z_hgb)"
        proof (rule zenon_nnpp [of "(?z_hfg=?z_hgb)"])
         assume z_Hff:"(?z_hfg~=?z_hgb)"
         show FALSE
         by (rule zenon_L1_ [OF z_Hff z_Hgc])
        qed
        have z_Hjo: "(?z_hgb=?z_hfg)"
        by (rule subst [where P="(\<lambda>zenon_Vela. (zenon_Vela=?z_hfg))", OF z_Hjr], fact z_Hjq)
        thus "(?z_hgb=?z_hfg)" .
       qed
      next
       assume z_Hjv:"(?z_hfg~=?z_hfg)"
       show FALSE
       by (rule zenon_noteq [OF z_Hjv])
      qed
     qed
     have z_Hjw: "(?z_hfg=BOT)"
     by (rule subst [where P="(\<lambda>zenon_Vcc. (zenon_Vcc=BOT))", OF z_Hjo], fact z_Hjm)
     thus "(?z_hfg=BOT)" .
    qed
   qed
  qed
 next
  assume z_Hka:"(~?z_hix)" (is "~(?z_hkb&?z_hkc)")
  show FALSE
  proof (rule zenon_notand [OF z_Hka])
   assume z_Hkd:"(~?z_hkb)" (is "~(?z_hke=>?z_hkf)")
   have z_Hke: "?z_hke"
   by (rule zenon_notimply_0 [OF z_Hkd])
   have z_Hkg: "(~?z_hkf)"
   by (rule zenon_notimply_1 [OF z_Hkd])
   have z_Hjh: "?z_him((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))" (is "_=>?z_hji")
   by (rule zenon_all_0 [of "?z_him" "(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hia])
   show FALSE
   proof (rule zenon_imply [OF z_Hjh])
    assume z_Hjj:"(~?z_hit)"
    show FALSE
    by (rule notE [OF z_Hjj z_Hit])
   next
    assume z_Hji:"?z_hji" (is "?z_hjk&?z_hjl")
    have z_Hjl: "?z_hjl" (is "?z_hkh&?z_hki")
    by (rule zenon_and_1 [OF z_Hji])
    have z_Hkh: "?z_hkh" (is "_=>?z_hkj")
    by (rule zenon_and_0 [OF z_Hjl])
    show FALSE
    proof (rule zenon_imply [OF z_Hkh])
     assume z_Hkk:"(~?z_hke)"
     show FALSE
     by (rule notE [OF z_Hkk z_Hke])
    next
     assume z_Hkj:"?z_hkj"
     have z_Hgf: "((''fres'' \\in DOMAIN(?z_hbe))&((?z_hbe[''fres''])=?z_hda))" (is "?z_hgg&?z_hgi")
     by (rule zenon_recfield_2, ((rule zenon_recfield_3)+)?, rule zenon_recfield_3b, auto)
     have z_Hgi: "?z_hgi" (is "?z_hbd=_")
     by (rule conjD2 [OF z_Hgf])
     have z_Hkl: "((?z_hda[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {ACK, BOT})" (is "?z_hkl")
     by (rule subst [where P="(\<lambda>zenon_Vsf. ((zenon_Vsf[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {ACK, BOT}))", OF z_Hgi z_Hkj])
     show FALSE
     proof (rule notE [OF z_Hkg])
      have z_Hkq: "((?z_hda[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=((?z_hec[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]))" (is "?z_hgt=?z_hgu")
      proof (rule zenon_nnpp [of "(?z_hgt=?z_hgu)"])
       assume z_Hgs:"(?z_hgt~=?z_hgu)"
       show FALSE
       by (rule zenon_L2_ [OF z_Hgs z_Hgc])
      qed
      have z_Hkf: "?z_hkf"
      by (rule subst [where P="(\<lambda>zenon_Vdc. (zenon_Vdc \\in {ACK, BOT}))", OF z_Hkq], fact z_Hkl)
      thus "?z_hkf" .
     qed
    qed
   qed
  next
   assume z_Hku:"(~?z_hkc)" (is "~(?z_hkv=>?z_hkw)")
   have z_Hkv: "?z_hkv"
   by (rule zenon_notimply_0 [OF z_Hku])
   have z_Hkx: "(~?z_hkw)"
   by (rule zenon_notimply_1 [OF z_Hku])
   show FALSE
   proof (rule zenon_in_addElt [of "(a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])" "''D4''" "{}", OF z_Hkv])
    assume z_Hla:"((a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=''D4'')" (is "?z_hky=?z_hdu")
    have z_Hjh: "?z_him((CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {?z_hdu})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT})))))))))" (is "_=>?z_hji")
    by (rule zenon_all_0 [of "?z_him" "(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {?z_hdu})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))", OF z_Hia])
    show FALSE
    proof (rule zenon_imply [OF z_Hjh])
     assume z_Hjj:"(~?z_hit)"
     show FALSE
     by (rule notE [OF z_Hjj z_Hit])
    next
     assume z_Hji:"?z_hji" (is "?z_hjk&?z_hjl")
     have z_Hjl: "?z_hjl" (is "?z_hkh&?z_hki")
     by (rule zenon_and_1 [OF z_Hji])
     have z_Hki: "?z_hki" (is "?z_hla=>?z_hlb")
     by (rule zenon_and_1 [OF z_Hjl])
     show FALSE
     proof (rule zenon_imply [OF z_Hki])
      assume z_Hlc:"(?z_hky~=?z_hdu)"
      show FALSE
      by (rule notE [OF z_Hlc z_Hla])
     next
      assume z_Hlb:"?z_hlb"
      have z_Hgf: "((''fres'' \\in DOMAIN(?z_hbe))&((?z_hbe[''fres''])=?z_hda))" (is "?z_hgg&?z_hgi")
      by (rule zenon_recfield_2, ((rule zenon_recfield_3)+)?, rule zenon_recfield_3b, auto)
      have z_Hgi: "?z_hgi" (is "?z_hbd=_")
      by (rule conjD2 [OF z_Hgf])
      have z_Hld: "((?z_hda[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {?z_hdu})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in ((Nat \\ {0}) \\cup {BOT}))" (is "?z_hld")
      by (rule subst [where P="(\<lambda>zenon_Vuf. ((zenon_Vuf[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {?z_hdu})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in ((Nat \\ {0}) \\cup {BOT})))", OF z_Hgi z_Hlb])
      show FALSE
      proof (rule notE [OF z_Hkx])
       have z_Hkq: "((?z_hda[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {?z_hdu})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])=((?z_hec[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {?z_hdu})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]))" (is "?z_hgt=?z_hgu")
       proof (rule zenon_nnpp [of "(?z_hgt=?z_hgu)"])
        assume z_Hgs:"(?z_hgt~=?z_hgu)"
        show FALSE
        by (rule zenon_L2_ [OF z_Hgs z_Hgc])
       qed
       have z_Hkw: "?z_hkw"
       by (rule subst [where P="(\<lambda>zenon_Vfc. (zenon_Vfc \\in ((Nat \\ {0}) \\cup {BOT})))", OF z_Hkq], fact z_Hld)
       thus "?z_hkw" .
      qed
     qed
    qed
   next
    assume z_Hll:"((a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))]) \\in {})" (is "?z_hll")
    show FALSE
    by (rule zenon_in_emptyset [of "(a_pchash_primea[(CHOOSE x:(~((x \\in ProcSet)=>((((a_pchash_primea[x]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>(((?z_hec[''fres''])[x])=BOT))&((((a_pchash_primea[x]) \\in {''E2'', ''E3''})=>(((?z_hec[''fres''])[x]) \\in {ACK, BOT}))&(((a_pchash_primea[x]) \\in {''D4''})=>(((?z_hec[''fres''])[x]) \\in ((Nat \\ {0}) \\cup {BOT}))))))))])", OF z_Hll])
   qed
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1711"; *} qed
lemma ob'1705:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
fixes q
assumes q_in : "(q \<in> (ProcSet))"
assumes v'284: "(((((fapply (((a_pchash_primea :: c)), (q))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Longrightarrow> ((((((fapply (((a_pchash_primea :: c)), (q))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (q))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (q))) = (''D4''))) \<Rightarrow> (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)}))))))))))"
assumes v'285: "(((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<Longrightarrow> ((((((fapply (((a_pchash_primea :: c)), (q))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (q))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (q))) = (''D4''))) \<Rightarrow> (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)}))))))))))"
assumes v'286: "(((((fapply (((a_pchash_primea :: c)), (q))) = (''E3''))) \<Longrightarrow> ((((((fapply (((a_pchash_primea :: c)), (q))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (q))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (q))) = (''D4''))) \<Rightarrow> (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)}))))))))))"
assumes v'287: "(((((fapply (((a_pchash_primea :: c)), (q))) = (''D4''))) \<Longrightarrow> ((((((fapply (((a_pchash_primea :: c)), (q))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (q))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (q))) = (''D4''))) \<Rightarrow> (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)}))))))))))"
shows "((((((fapply (((a_pchash_primea :: c)), (q))) \<in> ({(''L0''), (''E1''), (''D1''), (''D2''), (''D3'')}))) \<Rightarrow> (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (BOT))))) & (((((fapply (((a_pchash_primea :: c)), (q))) \<in> ({(''E2''), (''E3'')}))) \<Rightarrow> (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) \<in> ({(ACK), (BOT)}))))) & (((((fapply (((a_pchash_primea :: c)), (q))) = (''D4''))) \<Rightarrow> (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) \<in> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)}))))))))"(is "PROP ?ob'1705")
proof -
ML_command {* writeln "*** TLAPS ENTER 1705"; *}
show "PROP ?ob'1705"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_07094a.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_07094a.znn.out
;; obligation #1705
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "q_in" (TLA.in q ProcSet)
$hyp "v'284" (=> (TLA.in (TLA.fapply a_pchash_primea q)
(TLA.set "L0" "E1" "D1" "D2" "D3")) (/\ (=> (TLA.in (TLA.fapply a_pchash_primea q)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
BOT)) (=> (TLA.in (TLA.fapply a_pchash_primea q) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
(TLA.set ACK BOT))) (=> (= (TLA.fapply a_pchash_primea q) "D4")
(TLA.in (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT))))))
$hyp "v'285" (=> (= (TLA.fapply a_pchash_primea q)
"E2") (/\ (=> (TLA.in (TLA.fapply a_pchash_primea q)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
BOT)) (=> (TLA.in (TLA.fapply a_pchash_primea q) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
(TLA.set ACK BOT))) (=> (= (TLA.fapply a_pchash_primea q) "D4")
(TLA.in (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT))))))
$hyp "v'286" (=> (= (TLA.fapply a_pchash_primea q)
"E3") (/\ (=> (TLA.in (TLA.fapply a_pchash_primea q)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
BOT)) (=> (TLA.in (TLA.fapply a_pchash_primea q) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
(TLA.set ACK BOT))) (=> (= (TLA.fapply a_pchash_primea q) "D4")
(TLA.in (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT))))))
$hyp "v'287" (=> (= (TLA.fapply a_pchash_primea q)
"D4") (/\ (=> (TLA.in (TLA.fapply a_pchash_primea q)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
BOT)) (=> (TLA.in (TLA.fapply a_pchash_primea q) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
(TLA.set ACK BOT))) (=> (= (TLA.fapply a_pchash_primea q) "D4")
(TLA.in (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT))))))
$goal (/\ (=> (TLA.in (TLA.fapply a_pchash_primea q)
(TLA.set "L0" "E1" "D1" "D2" "D3"))
(= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
BOT)) (=> (TLA.in (TLA.fapply a_pchash_primea q) (TLA.set "E2" "E3"))
(TLA.in (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
(TLA.set ACK BOT))) (=> (= (TLA.fapply a_pchash_primea q) "D4")
(TLA.in (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
(TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hl:"(((a_pchash_primea[q]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>((((a_pchash_primea[q]) \\in {''L0'', ''E1'', ''D1'', ''D2'', ''D3''})=>((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q_1. cond((q_1 \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q_1]))))))[''fres''])[q])=BOT))&((((a_pchash_primea[q]) \\in {''E2'', ''E3''})=>((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q_1. cond((q_1 \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q_1]))))))[''fres''])[q]) \\in {ACK, BOT}))&(((a_pchash_primea[q])=''D4'')=>((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q_1. cond((q_1 \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q_1]))))))[''fres''])[q]) \\in ((Nat \\ {0}) \\cup {BOT}))))))" (is "?z_hq=>?z_hba")
 using v'284 by blast
 have z_Hn:"(((a_pchash_primea[q])=''E3'')=>?z_hba)" (is "?z_hee=>_")
 using v'286 by blast
 have z_Ho:"(((a_pchash_primea[q])=''D4'')=>?z_hba)" (is "?z_hdv=>_")
 using v'287 by blast
 have z_Hm:"(((a_pchash_primea[q])=''E2'')=>?z_hba)" (is "?z_hef=>_")
 using v'285 by blast
 assume z_Hp:"(~?z_hba)" (is "~(?z_hbb&?z_hdn)")
 show FALSE
 proof (rule zenon_imply [OF z_Hl])
  assume z_Heg:"(~?z_hq)"
  show FALSE
  proof (rule zenon_imply [OF z_Hm])
   assume z_Heh:"((a_pchash_primea[q])~=''E2'')" (is "?z_hr~=?z_hct")
   show FALSE
   proof (rule zenon_imply [OF z_Hn])
    assume z_Hei:"(?z_hr~=''E3'')" (is "_~=?z_hdr")
    show FALSE
    proof (rule zenon_imply [OF z_Ho])
     assume z_Hej:"(?z_hr~=''D4'')" (is "_~=?z_hdw")
     show FALSE
     proof (rule zenon_notand [OF z_Hp])
      assume z_Hek:"(~?z_hbb)" (is "~(_=>?z_hbc)")
      have z_Hq: "?z_hq"
      by (rule zenon_notimply_0 [OF z_Hek])
      show FALSE
      by (rule notE [OF z_Heg z_Hq])
     next
      assume z_Hel:"(~?z_hdn)" (is "~(?z_hdo&?z_hdu)")
      show FALSE
      proof (rule zenon_notand [OF z_Hel])
       assume z_Hem:"(~?z_hdo)" (is "~(?z_hdp=>?z_hds)")
       have z_Hdp: "?z_hdp"
       by (rule zenon_notimply_0 [OF z_Hem])
       show FALSE
       proof (rule zenon_in_addElt [of "?z_hr" "?z_hct" "{?z_hdr}", OF z_Hdp])
        assume z_Hef:"?z_hef"
        show FALSE
        by (rule notE [OF z_Heh z_Hef])
       next
        assume z_Heo:"(?z_hr \\in {?z_hdr})" (is "?z_heo")
        show FALSE
        proof (rule zenon_in_addElt [of "?z_hr" "?z_hdr" "{}", OF z_Heo])
         assume z_Hee:"?z_hee"
         show FALSE
         by (rule notE [OF z_Hei z_Hee])
        next
         assume z_Heq:"(?z_hr \\in {})" (is "?z_heq")
         show FALSE
         by (rule zenon_in_emptyset [of "?z_hr", OF z_Heq])
        qed
       qed
      next
       assume z_Her:"(~?z_hdu)" (is "~(_=>?z_hdx)")
       have z_Hdv: "?z_hdv"
       by (rule zenon_notimply_0 [OF z_Her])
       show FALSE
       by (rule notE [OF z_Hej z_Hdv])
      qed
     qed
    next
     assume z_Hba:"?z_hba"
     show FALSE
     by (rule notE [OF z_Hp z_Hba])
    qed
   next
    assume z_Hba:"?z_hba"
    show FALSE
    by (rule notE [OF z_Hp z_Hba])
   qed
  next
   assume z_Hba:"?z_hba"
   show FALSE
   by (rule notE [OF z_Hp z_Hba])
  qed
 next
  assume z_Hba:"?z_hba"
  show FALSE
  by (rule notE [OF z_Hp z_Hba])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1705"; *} qed
lemma ob'1676:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
fixes q
assumes q_in : "(q \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))"
fixes z
assumes z_in : "(z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))))"
assumes v'292: "(((z) \<noteq> ((Succ[0]))))"
fixes r
assumes r_in : "(r \<in> (ProcSet))"
fixes n
assumes n_in : "(n \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r_1. (((((((r_1) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r_1))) = (''E2''))) \<and> (((fapply ((i), (r_1))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]))))"
fixes f
assumes f_in : "(f \<in> (ProcSet))"
assumes v'312: "(((f) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r_1. (((((((r_1) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r_1))) = (''E2''))) \<and> (((fapply ((i), (r_1))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (n)))))"
shows "(((fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r_1. (((((((r_1) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r_1))) = (''E2''))) \<and> (((fapply ((i), (r_1))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (n))) \<in> (ProcSet)))"(is "PROP ?ob'1676")
proof -
ML_command {* writeln "*** TLAPS ENTER 1676"; *}
show "PROP ?ob'1676"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_e9ae83.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_e9ae83.znn.out
;; obligation #1676
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "q_in" (TLA.in q (TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))
$hyp "z_in" (TLA.in z (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))))
$hyp "v'292" (-. (= z
(TLA.fapply TLA.Succ 0)))
$hyp "r_in" (TLA.in r ProcSet)
$hyp "n_in" (TLA.in n (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r_1) (\/ (/\ (= r_1
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r_1) "E2") (= (TLA.fapply i r_1)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))))
$hyp "f_in" (TLA.in f ProcSet)
$hyp "v'312" (= f
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r_1) (\/ (/\ (= r_1
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r_1) "E2") (= (TLA.fapply i r_1)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) n))
$goal (TLA.in (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r_1) (\/ (/\ (= r_1
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r_1) "E2") (= (TLA.fapply i r_1)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) n)
ProcSet)
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hq:"(f=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[n]))" (is "_=?z_ht")
 using v'312 by blast
 have z_Hp:"(f \\in ProcSet)" (is "?z_hp")
 using f_in by blast
 assume z_Hr:"(~(?z_ht \\in ProcSet))" (is "~?z_hcg")
 have z_Hcg: "?z_hcg"
 by (rule subst [where P="(\<lambda>zenon_Vh. (zenon_Vh \\in ProcSet))", OF z_Hq z_Hp])
 show FALSE
 by (rule notE [OF z_Hr z_Hcg])
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1676"; *} qed
lemma ob'1786:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
assumes v'278: "((((ValuesMatchInds (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0])))))))))))  \<mapsto> (fapply ((seq), (z)))]), (fapply ((a_ca), (''sigma'')))))) \<and> ((GoodRes ((setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z))))), (fapply ((a_ca), (''fres''))))))))"
assumes v'279: "(((((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))) \<in> ((a_Mhash_primea :: c)))) \<Leftrightarrow> ((((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))) \<in> (CDomain))) & ((a_h022c5783954683bdcbcacced356fd6a ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply (((a_vhash_primea :: c)), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))]))))) :: c)) & (\<exists> y \<in> (M) : (\<exists> B \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((y)) :: c)))) : (\<exists> pi \<in> ((Perm ((B)))) : ((((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))) = ((Concat ((fapply ((y), (''sigma''))), ([ m \<in> ((DOMAIN (pi)))  \<mapsto> (fapply ((v), (fapply ((pi), (m)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (B))), (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (fapply ((fapply ((y), (''fres''))), (q)))))))))))))))"
assumes v'280: "(((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))) \<in> (CDomain)))"
assumes v'281: "((a_h022c5783954683bdcbcacced356fd6a ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply (((a_vhash_primea :: c)), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> ((((a_Xhash_primea :: c)) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))]))))) :: c))"
shows "(((\<exists> B \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((a_ca)) :: c)))) : (\<exists> pi \<in> ((Perm ((B)))) : ((((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))) = ((Concat ((fapply ((a_ca), (''sigma''))), ([ m \<in> ((DOMAIN (pi)))  \<mapsto> (fapply ((v), (fapply ((pi), (m)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (B))), (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q))))))))))) \<Rightarrow> (((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))) \<in> ((a_Mhash_primea :: c))))))"(is "PROP ?ob'1786")
proof -
ML_command {* writeln "*** TLAPS ENTER 1786"; *}
show "PROP ?ob'1786"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_8a5b52.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_8a5b52.znn.out
;; obligation #1786
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'278" (/\ (ValuesMatchInds (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z)))
(TLA.fapply a_ca "sigma"))
(GoodRes (TLA.setOfAll (arith.intrange (TLA.fapply TLA.Succ 0) (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z)))
(TLA.fapply a_ca "fres")))
$hyp "v'279" (<=> (TLA.in (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q)))))
a_Mhash_primea)
(/\ (TLA.in (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q)))))
CDomain)
(a_h022c5783954683bdcbcacced356fd6a (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply a_vhash_primea (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))))
(TLA.bEx M ((y) (TLA.bEx (TLA.SUBSET (hc4e622ce2e33ef1c6a9f10c01956cd y)) ((B) (TLA.bEx (Perm B) ((pi) (/\ (= (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")
(Concat (TLA.fapply y "sigma")
(TLA.Fcn (TLA.DOMAIN pi) ((m) (TLA.fapply v (TLA.fapply pi m))))))
(TLA.bAll ProcSet ((q) (TLA.cond (TLA.in q
B) (= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
ACK) (= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
(TLA.fapply (TLA.fapply y "fres") q))))))))))))))
$hyp "v'280" (TLA.in (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q)))))
CDomain)
$hyp "v'281" (a_h022c5783954683bdcbcacced356fd6a (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply a_vhash_primea (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= a_Xhash_primea
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply a_pchash_primea r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))))
$goal (=> (TLA.bEx (TLA.SUBSET (hc4e622ce2e33ef1c6a9f10c01956cd a_ca)) ((B) (TLA.bEx (Perm B) ((pi) (/\ (= (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")
(Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN pi) ((m) (TLA.fapply v (TLA.fapply pi m))))))
(TLA.bAll ProcSet ((q) (TLA.cond (TLA.in q
B) (= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
ACK) (= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))))))))
(TLA.in (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q)))))
a_Mhash_primea))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hj:"(a_ca \\in M)" (is "?z_hj")
 using a_ca_in by blast
 have z_Hn:"a_h022c5783954683bdcbcacced356fd6a((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(a_Xhash_primea=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (a_vhash_primea[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(a_Xhash_primea=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(a_Xhash_primea=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(a_Xhash_primea=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q])))))))" (is "?z_hn")
 using v'281 by blast
 have z_Hm:"((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q])))))) \\in CDomain)" (is "?z_hm")
 using v'280 by blast
 have z_Hl:"(((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q])))))) \\in a_Mhash_primea)<=>(?z_hm&(?z_hn&bEx(M, (\<lambda>y. bEx(SUBSET(hc4e622ce2e33ef1c6a9f10c01956cd(y)), (\<lambda>B. bEx(Perm(B), (\<lambda>pi. ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma''])=Concat((y[''sigma'']), Fcn(DOMAIN(pi), (\<lambda>m. (v[(pi[m])])))))&bAll(ProcSet, (\<lambda>q. cond((q \\in B), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[q])=ACK), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[q])=((y[''fres''])[q])))))))))))))))" (is "?z_heb<=>?z_hed")
 using v'279 by blast
 assume z_Ho:"(~(bEx(SUBSET(hc4e622ce2e33ef1c6a9f10c01956cd(a_ca)), (\<lambda>B. bEx(Perm(B), (\<lambda>pi. ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma''])=Concat((a_ca[''sigma'']), Fcn(DOMAIN(pi), (\<lambda>m. (v[(pi[m])])))))&bAll(ProcSet, (\<lambda>q. cond((q \\in B), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[q])=ACK), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[q])=((a_ca[''fres''])[q]))))))))))=>?z_heb))" (is "~(?z_hfn=>_)")
 have z_Hfn: "?z_hfn"
 by (rule zenon_notimply_0 [OF z_Ho])
 have z_Hga: "(~?z_heb)"
 by (rule zenon_notimply_1 [OF z_Ho])
 show FALSE
 proof (rule zenon_equiv [OF z_Hl])
  assume z_Hga:"(~?z_heb)"
  assume z_Hgb:"(~?z_hed)" (is "~(_&?z_hee)")
  show FALSE
  proof (rule zenon_notand [OF z_Hgb])
   assume z_Hgc:"(~?z_hm)"
   show FALSE
   by (rule notE [OF z_Hgc z_Hm])
  next
   assume z_Hgd:"(~?z_hee)" (is "~(_&?z_hef)")
   show FALSE
   proof (rule zenon_notand [OF z_Hgd])
    assume z_Hge:"(~?z_hn)"
    show FALSE
    by (rule notE [OF z_Hge z_Hn])
   next
    assume z_Hgf:"(~?z_hef)"
    have z_Hgg_z_Hgf: "(~(\\E x:((x \\in M)&bEx(SUBSET(hc4e622ce2e33ef1c6a9f10c01956cd(x)), (\<lambda>B. bEx(Perm(B), (\<lambda>pi. ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma''])=Concat((x[''sigma'']), Fcn(DOMAIN(pi), (\<lambda>m. (v[(pi[m])])))))&bAll(ProcSet, (\<lambda>q. cond((q \\in B), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[q])=ACK), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[q])=((x[''fres''])[q]))))))))))))) == (~?z_hef)" (is "?z_hgg == ?z_hgf")
    by (unfold bEx_def)
    have z_Hgg: "?z_hgg" (is "~(\\E x : ?z_hhb(x))")
    by (unfold z_Hgg_z_Hgf, fact z_Hgf)
    have z_Hhc: "~?z_hhb(a_ca)"
    by (rule zenon_notex_0 [of "?z_hhb" "a_ca", OF z_Hgg])
    show FALSE
    proof (rule zenon_notand [OF z_Hhc])
     assume z_Hhd:"(~?z_hj)"
     show FALSE
     by (rule notE [OF z_Hhd z_Hj])
    next
     assume z_Hhe:"(~?z_hfn)"
     show FALSE
     by (rule notE [OF z_Hhe z_Hfn])
    qed
   qed
  qed
 next
  assume z_Heb:"?z_heb"
  assume z_Hed:"?z_hed" (is "_&?z_hee")
  show FALSE
  by (rule notE [OF z_Hga z_Heb])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1786"; *} qed
lemma ob'1876:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'235: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'236: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'244: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
assumes v'284: "((\<And> y :: c. y \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))) \<Longrightarrow> (\<And> z :: c. z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))) \<Longrightarrow> ((((fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (y))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))) \<Longrightarrow> (((y) = (z)))))))"
shows "((([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]) \<in> (subsetOf(([((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))) \<rightarrow> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]), %M_1. (\<forall> a \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))) : (\<forall> b \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))) : (((((fapply ((M_1), (a))) = (fapply ((M_1), (b))))) \<Rightarrow> (((a) = (b)))))))))))"(is "PROP ?ob'1876")
proof -
ML_command {* writeln "*** TLAPS ENTER 1876"; *}
show "PROP ?ob'1876"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_953e6a.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_953e6a.znn.out
;; obligation #1876
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'235" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'236" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'244" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'284" (TLA.bAll (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((y) (TLA.bAll (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (=> (= (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) y)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)) (= y
z))))))
$goal (TLA.in (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))
(TLA.subsetOf (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) (TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ((M_1) (TLA.bAll (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((a) (TLA.bAll (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((b) (=> (= (TLA.fapply M_1 a)
(TLA.fapply M_1 b)) (= a
b)))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hk:"bAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>y. bAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[y])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[z]))=>(y=z))))))" (is "?z_hk")
 using v'284 by blast
 assume z_Hl:"(~(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))))))) \\in subsetOf(FuncSet(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[z])))), (\<lambda>M_1. bAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>a. bAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>b. (((M_1[a])=(M_1[b]))=>(a=b))))))))))" (is "~?z_hch")
 show FALSE
 proof (rule zenon_notin_subsetof [of "Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))" "FuncSet(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[z]))))" "(\<lambda>M_1. bAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>a. bAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>b. (((M_1[a])=(M_1[b]))=>(a=b)))))))", OF z_Hl])
  assume z_Hda:"(~(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))))))) \\in FuncSet(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[z]))))))" (is "~?z_hdb")
  have z_Hdc: "(~(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))))))) \\in FuncSet(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[z]))))))" (is "~?z_hdd")
  by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Voa. (~(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))))))) \\in FuncSet(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), setOfAll(zenon_Voa, (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[z])))))))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))))))", OF z_Hda])
  show FALSE
  proof (rule zenon_notin_funcset [of "Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[z])))", OF z_Hdc])
   assume z_Hdm:"(~isAFcn(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))))" (is "~?z_hdn")
   show FALSE
   by (rule zenon_notisafcn_fcn [of "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))))))", OF z_Hdm])
  next
   assume z_Hdo:"(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))))))))~=isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))" (is "?z_hcl~=?z_hm")
   have z_Hdp: "(?z_hm~=?z_hm)"
   by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vmda. (zenon_Vmda~=?z_hm))" "?z_hm" "(\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(?z_hm, (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(?z_hm, (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))))))", OF z_Hdo])
   show FALSE
   by (rule zenon_noteq [OF z_Hdp])
  next
   assume z_Hdt:"(~(\\A zenon_Vta:((zenon_Vta \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))=>((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[zenon_Vta]) \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[z])))))))" (is "~(\\A x : ?z_hea(x))")
   have z_Heb: "(\\E zenon_Vta:(~((zenon_Vta \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))=>((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[zenon_Vta]) \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[z])))))))" (is "\\E x : ?z_hed(x)")
   by (rule zenon_notallex_0 [of "?z_hea", OF z_Hdt])
   have z_Hee: "?z_hed((CHOOSE zenon_Vta:(~((zenon_Vta \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))=>((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[zenon_Vta]) \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[z]))))))))" (is "~(?z_heg=>?z_heh)")
   by (rule zenon_ex_choose_0 [of "?z_hed", OF z_Heb])
   have z_Heg: "?z_heg"
   by (rule zenon_notimply_0 [OF z_Hee])
   have z_Hei: "(~?z_heh)"
   by (rule zenon_notimply_1 [OF z_Hee])
   have z_Hej: "(~(\\E zenon_Vyb:((zenon_Vyb \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))&((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[(CHOOSE zenon_Vta:(~((zenon_Vta \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))=>((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[zenon_Vta]) \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[z])))))))])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[zenon_Vyb])))))" (is "~(\\E x : ?z_her(x))")
   by (rule zenon_notin_setofall_0 [of "(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[(CHOOSE zenon_Vta:(~((zenon_Vta \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))=>((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[zenon_Vta]) \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[z])))))))])" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[z]))", OF z_Hei])
   have z_Hes: "~?z_her((CHOOSE zenon_Vta:(~((zenon_Vta \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))=>((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[zenon_Vta]) \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[z]))))))))" (is "~(_&?z_het)")
   by (rule zenon_notex_0 [of "?z_her" "(CHOOSE zenon_Vta:(~((zenon_Vta \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))=>((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[zenon_Vta]) \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[z])))))))", OF z_Hej])
   show FALSE
   proof (rule zenon_notand [OF z_Hes])
    assume z_Heu:"(~?z_heg)"
    show FALSE
    by (rule notE [OF z_Heu z_Heg])
   next
    assume z_Hev:"((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[(CHOOSE zenon_Vta:(~((zenon_Vta \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))=>((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[zenon_Vta]) \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[z])))))))])~=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[(CHOOSE zenon_Vta:(~((zenon_Vta \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))=>((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[zenon_Vta]) \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[z])))))))]))" (is "?z_hep~=_")
    show FALSE
    by (rule zenon_noteq [OF z_Hev])
   qed
  qed
 next
  assume z_Hew:"(~?z_hk)"
  show FALSE
  by (rule notE [OF z_Hew z_Hk])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1876"; *} qed
lemma ob'1861:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> (subsetOf(([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) \<rightarrow> (A)]), %f. (\<forall> w \<in> (A) : (\<exists> q \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))) : (((fapply ((f), (q))) = (w))))))))"
assumes v'235: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'236: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'244: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
assumes v'281: "((((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))) = ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))))"
assumes v'282: "((((Cardinality ((setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))))) = ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))"
shows "((([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]) \<in> (subsetOf(([((isa_peri_peri_a (((Succ[0])), ((Cardinality ((setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))))))) \<rightarrow> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]), %f. (\<forall> w \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))) : (\<exists> q \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))))))) : (((fapply ((f), (q))) = (w)))))))))"(is "PROP ?ob'1861")
proof -
ML_command {* writeln "*** TLAPS ENTER 1861"; *}
show "PROP ?ob'1861"
using assms by auto
ML_command {* writeln "*** TLAPS EXIT 1861"; *} qed
lemma ob'1890:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "(((((((pc) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & (((X) \<in> (((Nat) \\ ({((0))}))))) & (((Q) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((i) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((j) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((l) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((x) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((v) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((M) \<in> ((SUBSET (subsetOf((CDomain), %a_ca. ((CFTypeOK ((a_ca))))))))))) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'235: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'236: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'244: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
fixes y
assumes y_in : "(y \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))))"
fixes z
assumes z_in : "(z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))))"
assumes v'286: "(((fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (y))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))"
assumes v'295: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'296: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'297: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'298: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'299: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'300: "((((a_jhash_primea :: c)) = (j)))"
assumes v'301: "((((a_lhash_primea :: c)) = (l)))"
assumes v'302: "((((a_xhash_primea :: c)) = (x)))"
assumes v'303: "((((a_vhash_primea :: c)) = (v)))"
assumes v'304: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca_1. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca_1)) :: c)) & (\<exists> d \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d)) :: c)))) : (\<exists> seq_1 \<in> ((Perm ((S)))) : ((((fapply ((a_ca_1), (''sigma''))) = ((Concat ((fapply ((d), (''sigma''))), ([ k_1 \<in> ((DOMAIN (seq_1)))  \<mapsto> (fapply ((v), (fapply ((seq_1), (k_1)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (S))), (((fapply ((fapply ((a_ca_1), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((a_ca_1), (''fres''))), (q))) = (fapply ((fapply ((d), (''fres''))), (q)))))))))))))))))"
shows "(((((fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (y))) = (p))) \<Rightarrow> (((((fapply ((pc), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (y))))) \<noteq> (''E2''))) \<and> (((fapply ((pc), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))) \<noteq> (''E2'')))))))"(is "PROP ?ob'1890")
proof -
ML_command {* writeln "*** TLAPS ENTER 1890"; *}
show "PROP ?ob'1890"
using assms by auto
ML_command {* writeln "*** TLAPS EXIT 1890"; *} qed
lemma ob'1949:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
assumes v'281: "(((\<exists> B \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((a_ca)) :: c)))) : (\<exists> pi \<in> ((Perm ((B)))) : ((((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))) = ((Concat ((fapply ((a_ca), (''sigma''))), ([ m \<in> ((DOMAIN (pi)))  \<mapsto> (fapply ((v), (fapply ((pi), (m)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (B))), (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q))))))))))) \<Rightarrow> (((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))) \<in> ((a_Mhash_primea :: c))))))"
assumes v'282: "(((setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))) \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((a_ca)) :: c))))))"
assumes v'283: "((([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]) \<in> ((Perm ((setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))))))"
shows "((((((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))) = ((Concat ((fapply ((a_ca), (''sigma''))), ([ m \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]), (m)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q))))))))) \<Rightarrow> (((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))) \<in> ((a_Mhash_primea :: c))))))"(is "PROP ?ob'1949")
proof -
ML_command {* writeln "*** TLAPS ENTER 1949"; *}
show "PROP ?ob'1949"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_2dd80d.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_2dd80d.znn.out
;; obligation #1949
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'281" (=> (TLA.bEx (TLA.SUBSET (hc4e622ce2e33ef1c6a9f10c01956cd a_ca)) ((B) (TLA.bEx (Perm B) ((pi) (/\ (= (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")
(Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN pi) ((m) (TLA.fapply v (TLA.fapply pi m))))))
(TLA.bAll ProcSet ((q) (TLA.cond (TLA.in q
B) (= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
ACK) (= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))))))))
(TLA.in (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q)))))
a_Mhash_primea))
$hyp "v'282" (TLA.in (TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))
(TLA.SUBSET (hc4e622ce2e33ef1c6a9f10c01956cd a_ca)))
$hyp "v'283" (TLA.in (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))
(Perm (TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))))
$goal (=> (/\ (= (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")
(Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((m) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))))))) m))))))
(TLA.bAll ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) (= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
ACK) (= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))))
(TLA.in (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q)))))
a_Mhash_primea))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hk:"(bEx(SUBSET(hc4e622ce2e33ef1c6a9f10c01956cd(a_ca)), (\<lambda>B. bEx(Perm(B), (\<lambda>pi. ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma''])=Concat((a_ca[''sigma'']), Fcn(DOMAIN(pi), (\<lambda>m. (v[(pi[m])])))))&bAll(ProcSet, (\<lambda>q. cond((q \\in B), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[q])=ACK), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[q])=((a_ca[''fres''])[q]))))))))))=>((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q])))))) \\in a_Mhash_primea))" (is "?z_ho=>?z_hdw")
 using v'281 by blast
 have z_Hl:"(setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))) \\in SUBSET(hc4e622ce2e33ef1c6a9f10c01956cd(a_ca)))" (is "?z_hl")
 using v'282 by blast
 have z_Hm:"(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))) \\in Perm(setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))))" (is "?z_hm")
 using v'283 by blast
 have zenon_L1_: "(~bAll(ProcSet, (\<lambda>q. cond((q \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[q])=ACK), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[q])=((a_ca[''fres''])[q])))))) ==> FALSE" (is "?z_hdz ==> FALSE")
 proof -
  assume z_Hdz:"?z_hdz" (is "~?z_hea")
  have z_Hef_z_Hdz: "(~(\\A x:((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=ACK), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=((a_ca[''fres''])[x])))))) == ?z_hdz" (is "?z_hef == _")
  by (unfold bAll_def)
  have z_Hef: "?z_hef" (is "~(\\A x : ?z_heq(x))")
  by (unfold z_Hef_z_Hdz, fact z_Hdz)
  have z_Her: "(\\E x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=ACK), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=((a_ca[''fres''])[x]))))))" (is "\\E x : ?z_het(x)")
  by (rule zenon_notallex_0 [of "?z_heq", OF z_Hef])
  have z_Heu: "?z_het((CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=ACK), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=((a_ca[''fres''])[x])))))))" (is "~(?z_hew=>?z_hex)")
  by (rule zenon_ex_choose_0 [of "?z_het", OF z_Her])
  have z_Hew: "?z_hew"
  by (rule zenon_notimply_0 [OF z_Heu])
  have z_Hey: "(~?z_hex)"
  by (rule zenon_notimply_1 [OF z_Heu])
  show FALSE
  proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vf. (~zenon_Vf))" "((CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=ACK), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=((a_ca[''fres''])[x])))))) \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))" "((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=ACK), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=((a_ca[''fres''])[x]))))))])=ACK)" "((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=ACK), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=((a_ca[''fres''])[x]))))))])=((a_ca[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=ACK), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=((a_ca[''fres''])[x]))))))]))", OF z_Hey])
   assume z_Hfc:"((CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=ACK), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=((a_ca[''fres''])[x])))))) \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))" (is "?z_hfc")
   assume z_Hfh:"((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=ACK), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=((a_ca[''fres''])[x]))))))])~=ACK)" (is "?z_hfe~=_")
   have z_Hfi: "((''fres'' \\in DOMAIN((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))))&(((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])=Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))" (is "?z_hfj&?z_hfl")
   by (rule zenon_recfield_2, ((rule zenon_recfield_3)+)?, rule zenon_recfield_3b, auto)
   have z_Hfl: "?z_hfl" (is "?z_hdu=?z_hcw")
   by (rule conjD2 [OF z_Hfi])
   have z_Hfm: "((?z_hcw[(CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((?z_hdu[x])=ACK), ((?z_hdu[x])=((a_ca[''fres''])[x]))))))])~=ACK)" (is "?z_hfn~=_")
   by (rule subst [where P="(\<lambda>zenon_Vbn. ((zenon_Vbn[(CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((?z_hdu[x])=ACK), ((?z_hdu[x])=((a_ca[''fres''])[x]))))))])~=ACK))", OF z_Hfl z_Hfh])
   show FALSE
   proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vaf. (zenon_Vaf~=ACK))" "ProcSet" "(\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q])))" "(CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((?z_hdu[x])=ACK), ((?z_hdu[x])=((a_ca[''fres''])[x]))))))", OF z_Hfm])
    assume z_Hfv:"(~?z_hew)"
    show FALSE
    by (rule notE [OF z_Hfv z_Hew])
   next
    assume z_Hfw:"(cond(((CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((?z_hdu[x])=ACK), ((?z_hdu[x])=((a_ca[''fres''])[x])))))) \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((?z_hdu[x])=ACK), ((?z_hdu[x])=((a_ca[''fres''])[x]))))))]))~=ACK)" (is "?z_hfx~=_")
    show FALSE
    proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vaf. (zenon_Vaf~=ACK))" "((CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((?z_hdu[x])=ACK), ((?z_hdu[x])=((a_ca[''fres''])[x])))))) \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))" "ACK" "((a_ca[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((?z_hdu[x])=ACK), ((?z_hdu[x])=((a_ca[''fres''])[x]))))))])", OF z_Hfw])
     assume z_Hfy:"((CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((?z_hdu[x])=ACK), ((?z_hdu[x])=((a_ca[''fres''])[x])))))) \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))" (is "?z_hfy")
     assume z_Hfz:"(ACK~=ACK)"
     show FALSE
     by (rule zenon_noteq [OF z_Hfz])
    next
     assume z_Hga:"(~((CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((?z_hdu[x])=ACK), ((?z_hdu[x])=((a_ca[''fres''])[x])))))) \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))))" (is "~?z_hfy")
     assume z_Hgb:"(((a_ca[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((?z_hdu[x])=ACK), ((?z_hdu[x])=((a_ca[''fres''])[x]))))))])~=ACK)" (is "?z_hfg~=_")
     have z_Hgc: "(~?z_hfc)"
     by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vin. (~((CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((?z_hdu[x])=ACK), ((?z_hdu[x])=((a_ca[''fres''])[x])))))) \\in setOfAll(zenon_Vin, (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hga])
     show FALSE
     by (rule notE [OF z_Hgc z_Hfc])
    qed
   qed
  next
   assume z_Hgc:"(~((CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=ACK), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=((a_ca[''fres''])[x])))))) \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))))" (is "~?z_hfc")
   assume z_Hgi:"((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=ACK), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=((a_ca[''fres''])[x]))))))])~=((a_ca[''fres''])[(CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=ACK), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[x])=((a_ca[''fres''])[x]))))))]))" (is "?z_hfe~=?z_hfg")
   have z_Hfi: "((''fres'' \\in DOMAIN((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))))&(((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])=Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))" (is "?z_hfj&?z_hfl")
   by (rule zenon_recfield_2, ((rule zenon_recfield_3)+)?, rule zenon_recfield_3b, auto)
   have z_Hfl: "?z_hfl" (is "?z_hdu=?z_hcw")
   by (rule conjD2 [OF z_Hfi])
   have z_Hgj: "((?z_hcw[(CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((?z_hdu[x])=ACK), ((?z_hdu[x])=((a_ca[''fres''])[x]))))))])~=?z_hfg)" (is "?z_hfn~=_")
   by (rule subst [where P="(\<lambda>zenon_Vom. ((zenon_Vom[(CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((?z_hdu[x])=ACK), ((?z_hdu[x])=((a_ca[''fres''])[x]))))))])~=?z_hfg))", OF z_Hfl z_Hgi])
   show FALSE
   proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vom. (zenon_Vom~=?z_hfg))" "ProcSet" "(\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q])))" "(CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((?z_hdu[x])=ACK), ((?z_hdu[x])=((a_ca[''fres''])[x]))))))", OF z_Hgj])
    assume z_Hfv:"(~?z_hew)"
    show FALSE
    by (rule notE [OF z_Hfv z_Hew])
   next
    assume z_Hgq:"(cond(((CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((?z_hdu[x])=ACK), ((?z_hdu[x])=((a_ca[''fres''])[x])))))) \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ?z_hfg)~=?z_hfg)" (is "?z_hfx~=_")
    show FALSE
    proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vom. (zenon_Vom~=?z_hfg))" "((CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((?z_hdu[x])=ACK), ((?z_hdu[x])=((a_ca[''fres''])[x])))))) \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))" "ACK" "?z_hfg", OF z_Hgq])
     assume z_Hfy:"((CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((?z_hdu[x])=ACK), ((?z_hdu[x])=((a_ca[''fres''])[x])))))) \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))" (is "?z_hfy")
     assume z_Hgr:"(ACK~=?z_hfg)"
     have z_Hfc: "?z_hfc"
     by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vym. ((CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((?z_hdu[x])=ACK), ((?z_hdu[x])=((a_ca[''fres''])[x])))))) \\in setOfAll(zenon_Vym, (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hfy])
     show FALSE
     by (rule notE [OF z_Hgc z_Hfc])
    next
     assume z_Hga:"(~((CHOOSE x:(~((x \\in ProcSet)=>cond((x \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((?z_hdu[x])=ACK), ((?z_hdu[x])=((a_ca[''fres''])[x])))))) \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))))" (is "~?z_hfy")
     assume z_Hgw:"(?z_hfg~=?z_hfg)"
     show FALSE
     by (rule zenon_noteq [OF z_Hgw])
    qed
   qed
  qed
 qed
 assume z_Hn:"(~(((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma''])=Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))&bAll(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[q])=ACK), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[q])=((a_ca[''fres''])[q]))))))=>?z_hdw))" (is "~(?z_hgy=>_)")
 have z_Hgy: "?z_hgy" (is "?z_hgz&?z_hha")
 by (rule zenon_notimply_0 [OF z_Hn])
 have z_Hhd: "(~?z_hdw)"
 by (rule zenon_notimply_1 [OF z_Hn])
 have z_Hgz: "?z_hgz" (is "?z_hz=?z_hbc")
 by (rule zenon_and_0 [OF z_Hgy])
 show FALSE
 proof (rule zenon_imply [OF z_Hk])
  assume z_Hhe:"(~?z_ho)"
  have z_Hhf_z_Hhe: "(~(\\E x:((x \\in SUBSET(hc4e622ce2e33ef1c6a9f10c01956cd(a_ca)))&bEx(Perm(x), (\<lambda>pi. ((?z_hz=Concat((a_ca[''sigma'']), Fcn(DOMAIN(pi), (\<lambda>m. (v[(pi[m])])))))&bAll(ProcSet, (\<lambda>q. cond((q \\in x), ((((''sigma'' :> (?z_hbc) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[q])=ACK), ((((''sigma'' :> (?z_hbc) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[q])=((a_ca[''fres''])[q]))))))))))) == (~?z_ho)" (is "?z_hhf == ?z_hhe")
  by (unfold bEx_def)
  have z_Hhf: "?z_hhf" (is "~(\\E x : ?z_hhr(x))")
  by (unfold z_Hhf_z_Hhe, fact z_Hhe)
  have z_Hhs: "(setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))) \\in SUBSET(hc4e622ce2e33ef1c6a9f10c01956cd(a_ca)))" (is "?z_hhs")
  by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vi. (setOfAll(zenon_Vi, (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))) \\in SUBSET(hc4e622ce2e33ef1c6a9f10c01956cd(a_ca))))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hl])
  have z_Hhx: "(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))) \\in Perm(setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))))" (is "?z_hhx")
  by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vg. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))) \\in Perm(setOfAll(zenon_Vg, (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hm])
  have z_Hie: "~?z_hhr(setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))" (is "~(_&?z_hif)")
  by (rule zenon_notex_0 [of "?z_hhr" "setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))", OF z_Hhf])
  show FALSE
  proof (rule zenon_notand [OF z_Hie])
   assume z_Hig:"(~?z_hhs)"
   show FALSE
   by (rule notE [OF z_Hig z_Hhs])
  next
   assume z_Hih:"(~?z_hif)"
   have z_Hii_z_Hih: "(~(\\E x:((x \\in Perm(setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))))&((?z_hz=Concat((a_ca[''sigma'']), Fcn(DOMAIN(x), (\<lambda>m. (v[(x[m])])))))&bAll(ProcSet, (\<lambda>q. cond((q \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((((''sigma'' :> (?z_hbc) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[q])=ACK), ((((''sigma'' :> (?z_hbc) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[q])=((a_ca[''fres''])[q]))))))))) == (~?z_hif)" (is "?z_hii == ?z_hih")
   by (unfold bEx_def)
   have z_Hii: "?z_hii" (is "~(\\E x : ?z_hiu(x))")
   by (unfold z_Hii_z_Hih, fact z_Hih)
   have z_Hiv: "~?z_hiu(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))))" (is "~(_&?z_hiw)")
   by (rule zenon_notex_0 [of "?z_hiu" "Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))", OF z_Hii])
   show FALSE
   proof (rule zenon_notand [OF z_Hiv])
    assume z_Hix:"(~?z_hhx)"
    show FALSE
    by (rule notE [OF z_Hix z_Hhx])
   next
    assume z_Hiy:"(~?z_hiw)" (is "~(_&?z_hea)")
    show FALSE
    proof (rule zenon_notand [OF z_Hiy])
     assume z_Hiz:"(?z_hz~=?z_hbc)"
     show FALSE
     by (rule notE [OF z_Hiz z_Hgz])
    next
     assume z_Hdz:"(~?z_hea)"
     show FALSE
     by (rule zenon_L1_ [OF z_Hdz])
    qed
   qed
  qed
 next
  assume z_Hdw:"?z_hdw"
  show FALSE
  by (rule notE [OF z_Hhd z_Hdw])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1949"; *} qed
lemma ob'1944:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'235: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'236: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'244: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
shows "((([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]) \<in> (subsetOf(([((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))) \<rightarrow> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]), %M_1. (\<forall> t \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))) : (\<exists> s \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))) : (((fapply ((M_1), (s))) = (t)))))))))"(is "PROP ?ob'1944")
proof -
ML_command {* writeln "*** TLAPS ENTER 1944"; *}
show "PROP ?ob'1944"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_a56ae6.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_a56ae6.znn.out
;; obligation #1944
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'235" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'236" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'244" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$goal (TLA.in (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))
(TLA.subsetOf (TLA.FuncSet (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) (TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ((M_1) (TLA.bAll (TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))) ((t) (TLA.bEx (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((s) (= (TLA.fapply M_1 s)
t))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 assume z_Hk:"(~(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))) \\in subsetOf(FuncSet(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), (\<lambda>M_1. bAll(setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))), (\<lambda>t. bEx(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>s. ((M_1[s])=t)))))))))" (is "~?z_hl")
 show FALSE
 proof (rule zenon_notin_subsetof [of "Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))" "FuncSet(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))" "(\<lambda>M_1. bAll(setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))), (\<lambda>t. bEx(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>s. ((M_1[s])=t))))))", OF z_Hk])
  assume z_Hcn:"(~(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))) \\in FuncSet(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))))" (is "~?z_hco")
  have z_Hcp: "(~(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))) \\in FuncSet(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))))" (is "~?z_hcq")
  by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vck. (~(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))) \\in FuncSet(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), setOfAll(zenon_Vck, (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))))))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hcn])
  show FALSE
  proof (rule zenon_notin_funcset [of "Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))", OF z_Hcp])
   assume z_Hcz:"(~isAFcn(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))))" (is "~?z_hda")
   show FALSE
   by (rule zenon_notisafcn_fcn [of "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hcz])
  next
   assume z_Hdb:"(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))))~=isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))" (is "?z_hca~=?z_hn")
   have z_Hdc: "(?z_hn~=?z_hn)"
   by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vop. (zenon_Vop~=?z_hn))" "?z_hn" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(?z_hn, (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(?z_hn, (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hdb])
   show FALSE
   by (rule zenon_noteq [OF z_Hdc])
  next
   assume z_Hdg:"(~(\\A zenon_Vhk:((zenon_Vhk \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))=>((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[zenon_Vhk]) \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))))))" (is "~(\\A x : ?z_hdn(x))")
   have z_Hdo: "(\\E zenon_Vhk:(~((zenon_Vhk \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))=>((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[zenon_Vhk]) \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))))))" (is "\\E x : ?z_hdq(x)")
   by (rule zenon_notallex_0 [of "?z_hdn", OF z_Hdg])
   have z_Hdr: "?z_hdq((CHOOSE zenon_Vhk:(~((zenon_Vhk \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))=>((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[zenon_Vhk]) \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))))))" (is "~(?z_hdt=>?z_hdu)")
   by (rule zenon_ex_choose_0 [of "?z_hdq", OF z_Hdo])
   have z_Hdt: "?z_hdt"
   by (rule zenon_notimply_0 [OF z_Hdr])
   have z_Hdv: "(~?z_hdu)"
   by (rule zenon_notimply_1 [OF z_Hdr])
   have z_Hdw: "(~(\\E zenon_Vtk:((zenon_Vtk \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))&((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[(CHOOSE zenon_Vhk:(~((zenon_Vhk \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))=>((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[zenon_Vhk]) \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))))))])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[zenon_Vtk])))))" (is "~(\\E x : ?z_hee(x))")
   by (rule zenon_notin_setofall_0 [of "(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[(CHOOSE zenon_Vhk:(~((zenon_Vhk \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))=>((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[zenon_Vhk]) \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))))))])" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))", OF z_Hdv])
   have z_Hef: "~?z_hee((CHOOSE zenon_Vhk:(~((zenon_Vhk \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))=>((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[zenon_Vhk]) \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))))))" (is "~(_&?z_heg)")
   by (rule zenon_notex_0 [of "?z_hee" "(CHOOSE zenon_Vhk:(~((zenon_Vhk \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))=>((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[zenon_Vhk]) \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))))))", OF z_Hdw])
   show FALSE
   proof (rule zenon_notand [OF z_Hef])
    assume z_Heh:"(~?z_hdt)"
    show FALSE
    by (rule notE [OF z_Heh z_Hdt])
   next
    assume z_Hei:"((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[(CHOOSE zenon_Vhk:(~((zenon_Vhk \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))=>((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[zenon_Vhk]) \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))))))])~=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[(CHOOSE zenon_Vhk:(~((zenon_Vhk \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))=>((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[zenon_Vhk]) \\in setOfAll(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))))))]))" (is "?z_hec~=_")
    show FALSE
    by (rule zenon_noteq [OF z_Hei])
   qed
  qed
 next
  assume z_Hej:"(~bAll(setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))), (\<lambda>t. bEx(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>s. ((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[s])=t))))))" (is "~?z_hek")
  have z_Heq_z_Hej: "(~(\\A x:((x \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))=>bEx(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>s. ((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[s])=x)))))) == (~?z_hek)" (is "?z_heq == ?z_hej")
  by (unfold bAll_def)
  have z_Heq: "?z_heq" (is "~(\\A x : ?z_hey(x))")
  by (unfold z_Heq_z_Hej, fact z_Hej)
  have z_Hez: "(\\E x:(~((x \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))=>bEx(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>s. ((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[s])=x))))))" (is "\\E x : ?z_hfb(x)")
  by (rule zenon_notallex_0 [of "?z_hey", OF z_Heq])
  have z_Hfc: "?z_hfb((CHOOSE x:(~((x \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))=>bEx(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>s. ((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[s])=x)))))))" (is "~(?z_hfe=>?z_hff)")
  by (rule zenon_ex_choose_0 [of "?z_hfb", OF z_Hez])
  have z_Hfe: "?z_hfe"
  by (rule zenon_notimply_0 [OF z_Hfc])
  have z_Hfg: "(~?z_hff)"
  by (rule zenon_notimply_1 [OF z_Hfc])
  have z_Hfh_z_Hfg: "(~(\\E x:((x \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))&((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[x])=(CHOOSE x:(~((x \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))=>bEx(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>s. ((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[s])=x)))))))))) == (~?z_hff)" (is "?z_hfh == ?z_hfg")
  by (unfold bEx_def)
  have z_Hfh: "?z_hfh" (is "~(\\E x : ?z_hfn(x))")
  by (unfold z_Hfh_z_Hfg, fact z_Hfg)
  have z_Hfo: "(\\E zenon_Vta:((zenon_Vta \\in DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))))&((CHOOSE x:(~((x \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))=>bEx(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>s. ((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[s])=x))))))=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[zenon_Vta]))))" (is "\\E x : ?z_hfu(x)")
  by (rule zenon_in_setofall_0 [of "(CHOOSE x:(~((x \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))=>bEx(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>s. ((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[s])=x))))))" "DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))))" "(\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))", OF z_Hfe])
  have z_Hfv: "?z_hfu((CHOOSE zenon_Vta:((zenon_Vta \\in DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))))&((CHOOSE x:(~((x \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))=>bEx(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>s. ((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[s])=x))))))=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[zenon_Vta])))))" (is "?z_hfx&?z_hfy")
  by (rule zenon_ex_choose_0 [of "?z_hfu", OF z_Hfo])
  have z_Hfx: "?z_hfx"
  by (rule zenon_and_0 [OF z_Hfv])
  have z_Hfy: "?z_hfy" (is "?z_hfd=?z_hfz")
  by (rule zenon_and_1 [OF z_Hfv])
  have z_Hga: "((CHOOSE zenon_Vta:((zenon_Vta \\in DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))))&(?z_hfd=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[zenon_Vta])))) \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))" (is "?z_hga")
  by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vwf. ((CHOOSE zenon_Vta:((zenon_Vta \\in DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))))&(?z_hfd=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[zenon_Vta])))) \\in zenon_Vwf))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hfx])
  have z_Hge: "~?z_hfn((CHOOSE zenon_Vta:((zenon_Vta \\in DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))))&(?z_hfd=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[zenon_Vta])))))" (is "~(_&?z_hgf)")
  by (rule zenon_notex_0 [of "?z_hfn" "(CHOOSE zenon_Vta:((zenon_Vta \\in DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))))&(?z_hfd=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[zenon_Vta]))))", OF z_Hfh])
  show FALSE
  proof (rule zenon_notand [OF z_Hge])
   assume z_Hgg:"(~?z_hga)"
   show FALSE
   by (rule notE [OF z_Hgg z_Hga])
  next
   assume z_Hgh:"(?z_hfz~=?z_hfd)"
   show FALSE
   by (rule zenon_eqsym [OF z_Hfy z_Hgh])
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1944"; *} qed
lemma ob'1940:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (\<forall> p \<in> (ProcSet) : (((((fapply ((pc), (p))) = (''E2''))) \<Rightarrow> (((leq (((Succ[0])), (fapply ((i), (p)))))) & ((less ((fapply ((i), (p))), (X)))) & (((fapply ((Q), (fapply ((i), (p))))) = (BOT))) & (\<forall> q \<in> (ProcSet) : (((((((fapply ((pc), (q))) \<in> ({(''E2''), (''E3'')}))) \<and> (((q) \<noteq> (p))))) \<Rightarrow> (((fapply ((i), (q))) \<noteq> (fapply ((i), (p)))))))))))) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'235: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'236: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'244: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
fixes y
assumes y_in : "(y \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))))"
fixes z
assumes z_in : "(z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))))"
assumes v'286: "(((fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (y))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))"
assumes v'304: "(((fapply ((pc), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (y))))) = (''E2'')))"
assumes v'305: "(((fapply ((i), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (y))))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (y)))))"
assumes v'310: "(((fapply ((pc), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (y))))) = (''E2'')))"
assumes v'311: "(((fapply ((i), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (y))))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (y)))))"
assumes v'312: "(((fapply ((pc), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))) = (''E2'')))"
assumes v'313: "(((fapply ((i), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))"
assumes v'314: "(\<forall> q \<in> (setOfAll(((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]))), %z_1. (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1))))) : ((((q) \<in> (ProcSet))) & (\<exists> z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]))) : (((((((q) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (q))) = (''E2''))) \<and> (((fapply ((i), (q))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))))))))"
shows "(((fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (y))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))"(is "PROP ?ob'1940")
proof -
ML_command {* writeln "*** TLAPS ENTER 1940"; *}
show "PROP ?ob'1940"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_307c1e.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_307c1e.znn.out
;; obligation #1940
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK (TLA.bAll ProcSet ((p) (=> (= (TLA.fapply pc p)
"E2") (/\ (arith.le (TLA.fapply TLA.Succ 0) (TLA.fapply i p))
(arith.lt (TLA.fapply i p) X) (= (TLA.fapply Q (TLA.fapply i p)) BOT)
(TLA.bAll ProcSet ((q) (=> (/\ (TLA.in (TLA.fapply pc q) (TLA.set "E2" "E3"))
(-. (= q p))) (-. (= (TLA.fapply i q) (TLA.fapply i p)))))))))) a_Invunde_E3a
a_Invunde_D2a a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'235" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'236" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'244" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "y_in" (TLA.in y (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))))
$hyp "z_in" (TLA.in z (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))))
$hyp "v'286" (= (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) y)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))
$hyp "v'304" (= (TLA.fapply pc (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) y))
"E2")
$hyp "v'305" (= (TLA.fapply i (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) y))
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) y))
$hyp "v'310" (= (TLA.fapply pc (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) y))
"E2")
$hyp "v'311" (= (TLA.fapply i (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) y))
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) y))
$hyp "v'312" (= (TLA.fapply pc (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))
"E2")
$hyp "v'313" (= (TLA.fapply i (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))
$hyp "v'314" (TLA.bAll (TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1))) ((q) (/\ (TLA.in q
ProcSet)
(TLA.bEx (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (\/ (/\ (= q
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc q) "E2") (= (TLA.fapply i q)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))))
$goal (= (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) y)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hm:"((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[y])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1]))))))))[z]))" (is "?z_ht=?z_hcg")
 using v'286 by blast
 have z_Ho:"((i[?z_ht])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[y]))" (is "?z_hci=?z_hcj")
 using v'311 by blast
 have z_Hq:"((i[?z_hcg])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z]))" (is "?z_hck=?z_hcl")
 using v'313 by blast
 have z_Hk:"(y \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))" (is "?z_hk")
 using y_in by blast
 assume z_Hs:"(?z_hcj~=?z_hcl)"
 show FALSE
 proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vl. (zenon_Vl=?z_hcg))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))))))" "y", OF z_Hm])
  assume z_Hcp:"(~?z_hk)"
  show FALSE
  by (rule notE [OF z_Hcp z_Hk])
 next
  assume z_Hcq:"(bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=?z_hcj))|(((pc[r])=''E2'')&((i[r])=?z_hcj)))))=?z_hcg)" (is "?z_hcr=_")
  have z_Hcy_z_Hcq: "((CHOOSE x:((x \\in ProcSet)&(((x=p)&(X=?z_hcj))|(((pc[x])=''E2'')&((i[x])=?z_hcj)))))=?z_hcg) == (?z_hcr=?z_hcg)" (is "?z_hcy == ?z_hcq")
  by (unfold bChoose_def)
  have z_Hcy: "?z_hcy" (is "?z_hcz=_")
  by (unfold z_Hcy_z_Hcq, fact z_Hcq)
  show FALSE
  proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vj. ((i[zenon_Vj])=?z_hcj))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z_1. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_2. (seq[(z_2 + (k +  -.(1)))])))[z_1])))))))" "y", OF z_Ho])
   assume z_Hcp:"(~?z_hk)"
   show FALSE
   by (rule notE [OF z_Hcp z_Hk])
  next
   assume z_Hdp:"((i[?z_hcr])=?z_hcj)" (is "?z_hdq=_")
   have z_Hdr_z_Hdp: "((i[?z_hcz])=?z_hcj) == (?z_hdq=?z_hcj)" (is "?z_hdr == ?z_hdp")
   by (unfold bChoose_def)
   have z_Hdr: "?z_hdr" (is "?z_hds=_")
   by (unfold z_Hdr_z_Hdp, fact z_Hdp)
   show FALSE
   proof (rule notE [OF z_Hs])
    have z_Hdt: "(?z_hck=?z_hcj)"
    proof (rule zenon_nnpp [of "(?z_hck=?z_hcj)"])
     assume z_Hdu:"(?z_hck~=?z_hcj)"
     show FALSE
     proof (rule zenon_em [of "(?z_hcj=?z_hcj)"])
      assume z_Hdv:"(?z_hcj=?z_hcj)"
      show FALSE
      proof (rule notE [OF z_Hdu])
       have z_Hdw: "(?z_hcj=?z_hck)"
       proof (rule zenon_nnpp [of "(?z_hcj=?z_hck)"])
        assume z_Hdx:"(?z_hcj~=?z_hck)"
        show FALSE
        proof (rule zenon_em [of "(?z_hck=?z_hck)"])
         assume z_Hdy:"(?z_hck=?z_hck)"
         show FALSE
         proof (rule notE [OF z_Hdx])
          have z_Hdt: "(?z_hck=?z_hcj)"
          proof (rule zenon_nnpp [of "(?z_hck=?z_hcj)"])
           assume z_Hdu:"(?z_hck~=?z_hcj)"
           show FALSE
           proof (rule notE [OF z_Hdu])
            have z_Hdz: "(?z_hds=?z_hck)"
            proof (rule zenon_nnpp [of "(?z_hds=?z_hck)"])
             assume z_Hea:"(?z_hds~=?z_hck)"
             show FALSE
             proof (rule zenon_em [of "(?z_hck=?z_hck)"])
              assume z_Hdy:"(?z_hck=?z_hck)"
              show FALSE
              proof (rule notE [OF z_Hea])
               have z_Heb: "(?z_hck=?z_hds)"
               proof (rule zenon_nnpp [of "(?z_hck=?z_hds)"])
               assume z_Hec:"(?z_hck~=?z_hds)"
               show FALSE
               proof (rule zenon_noteq [of "?z_hds"])
               have z_Hed: "(?z_hcg=?z_hcz)"
               by (rule sym [OF z_Hcy])
               have z_Hee: "(?z_hds~=?z_hds)"
               by (rule subst [where P="(\<lambda>zenon_Vhba. ((i[zenon_Vhba])~=?z_hds))", OF z_Hed], fact z_Hec)
               thus "(?z_hds~=?z_hds)" .
               qed
               qed
               have z_Hdz: "(?z_hds=?z_hck)"
               by (rule subst [where P="(\<lambda>zenon_Vkba. (zenon_Vkba=?z_hck))", OF z_Heb], fact z_Hdy)
               thus "(?z_hds=?z_hck)" .
              qed
             next
              assume z_Hem:"(?z_hck~=?z_hck)"
              show FALSE
              by (rule zenon_noteq [OF z_Hem])
             qed
            qed
            have z_Hdt: "(?z_hck=?z_hcj)"
            by (rule subst [where P="(\<lambda>zenon_Vlba. (zenon_Vlba=?z_hcj))", OF z_Hdz], fact z_Hdr)
            thus "(?z_hck=?z_hcj)" .
           qed
          qed
          have z_Hdw: "(?z_hcj=?z_hck)"
          by (rule subst [where P="(\<lambda>zenon_Vkba. (zenon_Vkba=?z_hck))", OF z_Hdt], fact z_Hdy)
          thus "(?z_hcj=?z_hck)" .
         qed
        next
         assume z_Hem:"(?z_hck~=?z_hck)"
         show FALSE
         by (rule zenon_noteq [OF z_Hem])
        qed
       qed
       have z_Hdt: "(?z_hck=?z_hcj)"
       by (rule subst [where P="(\<lambda>zenon_Vlba. (zenon_Vlba=?z_hcj))", OF z_Hdw], fact z_Hdv)
       thus "(?z_hck=?z_hcj)" .
      qed
     next
      assume z_Heq:"(?z_hcj~=?z_hcj)"
      show FALSE
      by (rule zenon_noteq [OF z_Heq])
     qed
    qed
    have z_Her: "(?z_hcj=?z_hcl)"
    by (rule subst [where P="(\<lambda>zenon_Voba. (zenon_Voba=?z_hcl))", OF z_Hdt], fact z_Hq)
    thus "(?z_hcj=?z_hcl)" .
   qed
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1940"; *} qed
lemma ob'1933:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "(((((((pc) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & (((X) \<in> (((Nat) \\ ({((0))}))))) & (((Q) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((i) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((j) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((l) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((x) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((v) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((M) \<in> ((SUBSET (subsetOf((CDomain), %a_ca. ((CFTypeOK ((a_ca))))))))))) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'235: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'236: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'244: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
fixes y
assumes y_in : "(y \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))))"
fixes z
assumes z_in : "(z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))))"
assumes v'286: "(((fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (y))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))"
assumes v'304: "(((fapply ((pc), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (y))))) = (''E2'')))"
assumes v'305: "(((fapply ((i), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (y))))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (y)))))"
assumes v'308: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'309: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'310: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'311: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'312: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'313: "((((a_jhash_primea :: c)) = (j)))"
assumes v'314: "((((a_lhash_primea :: c)) = (l)))"
assumes v'315: "((((a_xhash_primea :: c)) = (x)))"
assumes v'316: "((((a_vhash_primea :: c)) = (v)))"
assumes v'317: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca_1. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca_1)) :: c)) & (\<exists> d \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d)) :: c)))) : (\<exists> seq_1 \<in> ((Perm ((S)))) : ((((fapply ((a_ca_1), (''sigma''))) = ((Concat ((fapply ((d), (''sigma''))), ([ k_1 \<in> ((DOMAIN (seq_1)))  \<mapsto> (fapply ((v), (fapply ((seq_1), (k_1)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (S))), (((fapply ((fapply ((a_ca_1), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((a_ca_1), (''fres''))), (q))) = (fapply ((fapply ((d), (''fres''))), (q)))))))))))))))))"
shows "(((((fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (y))) \<noteq> (p))) \<and> (((fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))) \<noteq> (p)))))"(is "PROP ?ob'1933")
proof -
ML_command {* writeln "*** TLAPS ENTER 1933"; *}
show "PROP ?ob'1933"
using assms by auto
ML_command {* writeln "*** TLAPS EXIT 1933"; *} qed
lemma ob'1985:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
assumes v'293: "(((fapply ((d), (''sigma''))) = ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))))))))  \<mapsto> (cond(((leq ((z), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))), (fapply ((fapply ((a_ca), (''sigma''))), (z))), (fapply (([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]), ((arith_add ((z), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))])))"
assumes v'294: "((((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))))) = ((Cardinality ((A))))))"
shows "((((DOMAIN (fapply ((d), (''sigma''))))) = ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A)))))))))"(is "PROP ?ob'1985")
proof -
ML_command {* writeln "*** TLAPS ENTER 1985"; *}
show "PROP ?ob'1985"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_51139c.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_51139c.znn.out
;; obligation #1985
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'293" (= (TLA.fapply d "sigma")
(TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))))) ((z) (TLA.cond (arith.le z
(a_Lena (TLA.fapply a_ca "sigma"))) (TLA.fapply (TLA.fapply a_ca "sigma") z) (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1)))) (arith.add z
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))))))
$hyp "v'294" (= (arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))))
(Cardinality A))
$goal (= (TLA.DOMAIN (TLA.fapply d "sigma"))
(arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hl:"((a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))=Cardinality(A))" (is "?z_hn=?z_hz")
 using v'294 by blast
 have z_Hk:"((d[''sigma''])=Fcn(isa'dotdot(1, ?z_hn), (\<lambda>z. cond((z <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[z]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(z +  -.(a_Lena((a_ca[''sigma'']))))])))))" (is "?z_hck=?z_hcm")
 using v'293 by blast
 assume z_Hm:"(DOMAIN(?z_hck)~=isa'dotdot(1, ?z_hz))" (is "?z_hcv~=?z_hcw")
 have z_Hcx: "((a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))=?z_hz)" (is "?z_hcy=_")
 by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vi. ((a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(zenon_Vi, (\<lambda>z. (v[(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))=?z_hz))" "isa'dotdot(1, (?z_hz +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hl])
 have z_Hdh: "(~(\\A zenon_Vh:((zenon_Vh \\in ?z_hcv)<=>(zenon_Vh \\in ?z_hcw))))" (is "~(\\A x : ?z_hdn(x))")
 by (rule zenon_notsetequal_0 [of "?z_hcv" "?z_hcw", OF z_Hm])
 have z_Hdo: "(\\E zenon_Vh:(~((zenon_Vh \\in ?z_hcv)<=>(zenon_Vh \\in ?z_hcw))))" (is "\\E x : ?z_hdq(x)")
 by (rule zenon_notallex_0 [of "?z_hdn", OF z_Hdh])
 have z_Hdr: "?z_hdq((CHOOSE zenon_Vh:(~((zenon_Vh \\in ?z_hcv)<=>(zenon_Vh \\in ?z_hcw)))))" (is "~(?z_hdt<=>?z_hdu)")
 by (rule zenon_ex_choose_0 [of "?z_hdq", OF z_Hdo])
 show FALSE
 proof (rule zenon_notequiv [OF z_Hdr])
  assume z_Hdv:"(~?z_hdt)"
  assume z_Hdu:"?z_hdu"
  have z_Hdw: "(~((CHOOSE zenon_Vh:(~((zenon_Vh \\in ?z_hcv)<=>(zenon_Vh \\in ?z_hcw)))) \\in DOMAIN(?z_hcm)))" (is "~?z_hdx")
  by (rule subst [where P="(\<lambda>zenon_Vtb. (~((CHOOSE zenon_Vh:(~((zenon_Vh \\in ?z_hcv)<=>(zenon_Vh \\in ?z_hcw)))) \\in DOMAIN(zenon_Vtb))))", OF z_Hk z_Hdv])
  have z_Hee: "(~((CHOOSE zenon_Vh:(~((zenon_Vh \\in ?z_hcv)<=>(zenon_Vh \\in ?z_hcw)))) \\in isa'dotdot(1, ?z_hn)))" (is "~?z_hef")
  by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vbb. (~((CHOOSE zenon_Vh:(~((zenon_Vh \\in ?z_hcv)<=>(zenon_Vh \\in ?z_hcw)))) \\in zenon_Vbb)))" "isa'dotdot(1, ?z_hn)" "(\<lambda>z. cond((z <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[z]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(z +  -.(a_Lena((a_ca[''sigma'']))))])))", OF z_Hdw])
  have z_Hek: "(~((CHOOSE zenon_Vh:(~((zenon_Vh \\in ?z_hcv)<=>(zenon_Vh \\in ?z_hcw)))) \\in isa'dotdot(1, ?z_hcy)))" (is "~?z_hel")
  by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vwb. (~((CHOOSE zenon_Vh:(~((zenon_Vh \\in ?z_hcv)<=>(zenon_Vh \\in ?z_hcw)))) \\in isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(zenon_Vwb, (\<lambda>z. (v[(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))))))" "isa'dotdot(1, (?z_hz +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hee])
  show FALSE
  proof (rule notE [OF z_Hek])
   have z_Hev: "(?z_hcw=isa'dotdot(1, ?z_hcy))" (is "_=?z_hem")
   proof (rule zenon_nnpp [of "(?z_hcw=?z_hem)"])
    assume z_Hew:"(?z_hcw~=?z_hem)"
    show FALSE
    proof (rule zenon_noteq [of "?z_hem"])
     have z_Hex: "(?z_hz=?z_hcy)"
     by (rule sym [OF z_Hcx])
     have z_Hey: "(?z_hem~=?z_hem)"
     by (rule subst [where P="(\<lambda>zenon_Vcc. (isa'dotdot(1, zenon_Vcc)~=?z_hem))", OF z_Hex], fact z_Hew)
     thus "(?z_hem~=?z_hem)" .
    qed
   qed
   have z_Hel: "?z_hel"
   by (rule subst [where P="(\<lambda>zenon_Vdb. ((CHOOSE zenon_Vh:(~((zenon_Vh \\in ?z_hcv)<=>(zenon_Vh \\in ?z_hcw)))) \\in zenon_Vdb))", OF z_Hev], fact z_Hdu)
   thus "?z_hel" .
  qed
 next
  assume z_Hdt:"?z_hdt"
  assume z_Hfg:"(~?z_hdu)"
  have z_Hdx: "((CHOOSE zenon_Vh:(~((zenon_Vh \\in ?z_hcv)<=>(zenon_Vh \\in ?z_hcw)))) \\in DOMAIN(?z_hcm))" (is "?z_hdx")
  by (rule subst [where P="(\<lambda>zenon_Veb. ((CHOOSE zenon_Vh:(~((zenon_Vh \\in ?z_hcv)<=>(zenon_Vh \\in ?z_hcw)))) \\in DOMAIN(zenon_Veb)))", OF z_Hk z_Hdt])
  have z_Hef: "((CHOOSE zenon_Vh:(~((zenon_Vh \\in ?z_hcv)<=>(zenon_Vh \\in ?z_hcw)))) \\in isa'dotdot(1, ?z_hn))" (is "?z_hef")
  by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vdb. ((CHOOSE zenon_Vh:(~((zenon_Vh \\in ?z_hcv)<=>(zenon_Vh \\in ?z_hcw)))) \\in zenon_Vdb))" "isa'dotdot(1, ?z_hn)" "(\<lambda>z. cond((z <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[z]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(z +  -.(a_Lena((a_ca[''sigma'']))))])))", OF z_Hdx])
  have z_Hel: "((CHOOSE zenon_Vh:(~((zenon_Vh \\in ?z_hcv)<=>(zenon_Vh \\in ?z_hcw)))) \\in isa'dotdot(1, ?z_hcy))" (is "?z_hel")
  by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vhb. ((CHOOSE zenon_Vh:(~((zenon_Vh \\in ?z_hcv)<=>(zenon_Vh \\in ?z_hcw)))) \\in isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(zenon_Vhb, (\<lambda>z. (v[(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))))))" "isa'dotdot(1, (?z_hz +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (?z_hz +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))", OF z_Hef])
  show FALSE
  proof (rule notE [OF z_Hfg])
   have z_Hfs: "(isa'dotdot(1, ?z_hcy)=?z_hcw)" (is "?z_hem=_")
   proof (rule zenon_nnpp [of "(?z_hem=?z_hcw)"])
    assume z_Hft:"(?z_hem~=?z_hcw)"
    show FALSE
    proof (rule zenon_noteq [of "?z_hcw"])
     have z_Hfu: "(?z_hcw~=?z_hcw)"
     by (rule subst [where P="(\<lambda>zenon_Vkc. (isa'dotdot(1, zenon_Vkc)~=?z_hcw))", OF z_Hcx], fact z_Hft)
     thus "(?z_hcw~=?z_hcw)" .
    qed
   qed
   have z_Hdu: "?z_hdu"
   by (rule subst [where P="(\<lambda>zenon_Vdb. ((CHOOSE zenon_Vh:(~((zenon_Vh \\in ?z_hcv)<=>(zenon_Vh \\in ?z_hcw)))) \\in zenon_Vdb))", OF z_Hfs], fact z_Hel)
   thus "?z_hdu" .
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1985"; *} qed
lemma ob'1973:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'235: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'236: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'244: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
shows "(((fapply ((((''sigma'' :> ([ k_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))))))))  \<mapsto> (cond(((leq ((k_1), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))), (fapply ((fapply ((a_ca), (''sigma''))), (k_1))), (fapply (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]), ((arith_add ((k_1), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))])) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))) = ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))))))))  \<mapsto> (cond(((leq ((z), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))), (fapply ((fapply ((a_ca), (''sigma''))), (z))), (fapply (([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]), ((arith_add ((z), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))])))"(is "PROP ?ob'1973")
proof -
ML_command {* writeln "*** TLAPS ENTER 1973"; *}
show "PROP ?ob'1973"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_a2bb25.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_a2bb25.znn.out
;; obligation #1973
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'235" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'236" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'244" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$goal (= (TLA.fapply (TLA.record "sigma" (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))))) ((k_1) (TLA.cond (arith.le k_1
(a_Lena (TLA.fapply a_ca "sigma"))) (TLA.fapply (TLA.fapply a_ca "sigma") k_1) (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) (arith.add k_1
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")
(TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))))) ((z) (TLA.cond (arith.le z
(a_Lena (TLA.fapply a_ca "sigma"))) (TLA.fapply (TLA.fapply a_ca "sigma") z) (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1)))) (arith.add z
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 assume z_Hk:"(((''sigma'' :> (Fcn(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (\<lambda>k_1. cond((k_1 <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[k_1]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(k_1 +  -.(a_Lena((a_ca[''sigma'']))))]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma''])~=Fcn(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (\<lambda>k_1. cond((k_1 <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[k_1]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(k_1 +  -.(a_Lena((a_ca[''sigma'']))))])))))" (is "?z_hl~=?z_ho")
 have z_Hdf: "((''sigma'' \\in DOMAIN((''sigma'' :> (?z_ho) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))))&(?z_hl=?z_ho))" (is "?z_hdg&?z_hdi")
 by ((rule zenon_recfield_1)+, rule zenon_recfield_2b)
 have z_Hdi: "?z_hdi"
 by (rule conjD2 [OF z_Hdf])
 have z_Hdj: "(?z_ho~=?z_ho)"
 by (rule subst [where P="(\<lambda>zenon_Vf. (zenon_Vf~=?z_ho))", OF z_Hdi z_Hk])
 show FALSE
 by (rule zenon_noteq [OF z_Hdj])
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1973"; *} qed
lemma ob'1964:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
assumes v'290: "((((a_h5f69bd2035062162153eeb4da53c07a ((seq), (fapply (((a_h131f04ef3dd102f4156afe21bc2f50a :: c)), (''sigma'')))) :: c)) = (((fapply ((d), (''sigma''))) = ([ m \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (m))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (m)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m)))))))))))))])))))"
assumes v'291: "(((fapply ((d), (''sigma''))) \<in> ([((DOMAIN (seq))) \<rightarrow> (((Nat) \\ ({((0))})))])))"
assumes v'292: "((([ m \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (m))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (m)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m)))))))))))))]) \<in> ([((DOMAIN (seq))) \<rightarrow> (((Nat) \\ ({((0))})))])))"
assumes v'293: "(\<forall> m \<in> ((DOMAIN (seq))) : (((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply (([ m_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (m_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (m_1)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m_1)))))))))))))]), (m))))))"
shows "((a_h5f69bd2035062162153eeb4da53c07a ((seq), (fapply (((a_h131f04ef3dd102f4156afe21bc2f50a :: c)), (''sigma'')))) :: c))"(is "PROP ?ob'1964")
proof -
ML_command {* writeln "*** TLAPS ENTER 1964"; *}
show "PROP ?ob'1964"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_93a46e.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_93a46e.znn.out
;; obligation #1964
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'290" (= (a_h5f69bd2035062162153eeb4da53c07a seq
(TLA.fapply a_h131f04ef3dd102f4156afe21bc2f50a "sigma"))
(= (TLA.fapply d "sigma")
(TLA.Fcn (TLA.DOMAIN seq) ((m) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq m))
BOT)) (TLA.fapply Q (TLA.fapply seq m)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq m)))))))))))
$hyp "v'291" (TLA.in (TLA.fapply d "sigma")
(TLA.FuncSet (TLA.DOMAIN seq) (TLA.setminus arith.N
(TLA.set 0))))
$hyp "v'292" (TLA.in (TLA.Fcn (TLA.DOMAIN seq) ((m) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq m))
BOT)) (TLA.fapply Q (TLA.fapply seq m)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q) (TLA.fapply seq m)))))))))
(TLA.FuncSet (TLA.DOMAIN seq) (TLA.setminus arith.N
(TLA.set 0))))
$hyp "v'293" (TLA.bAll (TLA.DOMAIN seq) ((m) (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((m_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq m_1))
BOT)) (TLA.fapply Q (TLA.fapply seq m_1)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq m_1))))))))) m))))
$goal (a_h5f69bd2035062162153eeb4da53c07a seq
(TLA.fapply a_h131f04ef3dd102f4156afe21bc2f50a "sigma"))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hn:"bAll(DOMAIN(seq), (\<lambda>m. (((d[''sigma''])[m])=(Fcn(DOMAIN(seq), (\<lambda>m. (CASE ((Q[(seq[m])])~=BOT) -> (Q[(seq[m])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))))]))))[m]))))" (is "?z_hn")
 using v'293 by blast
 have z_Hm:"(Fcn(DOMAIN(seq), (\<lambda>m. (CASE ((Q[(seq[m])])~=BOT) -> (Q[(seq[m])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))))])))) \\in FuncSet(DOMAIN(seq), (Nat \\ {0})))" (is "?z_hm")
 using v'292 by blast
 have z_Hk:"(a_h5f69bd2035062162153eeb4da53c07a(seq, (a_h131f04ef3dd102f4156afe21bc2f50a[''sigma'']))=((d[''sigma''])=Fcn(DOMAIN(seq), (\<lambda>m. (CASE ((Q[(seq[m])])~=BOT) -> (Q[(seq[m])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))))]))))))" (is "?z_hca=?z_hcd")
 using v'290 by blast
 have z_Hl:"((d[''sigma'']) \\in FuncSet(DOMAIN(seq), (Nat \\ {0})))" (is "?z_hl")
 using v'291 by blast
 assume z_Ho:"(~?z_hca)"
 have z_Hce_z_Hn: "(\\A x:((x \\in DOMAIN(seq))=>(((d[''sigma''])[x])=(Fcn(DOMAIN(seq), (\<lambda>m. (CASE ((Q[(seq[m])])~=BOT) -> (Q[(seq[m])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))))]))))[x])))) == ?z_hn" (is "?z_hce == _")
 by (unfold bAll_def)
 have z_Hce: "?z_hce" (is "\\A x : ?z_hcl(x)")
 by (unfold z_Hce_z_Hn, fact z_Hn)
 have z_Hcm: "isAFcn((d[''sigma'']))" (is "?z_hcm")
 by (rule zenon_in_funcset_0 [of "(d[''sigma''])" "DOMAIN(seq)" "(Nat \\ {0})", OF z_Hl])
 have z_Hcn: "(DOMAIN((d[''sigma'']))=DOMAIN(seq))" (is "?z_hco=?z_hp")
 by (rule zenon_in_funcset_1 [of "(d[''sigma''])" "?z_hp" "(Nat \\ {0})", OF z_Hl])
 have z_Hcp: "isAFcn(Fcn(?z_hp, (\<lambda>m. (CASE ((Q[(seq[m])])~=BOT) -> (Q[(seq[m])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))))])))))" (is "?z_hcp")
 by (rule zenon_in_funcset_0 [of "Fcn(?z_hp, (\<lambda>m. (CASE ((Q[(seq[m])])~=BOT) -> (Q[(seq[m])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))))]))))" "?z_hp" "(Nat \\ {0})", OF z_Hm])
 show FALSE
 proof (rule zenon_boolcase_equal [of "(\<lambda>zenon_Vr. (?z_hca=zenon_Vr))" "(d[''sigma''])" "Fcn(?z_hp, (\<lambda>m. (CASE ((Q[(seq[m])])~=BOT) -> (Q[(seq[m])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))))]))))", OF z_Hk])
  assume z_Hct:"(?z_hcd=TRUE)" (is "_=?z_hcu")
  assume z_Hcv:"(?z_hca=?z_hcu)"
  have z_Hca: "?z_hca"
  by (rule zenon_eq_x_true_0 [of "?z_hca", OF z_Hcv])
  show FALSE
  by (rule notE [OF z_Ho z_Hca])
 next
  assume z_Hcw:"(?z_hcd=FALSE)" (is "_=?z_hcx")
  assume z_Hcy:"(?z_hca=?z_hcx)"
  have z_Hcz: "((d[''sigma''])~=Fcn(?z_hp, (\<lambda>m. (CASE ((Q[(seq[m])])~=BOT) -> (Q[(seq[m])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))))])))))" (is "?z_hu~=?z_hz")
  by (rule zenon_eq_x_false_0 [of "?z_hcd", OF z_Hcw])
  have z_Hda: "(~(((?z_hcm&?z_hcp)&(?z_hco=DOMAIN(?z_hz)))&(\\A zenon_Vdc:((zenon_Vdc \\in DOMAIN(?z_hz))=>((?z_hu[zenon_Vdc])=(?z_hz[zenon_Vdc]))))))" (is "~(?z_hdc&?z_hdg)")
  by (rule zenon_notfunequal_0 [of "?z_hu" "?z_hz", OF z_Hcz])
  show FALSE
  proof (rule zenon_notand [OF z_Hda])
   assume z_Hdn:"(~?z_hdc)" (is "~(?z_hdd&?z_hde)")
   show FALSE
   proof (rule zenon_notand [OF z_Hdn])
    assume z_Hdo:"(~?z_hdd)"
    show FALSE
    proof (rule zenon_notand [OF z_Hdo])
     assume z_Hdp:"(~?z_hcm)"
     show FALSE
     by (rule notE [OF z_Hdp z_Hcm])
    next
     assume z_Hdq:"(~?z_hcp)"
     show FALSE
     by (rule notE [OF z_Hdq z_Hcp])
    qed
   next
    assume z_Hdr:"(?z_hco~=DOMAIN(?z_hz))" (is "_~=?z_hdf")
    have z_Hds: "(?z_hco~=?z_hp)"
    by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vlpc. (?z_hco~=zenon_Vlpc))" "?z_hp" "(\<lambda>m. (CASE ((Q[(seq[m])])~=BOT) -> (Q[(seq[m])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))))])))", OF z_Hdr])
    show FALSE
    by (rule notE [OF z_Hds z_Hcn])
   qed
  next
   assume z_Hdw:"(~?z_hdg)" (is "~(\\A x : ?z_hdx(x))")
   have z_Hdy: "(\\E zenon_Vdc:(~((zenon_Vdc \\in DOMAIN(?z_hz))=>((?z_hu[zenon_Vdc])=(?z_hz[zenon_Vdc])))))" (is "\\E x : ?z_hea(x)")
   by (rule zenon_notallex_0 [of "?z_hdx", OF z_Hdw])
   have z_Heb: "?z_hea((CHOOSE zenon_Vdc:(~((zenon_Vdc \\in DOMAIN(?z_hz))=>((?z_hu[zenon_Vdc])=(?z_hz[zenon_Vdc]))))))" (is "~(?z_hed=>?z_hee)")
   by (rule zenon_ex_choose_0 [of "?z_hea", OF z_Hdy])
   have z_Hed: "?z_hed"
   by (rule zenon_notimply_0 [OF z_Heb])
   have z_Hef: "((?z_hu[(CHOOSE zenon_Vdc:(~((zenon_Vdc \\in DOMAIN(?z_hz))=>((?z_hu[zenon_Vdc])=(?z_hz[zenon_Vdc])))))])~=(?z_hz[(CHOOSE zenon_Vdc:(~((zenon_Vdc \\in DOMAIN(?z_hz))=>((?z_hu[zenon_Vdc])=(?z_hz[zenon_Vdc])))))]))" (is "?z_heg~=?z_heh")
   by (rule zenon_notimply_1 [OF z_Heb])
   have z_Hei: "((CHOOSE zenon_Vdc:(~((zenon_Vdc \\in DOMAIN(?z_hz))=>((?z_hu[zenon_Vdc])=(?z_hz[zenon_Vdc]))))) \\in ?z_hp)" (is "?z_hei")
   by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vpk. ((CHOOSE zenon_Vdc:(~((zenon_Vdc \\in DOMAIN(?z_hz))=>((?z_hu[zenon_Vdc])=(?z_hz[zenon_Vdc]))))) \\in zenon_Vpk))" "?z_hp" "(\<lambda>m. (CASE ((Q[(seq[m])])~=BOT) -> (Q[(seq[m])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))))])))", OF z_Hed])
   have z_Hem: "?z_hcl((CHOOSE zenon_Vdc:(~((zenon_Vdc \\in DOMAIN(?z_hz))=>((?z_hu[zenon_Vdc])=(?z_hz[zenon_Vdc]))))))"
   by (rule zenon_all_0 [of "?z_hcl" "(CHOOSE zenon_Vdc:(~((zenon_Vdc \\in DOMAIN(?z_hz))=>((?z_hu[zenon_Vdc])=(?z_hz[zenon_Vdc])))))", OF z_Hce])
   show FALSE
   proof (rule zenon_imply [OF z_Hem])
    assume z_Hen:"(~?z_hei)"
    show FALSE
    by (rule notE [OF z_Hen z_Hei])
   next
    assume z_Hee:"?z_hee"
    show FALSE
    by (rule notE [OF z_Hef z_Hee])
   qed
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1964"; *} qed
lemma ob'1956:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
assumes v'285: "((((((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))) = ((Concat ((fapply ((a_ca), (''sigma''))), ([ m \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]), (m)))))])))))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q))))))))) \<Rightarrow> (((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))) \<in> ((a_Mhash_primea :: c))))))"
assumes v'286: "(((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))) = ((Concat ((fapply ((a_ca), (''sigma''))), ([ m \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]), (m)))))]))))))"
assumes v'287: "(\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q))))))))"
shows "(((((''sigma'' :> ((Concat ((fapply ((a_ca), (''sigma''))), ([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))) \<in> ((a_Mhash_primea :: c))))"(is "PROP ?ob'1956")
proof -
ML_command {* writeln "*** TLAPS ENTER 1956"; *}
show "PROP ?ob'1956"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_2382b4.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_2382b4.znn.out
;; obligation #1956
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'285" (=> (/\ (= (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")
(Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((m) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))))))) m))))))
(TLA.bAll ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) (= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
ACK) (= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))))
(TLA.in (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q)))))
a_Mhash_primea))
$hyp "v'286" (= (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")
(Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((m) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z)))))))) m))))))
$hyp "v'287" (TLA.bAll ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) (= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
ACK) (= (TLA.fapply (TLA.fapply (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q)))))
$goal (TLA.in (TLA.record "sigma" (Concat (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q)))))
a_Mhash_primea)
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hk:"(((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma''])=Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))&bAll(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[q])=ACK), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[q])=((a_ca[''fres''])[q]))))))=>((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q])))))) \\in a_Mhash_primea))" (is "?z_ho=>?z_hdd")
 using v'285 by blast
 have z_Hm:"bAll(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[q])=ACK), ((((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''fres''])[q])=((a_ca[''fres''])[q])))))" (is "?z_hm")
 using v'287 by blast
 have z_Hl:"(((''sigma'' :> (Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma''])=Concat((a_ca[''sigma'']), Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))" (is "?z_hp=?z_hs")
 using v'286 by blast
 assume z_Hn:"(~?z_hdd)"
 show FALSE
 proof (rule zenon_imply [OF z_Hk])
  assume z_Hdf:"(~?z_ho)" (is "~(?z_hl&_)")
  show FALSE
  proof (rule zenon_notand [OF z_Hdf])
   assume z_Hdg:"(?z_hp~=?z_hs)"
   show FALSE
   by (rule notE [OF z_Hdg z_Hl])
  next
   assume z_Hdh:"(~?z_hm)"
   show FALSE
   by (rule notE [OF z_Hdh z_Hm])
  qed
 next
  assume z_Hdd:"?z_hdd"
  show FALSE
  by (rule notE [OF z_Hn z_Hdd])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 1956"; *} qed
lemma ob'2047:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN ([ m \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (m))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (m)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m)))))))))))))]))))"
assumes v'300: "(((fapply ((Q), (fapply ((seq), (m))))) = (BOT)))"
assumes v'305: "(((fapply (([ m_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (m_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (m_1)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m_1)))))))))))))]), (m))) = (fapply ((v), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m)))))))))))))"
assumes v'306: "(\<exists> q \<in> (ProcSet) : (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m))))))))"
shows "(\<exists> q \<in> (ProcSet) : (((((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m))))))) \<and> (((fapply (([ m_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (m_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (m_1)))))>>,(fapply ((v), (bChoice((ProcSet), %q_1. (((((fapply (((a_pchash_primea :: c)), (q_1))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q_1))) = (fapply ((seq), (m_1)))))))))))))]), (m))) = (fapply ((v), (q))))))))"(is "PROP ?ob'2047")
proof -
ML_command {* writeln "*** TLAPS ENTER 2047"; *}
show "PROP ?ob'2047"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_849062.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_849062.znn.out
;; obligation #2047
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN (TLA.Fcn (TLA.DOMAIN seq) ((m) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq m))
BOT)) (TLA.fapply Q (TLA.fapply seq m)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq m)))))))))))
$hyp "v'300" (= (TLA.fapply Q (TLA.fapply seq m))
BOT)
$hyp "v'305" (= (TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((m_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq m_1))
BOT)) (TLA.fapply Q (TLA.fapply seq m_1)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q) (TLA.fapply seq m_1))))))))) m)
(TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq m)))))))
$hyp "v'306" (TLA.bEx ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq m)))))
$goal (TLA.bEx ProcSet ((q) (/\ (/\ (= (TLA.fapply a_pchash_primea q) "E2")
(= (TLA.fapply a_ihash_primea q) (TLA.fapply seq m)))
(= (TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((m_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq m_1))
BOT)) (TLA.fapply Q (TLA.fapply seq m_1)) (TLA.fapply v (TLA.bChoice ProcSet ((q_1) (/\ (= (TLA.fapply a_pchash_primea q_1)
"E2") (= (TLA.fapply a_ihash_primea q_1) (TLA.fapply seq m_1))))))))) m)
(TLA.fapply v q)))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hl:"((Q[(seq[m])])=BOT)" (is "?z_hp=_")
 using v'300 by blast
 have z_Hn:"bEx(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))))" (is "?z_hn")
 using v'306 by blast
 have z_Hk:"(m \\in DOMAIN(Fcn(DOMAIN(seq), (\<lambda>m. (CASE ((Q[(seq[m])])~=BOT) -> (Q[(seq[m])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))))]))))))" (is "?z_hk")
 using m_in by blast
 have z_Hm:"((Fcn(DOMAIN(seq), (\<lambda>m. (CASE ((Q[(seq[m])])~=BOT) -> (Q[(seq[m])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))))]))))[m])=(v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))))]))" (is "?z_hbp=?z_hbm")
 using v'305 by blast
 have zenon_L1_: "(?z_hp=BOT) ==> (?z_hp~=BOT) ==> FALSE" (is "?z_hl ==> ?z_hbl ==> FALSE")
 proof -
  assume z_Hl:"?z_hl"
  assume z_Hbl:"?z_hbl"
  show FALSE
  by (rule notE [OF z_Hbl z_Hl])
 qed
 have zenon_L2_: "((~(?z_hp~=BOT))&TRUE) ==> (~(\\E x:((x \\in ProcSet)&((((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(seq[m])))&(?z_hbp=(v[x])))))) ==> ((CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(seq[m]))))) \\in ProcSet) ==> ((a_pchash_primea[(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(seq[m])))))])=''E2'') ==> ((a_ihash_primea[(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(seq[m])))))])=(seq[m])) ==> (m \\in DOMAIN(seq)) ==> FALSE" (is "?z_hbq ==> ?z_hbt ==> ?z_hcg ==> ?z_hcj ==> ?z_hcl ==> ?z_hcn ==> FALSE")
 proof -
  assume z_Hbq:"?z_hbq" (is "?z_hbr&?z_hbs")
  assume z_Hbt:"?z_hbt" (is "~(\\E x : ?z_hco(x))")
  assume z_Hcg:"?z_hcg"
  assume z_Hcj:"?z_hcj" (is "?z_hck=?z_hbc")
  assume z_Hcl:"?z_hcl" (is "?z_hcm=?z_hr")
  assume z_Hcn:"?z_hcn"
  have z_Hbr: "?z_hbr" (is "~~?z_hl")
  by (rule zenon_and_0 [OF z_Hbq])
  have z_Hl: "?z_hl"
  by (rule zenon_notnot_0 [OF z_Hbr])
  have z_Hcp: "~?z_hco((CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=?z_hbc)&((a_ihash_primea[x])=?z_hr)))))" (is "~(_&?z_hcq)")
  by (rule zenon_notex_0 [of "?z_hco" "(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=?z_hbc)&((a_ihash_primea[x])=?z_hr))))", OF z_Hbt])
  show FALSE
  proof (rule zenon_notand [OF z_Hcp])
   assume z_Hcr:"(~?z_hcg)"
   show FALSE
   by (rule notE [OF z_Hcr z_Hcg])
  next
   assume z_Hcs:"(~?z_hcq)" (is "~(?z_hct&?z_hcu)")
   show FALSE
   proof (rule zenon_notand [OF z_Hcs])
    assume z_Hcv:"(~?z_hct)"
    show FALSE
    proof (rule zenon_notand [OF z_Hcv])
     assume z_Hcw:"(?z_hck~=?z_hbc)"
     show FALSE
     by (rule notE [OF z_Hcw z_Hcj])
    next
     assume z_Hcx:"(?z_hcm~=?z_hr)"
     show FALSE
     by (rule notE [OF z_Hcx z_Hcl])
    qed
   next
    assume z_Hcy:"(?z_hbp~=(v[(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=?z_hbc)&((a_ihash_primea[x])=?z_hr))))]))" (is "_~=?z_hcz")
    show FALSE
    proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vlc. (zenon_Vlc~=?z_hcz))" "DOMAIN(seq)" "(\<lambda>m. (CASE ((Q[(seq[m])])~=BOT) -> (Q[(seq[m])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=?z_hbc)&((a_ihash_primea[q])=(seq[m])))))])))" "m", OF z_Hcy])
     assume z_Hdd:"(~?z_hcn)"
     show FALSE
     by (rule notE [OF z_Hdd z_Hcn])
    next
     assume z_Hde:"((CASE (?z_hp~=BOT) -> ?z_hp [] OTHER -> ?z_hbm)~=?z_hcz)" (is "?z_hbk~=_")
     show FALSE
     proof (rule zenon_caseother1 [of "(\<lambda>zenon_Vlc. (zenon_Vlc~=?z_hcz))", OF z_Hde])
      assume z_Hbl:"(?z_hp~=BOT)"
      assume z_Hdf:"(?z_hp~=?z_hcz)"
      show FALSE
      by (rule notE [OF z_Hbl z_Hl])
     next
      assume z_Hbq:"?z_hbq"
      assume z_Hdg:"(?z_hbm~=?z_hcz)"
      have z_Hdh_z_Hdg: "(?z_hcz~=?z_hcz) == (?z_hbm~=?z_hcz)" (is "?z_hdh == ?z_hdg")
      by (unfold bChoose_def)
      have z_Hdh: "?z_hdh"
      by (unfold z_Hdh_z_Hdg, fact z_Hdg)
      show FALSE
      by (rule zenon_noteq [OF z_Hdh])
     qed
    qed
   qed
  qed
 qed
 assume z_Ho:"(~bEx(ProcSet, (\<lambda>q. ((((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))&(?z_hbp=(v[q]))))))" (is "~?z_hdi")
 have z_Hdn_z_Hn: "(\\E x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(seq[m]))))) == ?z_hn" (is "?z_hdn == _")
 by (unfold bEx_def)
 have z_Hdn: "?z_hdn" (is "\\E x : ?z_hdo(x)")
 by (unfold z_Hdn_z_Hn, fact z_Hn)
 have z_Hdp: "?z_hdo((CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(seq[m]))))))" (is "?z_hcg&?z_hct")
 by (rule zenon_ex_choose_0 [of "?z_hdo", OF z_Hdn])
 have z_Hcg: "?z_hcg"
 by (rule zenon_and_0 [OF z_Hdp])
 have z_Hct: "?z_hct" (is "?z_hcj&?z_hcl")
 by (rule zenon_and_1 [OF z_Hdp])
 have z_Hcj: "?z_hcj" (is "?z_hck=?z_hbc")
 by (rule zenon_and_0 [OF z_Hct])
 have z_Hcl: "?z_hcl" (is "?z_hcm=?z_hr")
 by (rule zenon_and_1 [OF z_Hct])
 have z_Hbt_z_Ho: "(~(\\E x:((x \\in ProcSet)&((((a_pchash_primea[x])=?z_hbc)&((a_ihash_primea[x])=?z_hr))&(?z_hbp=(v[x])))))) == (~?z_hdi)" (is "?z_hbt == ?z_ho")
 by (unfold bEx_def)
 have z_Hbt: "?z_hbt" (is "~(\\E x : ?z_hco(x))")
 by (unfold z_Hbt_z_Ho, fact z_Ho)
 have z_Hcn: "(m \\in DOMAIN(seq))" (is "?z_hcn")
 by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vj. (m \\in zenon_Vj))" "DOMAIN(seq)" "(\<lambda>m. (CASE ((Q[(seq[m])])~=BOT) -> (Q[(seq[m])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=?z_hbc)&((a_ihash_primea[q])=(seq[m])))))])))", OF z_Hk])
 show FALSE
 proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vh. (zenon_Vh=?z_hbm))" "DOMAIN(seq)" "(\<lambda>m. (CASE ((Q[(seq[m])])~=BOT) -> (Q[(seq[m])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=?z_hbc)&((a_ihash_primea[q])=(seq[m])))))])))" "m", OF z_Hm])
  assume z_Hdd:"(~?z_hcn)"
  show FALSE
  by (rule notE [OF z_Hdd z_Hcn])
 next
  assume z_Hdw:"((CASE (?z_hp~=BOT) -> ?z_hp [] OTHER -> ?z_hbm)=?z_hbm)" (is "?z_hbk=_")
  show FALSE
  proof (rule zenon_caseother1 [of "(\<lambda>zenon_Vh. (zenon_Vh=?z_hbm))", OF z_Hdw])
   assume z_Hbl:"(?z_hp~=BOT)"
   assume z_Hdx:"(?z_hp=?z_hbm)"
   show FALSE
   by (rule notE [OF z_Hbl z_Hl])
  next
   assume z_Hbq:"((~(?z_hp~=BOT))&TRUE)" (is "?z_hbr&?z_hbs")
   assume z_Hdy:"(?z_hbm=?z_hbm)"
   show FALSE
   by (rule zenon_L2_ [OF z_Hbq z_Hbt z_Hcg z_Hcj z_Hcl z_Hcn])
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2047"; *} qed
lemma ob'2003:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
assumes v'293: "((\<And> m :: c. m \<in> ((DOMAIN ([ m \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (m))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (m)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m)))))))))))))]))) \<Longrightarrow> (((fapply (([ m_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (m_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (m_1)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m_1)))))))))))))]), (m))) \<in> (((Nat) \\ ({((0))})))))))"
shows "(\<forall> m \<in> ((DOMAIN ([ m \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (m))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (m)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m)))))))))))))]))) : (((fapply (([ m_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (m_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (m_1)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m_1)))))))))))))]), (m))) \<in> (((Nat) \\ ({((0))}))))))"(is "PROP ?ob'2003")
proof -
ML_command {* writeln "*** TLAPS ENTER 2003"; *}
show "PROP ?ob'2003"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_7da154.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_7da154.znn.out
;; obligation #2003
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "v'293" (TLA.bAll (TLA.DOMAIN (TLA.Fcn (TLA.DOMAIN seq) ((m) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq m))
BOT)) (TLA.fapply Q (TLA.fapply seq m)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq m)))))))))) ((m) (TLA.in (TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((m_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq m_1))
BOT)) (TLA.fapply Q (TLA.fapply seq m_1)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q) (TLA.fapply seq m_1))))))))) m)
(TLA.setminus arith.N
(TLA.set 0)))))
$goal (TLA.bAll (TLA.DOMAIN (TLA.Fcn (TLA.DOMAIN seq) ((m) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq m))
BOT)) (TLA.fapply Q (TLA.fapply seq m)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq m)))))))))) ((m) (TLA.in (TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((m_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq m_1))
BOT)) (TLA.fapply Q (TLA.fapply seq m_1)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q) (TLA.fapply seq m_1))))))))) m)
(TLA.setminus arith.N
(TLA.set 0)))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hk:"bAll(DOMAIN(Fcn(DOMAIN(seq), (\<lambda>m. (CASE ((Q[(seq[m])])~=BOT) -> (Q[(seq[m])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))))]))))), (\<lambda>m. ((Fcn(DOMAIN(seq), (\<lambda>m. (CASE ((Q[(seq[m])])~=BOT) -> (Q[(seq[m])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))))]))))[m]) \\in (Nat \\ {0}))))" (is "?z_hk")
 using v'293 by blast
 assume z_Hl:"(~?z_hk)"
 show FALSE
 by (rule notE [OF z_Hl z_Hk])
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2003"; *} qed
lemma ob'2084:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'305: "(((fapply ((d), (''sigma''))) \<in> ([((DOMAIN (seq))) \<rightarrow> (((Nat) \\ ({((0))})))])))"
assumes v'306: "(((fapply ((d), (''sigma''))) = ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))))))))  \<mapsto> (cond(((leq ((z), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))), (fapply ((fapply ((a_ca), (''sigma''))), (z))), (fapply (([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]), ((arith_add ((z), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))])))"
shows "((((~ ((leq ((m), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))))) \<Rightarrow> (((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]), ((arith_add ((m), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))))"(is "PROP ?ob'2084")
proof -
ML_command {* writeln "*** TLAPS ENTER 2084"; *}
show "PROP ?ob'2084"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_1ee2e3.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_1ee2e3.znn.out
;; obligation #2084
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$hyp "v'305" (TLA.in (TLA.fapply d "sigma")
(TLA.FuncSet (TLA.DOMAIN seq) (TLA.setminus arith.N
(TLA.set 0))))
$hyp "v'306" (= (TLA.fapply d "sigma")
(TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))))) ((z) (TLA.cond (arith.le z
(a_Lena (TLA.fapply a_ca "sigma"))) (TLA.fapply (TLA.fapply a_ca "sigma") z) (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1)))) (arith.add z
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))))))
$goal (=> (-. (arith.le m (a_Lena (TLA.fapply a_ca "sigma"))))
(= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) (arith.add m
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hm:"((d[''sigma''])=Fcn(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (\<lambda>z. cond((z <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[z]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(z +  -.(a_Lena((a_ca[''sigma'']))))])))))" (is "?z_ho=?z_hr")
 using v'306 by blast
 have z_Hk:"(m \\in DOMAIN(seq))" (is "?z_hk")
 using m_in by blast
 have z_Hl:"(?z_ho \\in FuncSet(DOMAIN(seq), (Nat \\ {0})))" (is "?z_hl")
 using v'305 by blast
 assume z_Hn:"(~((~(m <= a_Lena((a_ca[''sigma'']))))=>((?z_ho[m])=(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(m +  -.(a_Lena((a_ca[''sigma'']))))]))))" (is "~(?z_hde=>?z_hdg)")
 have z_Hde: "?z_hde" (is "~?z_hdf")
 by (rule zenon_notimply_0 [OF z_Hn])
 have z_Hdk: "((?z_ho[m])~=(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(m +  -.(a_Lena((a_ca[''sigma'']))))]))" (is "?z_hdh~=?z_hdi")
 by (rule zenon_notimply_1 [OF z_Hn])
 have z_Hdl: "(DOMAIN(?z_ho)=DOMAIN(seq))" (is "?z_hdm=?z_hcx")
 by (rule zenon_in_funcset_1 [of "?z_ho" "?z_hcx" "(Nat \\ {0})", OF z_Hl])
 have z_Hdn: "(((isAFcn(?z_ho)<=>isAFcn(?z_hr))&(?z_hdm=DOMAIN(?z_hr)))&(\\A zenon_Vh:((?z_ho[zenon_Vh])=(?z_hr[zenon_Vh]))))" (is "?z_hdo&?z_hdu")
 by (rule zenon_funequal_0 [of "?z_ho" "?z_hr", OF z_Hm])
 have z_Hdu: "?z_hdu" (is "\\A x : ?z_hdz(x)")
 by (rule zenon_and_1 [OF z_Hdn])
 have z_Hea: "(\\A zenon_Vcb:((zenon_Vcb \\in ?z_hdm)<=>(zenon_Vcb \\in ?z_hcx)))" (is "\\A x : ?z_hef(x)")
 by (rule zenon_setequal_0 [of "?z_hdm" "?z_hcx", OF z_Hdl])
 have z_Heg: "?z_hdz(m)" (is "_=?z_heh")
 by (rule zenon_all_0 [of "?z_hdz" "m", OF z_Hdu])
 show FALSE
 proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vom. (?z_hdh=zenon_Vom))" "isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))))" "(\<lambda>z. cond((z <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[z]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(z +  -.(a_Lena((a_ca[''sigma'']))))])))" "m", OF z_Heg])
  assume z_Hel:"(~(m \\in isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))))))" (is "~?z_hem")
  have z_Hen: "?z_hef(m)" (is "?z_heo<=>_")
  by (rule zenon_all_0 [of "?z_hef" "m", OF z_Hea])
  show FALSE
  proof (rule zenon_equiv [OF z_Hen])
   assume z_Hep:"(~?z_heo)"
   assume z_Heq:"(~?z_hk)"
   show FALSE
   by (rule notE [OF z_Heq z_Hk])
  next
   assume z_Heo:"?z_heo"
   assume z_Hk:"?z_hk"
   have z_Her: "(m \\in DOMAIN(?z_hr))" (is "?z_her")
   by (rule subst [where P="(\<lambda>zenon_Vgo. (m \\in DOMAIN(zenon_Vgo)))", OF z_Hm z_Heo])
   have z_Hem: "?z_hem"
   by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vfo. (m \\in zenon_Vfo))" "isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])]))))))" "(\<lambda>z. cond((z <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[z]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(z +  -.(a_Lena((a_ca[''sigma'']))))])))", OF z_Her])
   show FALSE
   by (rule notE [OF z_Hel z_Hem])
  qed
 next
  assume z_Hez:"(?z_hdh=cond(?z_hdf, ((a_ca[''sigma''])[m]), ?z_hdi))" (is "_=?z_hfa")
  show FALSE
  proof (rule zenon_ifthenelse [of "(\<lambda>zenon_Vom. (?z_hdh=zenon_Vom))" "?z_hdf" "((a_ca[''sigma''])[m])" "?z_hdi", OF z_Hez])
   assume z_Hdf:"?z_hdf"
   assume z_Hfc:"(?z_hdh=((a_ca[''sigma''])[m]))" (is "_=?z_hfb")
   show FALSE
   by (rule notE [OF z_Hde z_Hdf])
  next
   assume z_Hde:"?z_hde"
   assume z_Hdg:"?z_hdg"
   show FALSE
   by (rule notE [OF z_Hdk z_Hdg])
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2084"; *} qed
lemma ob'2082:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'235: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'236: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'244: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
shows "(((fapply ((((''sigma'' :> ([ k_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))))))))  \<mapsto> (cond(((leq ((k_1), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))), (fapply ((fapply ((a_ca), (''sigma''))), (k_1))), (fapply (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]), ((arith_add ((k_1), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))])) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))) = ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))))))))  \<mapsto> (cond(((leq ((z), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))), (fapply ((fapply ((a_ca), (''sigma''))), (z))), (fapply (([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]), ((arith_add ((z), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))])))"(is "PROP ?ob'2082")
proof -
ML_command {* writeln "*** TLAPS ENTER 2082"; *}
show "PROP ?ob'2082"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_9ec176.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_9ec176.znn.out
;; obligation #2082
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'235" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'236" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'244" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$goal (= (TLA.fapply (TLA.record "sigma" (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))))) ((k_1) (TLA.cond (arith.le k_1
(a_Lena (TLA.fapply a_ca "sigma"))) (TLA.fapply (TLA.fapply a_ca "sigma") k_1) (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) (arith.add k_1
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")
(TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))))) ((z) (TLA.cond (arith.le z
(a_Lena (TLA.fapply a_ca "sigma"))) (TLA.fapply (TLA.fapply a_ca "sigma") z) (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1)))) (arith.add z
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 assume z_Hl:"(((''sigma'' :> (Fcn(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (\<lambda>k_1. cond((k_1 <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[k_1]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(k_1 +  -.(a_Lena((a_ca[''sigma'']))))]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma''])~=Fcn(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (\<lambda>k_1. cond((k_1 <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[k_1]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(k_1 +  -.(a_Lena((a_ca[''sigma'']))))])))))" (is "?z_hm~=?z_hp")
 have z_Hdg: "((''sigma'' \\in DOMAIN((''sigma'' :> (?z_hp) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))))&(?z_hm=?z_hp))" (is "?z_hdh&?z_hdj")
 by ((rule zenon_recfield_1)+, rule zenon_recfield_2b)
 have z_Hdj: "?z_hdj"
 by (rule conjD2 [OF z_Hdg])
 have z_Hdk: "(?z_hp~=?z_hp)"
 by (rule subst [where P="(\<lambda>zenon_Vf. (zenon_Vf~=?z_hp))", OF z_Hdj z_Hl])
 show FALSE
 by (rule zenon_noteq [OF z_Hdk])
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2082"; *} qed
lemma ob'2058:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'235: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'236: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'244: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'296: "((((((fapply ((((''sigma'' :> ([ k_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))))))))  \<mapsto> (cond(((leq ((k_1), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))), (fapply ((fapply ((a_ca), (''sigma''))), (k_1))), (fapply (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]), ((arith_add ((k_1), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))])) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))) = ([ k_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ m_1 \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]), (m_1)))))]))))))))))  \<mapsto> (cond(((leq ((k_1), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))), (fapply ((fapply ((a_ca), (''sigma''))), (k_1))), (fapply (([ m_1 \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]), (m_1)))))]), ((arith_add ((k_1), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))]))) & (\<forall> q \<in> (ProcSet) : (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (((fapply ((fapply ((((''sigma'' :> ([ k_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))))))))  \<mapsto> (cond(((leq ((k_1), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))), (fapply ((fapply ((a_ca), (''sigma''))), (k_1))), (fapply (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]), ((arith_add ((k_1), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))])) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (ACK))), (((fapply ((fapply ((((''sigma'' :> ([ k_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))))))))  \<mapsto> (cond(((leq ((k_1), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))), (fapply ((fapply ((a_ca), (''sigma''))), (k_1))), (fapply (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]), ((arith_add ((k_1), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))])) @@ (''fres'' :> ([ q_1 \<in> (ProcSet)  \<mapsto> (cond((((q_1) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q_1)))))])))), (''fres''))), (q))) = (fapply ((fapply ((a_ca), (''fres''))), (q))))))))) \<Rightarrow> (((((''sigma'' :> ([ k_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))))))))  \<mapsto> (cond(((leq ((k_1), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))), (fapply ((fapply ((a_ca), (''sigma''))), (k_1))), (fapply (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]), ((arith_add ((k_1), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))])) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))) \<in> ((a_Mhash_primea :: c))))))"
shows "(((fapply ((((''sigma'' :> ([ k_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))))))))  \<mapsto> (cond(((leq ((k_1), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))), (fapply ((fapply ((a_ca), (''sigma''))), (k_1))), (fapply (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]), ((arith_add ((k_1), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))])) @@ (''fres'' :> ([ q \<in> (ProcSet)  \<mapsto> (cond((((q) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))), (ACK), (fapply ((fapply ((a_ca), (''fres''))), (q)))))])))), (''sigma''))) = ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Lena ((fapply ((a_ca), (''sigma'')))))), ((a_Lena (([ z \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))]))))))))))  \<mapsto> (cond(((leq ((z), ((a_Lena ((fapply ((a_ca), (''sigma''))))))))), (fapply ((fapply ((a_ca), (''sigma''))), (z))), (fapply (([ z_1 \<in> ((DOMAIN ([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))])))  \<mapsto> (fapply ((v), (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_3 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_3), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_2)))))))))))]), (z_1)))))]), ((arith_add ((z), ((minus (((a_Lena ((fapply ((a_ca), (''sigma''))))))))))))))))])))"(is "PROP ?ob'2058")
proof -
ML_command {* writeln "*** TLAPS ENTER 2058"; *}
show "PROP ?ob'2058"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_a2ce40.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_a2ce40.znn.out
;; obligation #2058
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'235" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'236" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'244" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$hyp "v'296" (=> (/\ (= (TLA.fapply (TLA.record "sigma" (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))))) ((k_1) (TLA.cond (arith.le k_1
(a_Lena (TLA.fapply a_ca "sigma"))) (TLA.fapply (TLA.fapply a_ca "sigma") k_1) (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) (arith.add k_1
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")
(TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((m_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z)))))))) m_1))))))) ((k_1) (TLA.cond (arith.le k_1
(a_Lena (TLA.fapply a_ca "sigma"))) (TLA.fapply (TLA.fapply a_ca "sigma") k_1) (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((m_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z)))))))) m_1)))) (arith.add k_1
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))))))
(TLA.bAll ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) (= (TLA.fapply (TLA.fapply (TLA.record "sigma" (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))))) ((k_1) (TLA.cond (arith.le k_1
(a_Lena (TLA.fapply a_ca "sigma"))) (TLA.fapply (TLA.fapply a_ca "sigma") k_1) (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) (arith.add k_1
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
ACK) (= (TLA.fapply (TLA.fapply (TLA.record "sigma" (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))))) ((k_1) (TLA.cond (arith.le k_1
(a_Lena (TLA.fapply a_ca "sigma"))) (TLA.fapply (TLA.fapply a_ca "sigma") k_1) (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) (arith.add k_1
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))))) "fres" (TLA.Fcn ProcSet ((q_1) (TLA.cond (TLA.in q_1
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q_1))))) "fres") q)
(TLA.fapply (TLA.fapply a_ca "fres") q))))))
(TLA.in (TLA.record "sigma" (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))))) ((k_1) (TLA.cond (arith.le k_1
(a_Lena (TLA.fapply a_ca "sigma"))) (TLA.fapply (TLA.fapply a_ca "sigma") k_1) (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) (arith.add k_1
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q)))))
a_Mhash_primea))
$goal (= (TLA.fapply (TLA.record "sigma" (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))))) ((k_1) (TLA.cond (arith.le k_1
(a_Lena (TLA.fapply a_ca "sigma"))) (TLA.fapply (TLA.fapply a_ca "sigma") k_1) (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) (arith.add k_1
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))))) "fres" (TLA.Fcn ProcSet ((q) (TLA.cond (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))) ACK (TLA.fapply (TLA.fapply a_ca "fres") q))))) "sigma")
(TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (a_Lena (TLA.fapply a_ca "sigma"))
(a_Lena (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))))) ((z) (TLA.cond (arith.le z
(a_Lena (TLA.fapply a_ca "sigma"))) (TLA.fapply (TLA.fapply a_ca "sigma") z) (TLA.fapply (TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1))))))))) ((z_1) (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_3) (TLA.fapply seq (arith.add z_3
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_2)))))))) z_1)))) (arith.add z
(arith.minus (a_Lena (TLA.fapply a_ca "sigma")))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 assume z_Hm:"(((''sigma'' :> (Fcn(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (\<lambda>k_1. cond((k_1 <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[k_1]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(k_1 +  -.(a_Lena((a_ca[''sigma'']))))]))))) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))[''sigma''])~=Fcn(isa'dotdot(1, (a_Lena((a_ca[''sigma''])) + a_Lena(Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))))), (\<lambda>k_1. cond((k_1 <= a_Lena((a_ca[''sigma'']))), ((a_ca[''sigma''])[k_1]), (Fcn(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])])))[(k_1 +  -.(a_Lena((a_ca[''sigma'']))))])))))" (is "?z_hn~=?z_hq")
 have z_Hdh: "((''sigma'' \\in DOMAIN((''sigma'' :> (?z_hq) @@ ''fres'' :> (Fcn(ProcSet, (\<lambda>q. cond((q \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))), ACK, ((a_ca[''fres''])[q]))))))))&(?z_hn=?z_hq))" (is "?z_hdi&?z_hdk")
 by ((rule zenon_recfield_1)+, rule zenon_recfield_2b)
 have z_Hdk: "?z_hdk"
 by (rule conjD2 [OF z_Hdh])
 have z_Hdl: "(?z_hq~=?z_hq)"
 by (rule subst [where P="(\<lambda>zenon_Vf. (zenon_Vf~=?z_hq))", OF z_Hdk z_Hm])
 show FALSE
 by (rule zenon_noteq [OF z_Hdl])
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2058"; *} qed
lemma ob'2124:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'310: "((less ((m), (k))))"
assumes v'311: "(((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((fapply ((a_ca), (''sigma''))), (m)))))"
assumes v'324: "(((m) \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0])))))))))))))"
shows "(((m) \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0])))))))))))  \<mapsto> (fapply ((seq), (z)))])))))"(is "PROP ?ob'2124")
proof -
ML_command {* writeln "*** TLAPS ENTER 2124"; *}
show "PROP ?ob'2124"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_9c1007.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_9c1007.znn.out
;; obligation #2124
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$hyp "v'310" (arith.lt m
k)
$hyp "v'311" (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply (TLA.fapply a_ca "sigma") m))
$hyp "v'324" (TLA.in m (arith.intrange (TLA.fapply TLA.Succ 0) (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))
$goal (TLA.in m (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z)))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hn:"(m \\in isa'dotdot(1, (k +  -.(1))))" (is "?z_hn")
 using v'324 by blast
 assume z_Ho:"(~(m \\in DOMAIN(Fcn(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))))))" (is "~?z_hv")
 have z_Hbc: "(~?z_hn)"
 by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vg. (~(m \\in zenon_Vg)))" "isa'dotdot(1, (k +  -.(1)))" "(\<lambda>z. (seq[z]))", OF z_Ho])
 show FALSE
 by (rule notE [OF z_Hbc z_Hn])
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2124"; *} qed
lemma ob'2117:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'310: "((less ((m), (k))))"
assumes v'311: "(((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((fapply ((a_ca), (''sigma''))), (m)))))"
assumes v'322: "((((DOMAIN (seq))) = ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A)))))))))"
assumes v'323: "(((fapply ((Q), (fapply ((seq), (m))))) \<noteq> (BOT)))"
shows "(((m) \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A)))))))))"(is "PROP ?ob'2117")
proof -
ML_command {* writeln "*** TLAPS ENTER 2117"; *}
show "PROP ?ob'2117"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_df1212.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_df1212.znn.out
;; obligation #2117
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$hyp "v'310" (arith.lt m
k)
$hyp "v'311" (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply (TLA.fapply a_ca "sigma") m))
$hyp "v'322" (= (TLA.DOMAIN seq) (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "v'323" (-. (= (TLA.fapply Q (TLA.fapply seq m)) BOT))
$goal (TLA.in m (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hk:"(m \\in DOMAIN(seq))" (is "?z_hk")
 using m_in by blast
 have z_Hn:"(DOMAIN(seq)=isa'dotdot(1, Cardinality(A)))" (is "?z_hr=?z_ht")
 using v'322 by blast
 assume z_Hp:"(~(m \\in ?z_ht))" (is "~?z_hx")
 show FALSE
 proof (rule notE [OF z_Hp])
  have z_Hx: "?z_hx"
  by (rule subst [where P="(\<lambda>zenon_Vo. (m \\in zenon_Vo))", OF z_Hn], fact z_Hk)
  thus "?z_hx" .
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2117"; *} qed
lemma ob'2113:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'235: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'236: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'244: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'309: "((less ((m), (k))))"
assumes v'310: "(((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((fapply ((a_ca), (''sigma''))), (m)))))"
assumes v'320: "((GoodRes ((setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z))))), (fapply ((a_ca), (''fres''))))))"
assumes v'321: "(((fapply ((a_ca), (''sigma''))) = ([ k_1 \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0])))))))))))  \<mapsto> (fapply ((seq), (z)))])))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0])))))))))))  \<mapsto> (fapply ((seq), (z)))]), (k_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0])))))))))))  \<mapsto> (fapply ((seq), (z)))]), (k_1)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply ((pc), (q))) = (''E2''))) \<and> (((fapply ((i), (q))) = (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0])))))))))))  \<mapsto> (fapply ((seq), (z)))]), (k_1)))))))))))))])))"
assumes v'322: "(((fapply ((Q), (fapply ((seq), (m))))) \<noteq> (BOT)))"
shows "(((((m) \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0])))))))))))  \<mapsto> (fapply ((seq), (z)))]))))) \<Rightarrow> (((fapply ((fapply ((a_ca), (''sigma''))), (m))) = (fapply ((Q), (fapply ((seq), (m)))))))))"(is "PROP ?ob'2113")
proof -
ML_command {* writeln "*** TLAPS ENTER 2113"; *}
show "PROP ?ob'2113"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_f9dffd.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_f9dffd.znn.out
;; obligation #2113
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'235" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'236" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'244" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$hyp "v'309" (arith.lt m
k)
$hyp "v'310" (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply (TLA.fapply a_ca "sigma") m))
$hyp "v'320" (GoodRes (TLA.setOfAll (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z)))
(TLA.fapply a_ca "fres"))
$hyp "v'321" (= (TLA.fapply a_ca "sigma")
(TLA.Fcn (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z)))) ((k_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z))) k_1))
BOT)) (TLA.fapply Q (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z))) k_1)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply pc q)
"E2") (= (TLA.fapply i q)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0) (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z))) k_1))))))))))
$hyp "v'322" (-. (= (TLA.fapply Q (TLA.fapply seq m))
BOT))
$goal (=> (TLA.in m
(TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0) (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z)))))
(= (TLA.fapply (TLA.fapply a_ca "sigma") m)
(TLA.fapply Q (TLA.fapply seq m))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Ho:"((a_ca[''sigma''])=Fcn(DOMAIN(Fcn(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z])))), (\<lambda>k_1. (CASE ((Q[(Fcn(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z])))[k_1])])~=BOT) -> (Q[(Fcn(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z])))[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((pc[q])=''E2'')&((i[q])=(Fcn(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z])))[k_1])))))])))))" (is "?z_hr=?z_hu")
 using v'321 by blast
 have z_Hp:"((Q[(seq[m])])~=BOT)" (is "?z_hcc~=_")
 using v'322 by blast
 assume z_Hq:"(~((m \\in DOMAIN(Fcn(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z])))))=>((?z_hr[m])=?z_hcc)))" (is "~(?z_hcg=>?z_hch)")
 have z_Hcg: "?z_hcg"
 by (rule zenon_notimply_0 [OF z_Hq])
 have z_Hcj: "((?z_hr[m])~=?z_hcc)" (is "?z_hci~=_")
 by (rule zenon_notimply_1 [OF z_Hq])
 have z_Hck: "(m \\in isa'dotdot(1, (k +  -.(1))))" (is "?z_hck")
 by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vn. (m \\in zenon_Vn))" "isa'dotdot(1, (k +  -.(1)))" "(\<lambda>z. (seq[z]))", OF z_Hcg])
 have z_Hco: "(((isAFcn(?z_hr)<=>isAFcn(?z_hu))&(DOMAIN(?z_hr)=DOMAIN(?z_hu)))&(\\A zenon_Vi:((?z_hr[zenon_Vi])=(?z_hu[zenon_Vi]))))" (is "?z_hcp&?z_hcw")
 by (rule zenon_funequal_0 [of "?z_hr" "?z_hu", OF z_Ho])
 have z_Hcw: "?z_hcw" (is "\\A x : ?z_hdb(x)")
 by (rule zenon_and_1 [OF z_Hco])
 have z_Hdc: "?z_hdb(m)" (is "_=?z_hdd")
 by (rule zenon_all_0 [of "?z_hdb" "m", OF z_Hcw])
 show FALSE
 proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vbf. (?z_hci=zenon_Vbf))" "DOMAIN(Fcn(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))))" "(\<lambda>k_1. (CASE ((Q[(Fcn(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z])))[k_1])])~=BOT) -> (Q[(Fcn(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z])))[k_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((pc[q])=''E2'')&((i[q])=(Fcn(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z])))[k_1])))))])))" "m", OF z_Hdc])
  assume z_Hdh:"(~?z_hcg)"
  show FALSE
  by (rule notE [OF z_Hdh z_Hcg])
 next
  assume z_Hdi:"(?z_hci=(CASE ((Q[(Fcn(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z])))[m])])~=BOT) -> (Q[(Fcn(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z])))[m])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((pc[q])=''E2'')&((i[q])=(Fcn(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z])))[m])))))])))" (is "_=?z_hdj")
  show FALSE
  proof (rule zenon_caseother1 [of "(\<lambda>zenon_Vbf. (?z_hci=zenon_Vbf))", OF z_Hdi])
   assume z_Hdk:"((Q[(Fcn(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z])))[m])])~=BOT)" (is "?z_hdl~=_")
   assume z_Hds:"(?z_hci=?z_hdl)"
   show FALSE
   proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vmf. (?z_hci=(Q[zenon_Vmf])))" "isa'dotdot(1, (k +  -.(1)))" "(\<lambda>z. (seq[z]))" "m", OF z_Hds])
    assume z_Hdx:"(~?z_hck)"
    show FALSE
    by (rule notE [OF z_Hdx z_Hck])
   next
    assume z_Hch:"?z_hch"
    show FALSE
    by (rule notE [OF z_Hcj z_Hch])
   qed
  next
   assume z_Hdy:"((~((Q[(Fcn(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z])))[m])])~=BOT))&TRUE)" (is "?z_hdz&?z_hea")
   assume z_Heb:"(?z_hci=(v[bChoice(ProcSet, (\<lambda>q. (((pc[q])=''E2'')&((i[q])=(Fcn(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z])))[m])))))]))" (is "_=?z_hdn")
   have z_Hdz: "?z_hdz" (is "~~?z_hec")
   by (rule zenon_and_0 [OF z_Hdy])
   have z_Hec: "?z_hec" (is "?z_hdl=_")
   by (rule zenon_notnot_0 [OF z_Hdz])
   show FALSE
   proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vrc. ((Q[zenon_Vrc])=BOT))" "isa'dotdot(1, (k +  -.(1)))" "(\<lambda>z. (seq[z]))" "m", OF z_Hec])
    assume z_Hdx:"(~?z_hck)"
    show FALSE
    by (rule notE [OF z_Hdx z_Hck])
   next
    assume z_Heh:"(?z_hcc=BOT)"
    show FALSE
    by (rule notE [OF z_Hp z_Heh])
   qed
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2113"; *} qed
lemma ob'2103:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'310: "((((less ((m), (k)))) \<Longrightarrow> ((((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((fapply ((a_ca), (''sigma''))), (m))))) \<Longrightarrow> (((fapply ((fapply ((a_ca), (''sigma''))), (m))) = (fapply (([ m_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (m_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (m_1)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m_1)))))))))))))]), (m))))))))"
assumes v'312: "((((less ((m), (k)))) \<Rightarrow> (((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((fapply ((a_ca), (''sigma''))), (m)))))))"
assumes v'313: "((less ((m), (k))))"
shows "(((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply (([ m_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (m_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (m_1)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m_1)))))))))))))]), (m)))))"(is "PROP ?ob'2103")
proof -
ML_command {* writeln "*** TLAPS ENTER 2103"; *}
show "PROP ?ob'2103"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_3491b6.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_3491b6.znn.out
;; obligation #2103
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$hyp "v'310" (=> (arith.lt m k) (=> (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply (TLA.fapply a_ca "sigma") m)) (= (TLA.fapply (TLA.fapply a_ca "sigma") m)
(TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((m_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq m_1))
BOT)) (TLA.fapply Q (TLA.fapply seq m_1)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq m_1))))))))) m))))
$hyp "v'312" (=> (arith.lt m k) (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply (TLA.fapply a_ca "sigma") m)))
$hyp "v'313" (arith.lt m k)
$goal (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((m_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq m_1))
BOT)) (TLA.fapply Q (TLA.fapply seq m_1)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq m_1))))))))) m))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hl:"((m < k)=>((((d[''sigma''])[m])=((a_ca[''sigma''])[m]))=>(((a_ca[''sigma''])[m])=(Fcn(DOMAIN(seq), (\<lambda>m_1. (CASE ((Q[(seq[m_1])])~=BOT) -> (Q[(seq[m_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m_1])))))]))))[m]))))" (is "?z_hn=>?z_hr")
 using v'310 by blast
 have z_Hm:"(?z_hn=>(((d[''sigma''])[m])=((a_ca[''sigma''])[m])))" (is "_=>?z_hs")
 using v'312 by blast
 have z_Hn:"?z_hn"
 using v'313 by blast
 assume z_Ho:"(((d[''sigma''])[m])~=(Fcn(DOMAIN(seq), (\<lambda>m_1. (CASE ((Q[(seq[m_1])])~=BOT) -> (Q[(seq[m_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m_1])))))]))))[m]))" (is "?z_ht~=?z_hbb")
 show FALSE
 proof (rule zenon_imply [OF z_Hl])
  assume z_Hcb:"(~?z_hn)"
  show FALSE
  by (rule notE [OF z_Hcb z_Hn])
 next
  assume z_Hr:"?z_hr" (is "_=>?z_hba")
  show FALSE
  proof (rule zenon_imply [OF z_Hr])
   assume z_Hcc:"(?z_ht~=((a_ca[''sigma''])[m]))" (is "_~=?z_hx")
   show FALSE
   proof (rule zenon_imply [OF z_Hm])
    assume z_Hcb:"(~?z_hn)"
    show FALSE
    by (rule notE [OF z_Hcb z_Hn])
   next
    assume z_Hs:"?z_hs"
    show FALSE
    by (rule notE [OF z_Hcc z_Hs])
   qed
  next
   assume z_Hba:"?z_hba" (is "?z_hx=_")
   show FALSE
   proof (rule zenon_imply [OF z_Hm])
    assume z_Hcb:"(~?z_hn)"
    show FALSE
    by (rule notE [OF z_Hcb z_Hn])
   next
    assume z_Hs:"?z_hs"
    show FALSE
    proof (rule notE [OF z_Ho])
     have z_Hcd: "(?z_hx=?z_ht)"
     by (rule sym [OF z_Hs])
     have z_Hce: "(?z_ht=?z_hbb)"
     by (rule subst [where P="(\<lambda>zenon_Vra. (zenon_Vra=?z_hbb))", OF z_Hcd], fact z_Hba)
     thus "(?z_ht=?z_hbb)" .
    qed
   qed
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2103"; *} qed
lemma ob'2148:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'310: "((less ((m), (k))))"
assumes v'311: "(((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((fapply ((a_ca), (''sigma''))), (m)))))"
assumes v'318: "(((fapply ((Q), (fapply ((seq), (m))))) = (BOT)))"
fixes q
assumes q_in : "(q \<in> (ProcSet))"
assumes v'329: "((((DOMAIN (seq))) = ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A)))))))))"
assumes v'330: "(((((fapply ((Q), (fapply ((seq), (m))))) \<noteq> (BOT))) \<Longrightarrow> (((fapply ((fapply ((a_ca), (''sigma''))), (m))) = (fapply (([ m_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (m_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (m_1)))))>>,(fapply ((v), (bChoice((ProcSet), %q_1. (((((fapply (((a_pchash_primea :: c)), (q_1))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q_1))) = (fapply ((seq), (m_1)))))))))))))]), (m)))))))"
shows "(((m) \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A)))))))))"(is "PROP ?ob'2148")
proof -
ML_command {* writeln "*** TLAPS ENTER 2148"; *}
show "PROP ?ob'2148"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_253690.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_253690.znn.out
;; obligation #2148
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$hyp "v'310" (arith.lt m
k)
$hyp "v'311" (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply (TLA.fapply a_ca "sigma") m))
$hyp "v'318" (= (TLA.fapply Q (TLA.fapply seq m))
BOT)
$hyp "q_in" (TLA.in q ProcSet)
$hyp "v'329" (= (TLA.DOMAIN seq) (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "v'330" (=> (-. (= (TLA.fapply Q (TLA.fapply seq m))
BOT)) (= (TLA.fapply (TLA.fapply a_ca "sigma") m)
(TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((m_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq m_1))
BOT)) (TLA.fapply Q (TLA.fapply seq m_1)) (TLA.fapply v (TLA.bChoice ProcSet ((q_1) (/\ (= (TLA.fapply a_pchash_primea q_1)
"E2") (= (TLA.fapply a_ihash_primea q_1)
(TLA.fapply seq m_1))))))))) m)))
$goal (TLA.in m (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hk:"(m \\in DOMAIN(seq))" (is "?z_hk")
 using m_in by blast
 have z_Hp:"(DOMAIN(seq)=isa'dotdot(1, Cardinality(A)))" (is "?z_ht=?z_hv")
 using v'329 by blast
 assume z_Hr:"(~(m \\in ?z_hv))" (is "~?z_hz")
 show FALSE
 proof (rule notE [OF z_Hr])
  have z_Hz: "?z_hz"
  by (rule subst [where P="(\<lambda>zenon_Vq. (m \\in zenon_Vq))", OF z_Hp], fact z_Hk)
  thus "?z_hz" .
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2148"; *} qed
lemma ob'2144:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'310: "((less ((m), (k))))"
assumes v'311: "(((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((fapply ((a_ca), (''sigma''))), (m)))))"
assumes v'318: "(((fapply ((Q), (fapply ((seq), (m))))) = (BOT)))"
assumes v'323: "(((fapply (([ m_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (m_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (m_1)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m_1)))))))))))))]), (m))) = (fapply ((v), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m)))))))))))))"
assumes v'324: "(\<exists> q \<in> (ProcSet) : (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m))))))))"
shows "(\<exists> q \<in> (ProcSet) : (((((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m))))))) \<and> (((fapply (([ m_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (m_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (m_1)))))>>,(fapply ((v), (bChoice((ProcSet), %q_1. (((((fapply (((a_pchash_primea :: c)), (q_1))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q_1))) = (fapply ((seq), (m_1)))))))))))))]), (m))) = (fapply ((v), (q))))))))"(is "PROP ?ob'2144")
proof -
ML_command {* writeln "*** TLAPS ENTER 2144"; *}
show "PROP ?ob'2144"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_bd1b66.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_bd1b66.znn.out
;; obligation #2144
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$hyp "v'310" (arith.lt m
k)
$hyp "v'311" (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply (TLA.fapply a_ca "sigma") m))
$hyp "v'318" (= (TLA.fapply Q (TLA.fapply seq m))
BOT)
$hyp "v'323" (= (TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((m_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq m_1))
BOT)) (TLA.fapply Q (TLA.fapply seq m_1)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q) (TLA.fapply seq m_1))))))))) m)
(TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq m)))))))
$hyp "v'324" (TLA.bEx ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq m)))))
$goal (TLA.bEx ProcSet ((q) (/\ (/\ (= (TLA.fapply a_pchash_primea q) "E2")
(= (TLA.fapply a_ihash_primea q) (TLA.fapply seq m)))
(= (TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((m_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq m_1))
BOT)) (TLA.fapply Q (TLA.fapply seq m_1)) (TLA.fapply v (TLA.bChoice ProcSet ((q_1) (/\ (= (TLA.fapply a_pchash_primea q_1)
"E2") (= (TLA.fapply a_ihash_primea q_1) (TLA.fapply seq m_1))))))))) m)
(TLA.fapply v q)))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hn:"((Q[(seq[m])])=BOT)" (is "?z_hr=_")
 using v'318 by blast
 have z_Hp:"bEx(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))))" (is "?z_hp")
 using v'324 by blast
 have z_Ho:"((Fcn(DOMAIN(seq), (\<lambda>m_1. (CASE ((Q[(seq[m_1])])~=BOT) -> (Q[(seq[m_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m_1])))))]))))[m])=(v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))))]))" (is "?z_hbi=?z_hbx")
 using v'323 by blast
 have z_Hk:"(m \\in DOMAIN(seq))" (is "?z_hk")
 using m_in by blast
 have zenon_L1_: "(?z_hr=BOT) ==> (?z_hr~=BOT) ==> FALSE" (is "?z_hn ==> ?z_hbz ==> FALSE")
 proof -
  assume z_Hn:"?z_hn"
  assume z_Hbz:"?z_hbz"
  show FALSE
  by (rule notE [OF z_Hbz z_Hn])
 qed
 have zenon_L2_: "((~(?z_hr~=BOT))&TRUE) ==> (~(\\E x:((x \\in ProcSet)&((((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(seq[m])))&(?z_hbi=(v[x])))))) ==> ((CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(seq[m]))))) \\in ProcSet) ==> ((a_pchash_primea[(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(seq[m])))))])=''E2'') ==> ((a_ihash_primea[(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(seq[m])))))])=(seq[m])) ==> ?z_hk ==> FALSE" (is "?z_hca ==> ?z_hcd ==> ?z_hcq ==> ?z_hct ==> ?z_hcv ==> _ ==> FALSE")
 proof -
  assume z_Hca:"?z_hca" (is "?z_hcb&?z_hcc")
  assume z_Hcd:"?z_hcd" (is "~(\\E x : ?z_hcx(x))")
  assume z_Hcq:"?z_hcq"
  assume z_Hct:"?z_hct" (is "?z_hcu=?z_hbe")
  assume z_Hcv:"?z_hcv" (is "?z_hcw=?z_ht")
  assume z_Hk:"?z_hk"
  have z_Hcb: "?z_hcb" (is "~~?z_hn")
  by (rule zenon_and_0 [OF z_Hca])
  have z_Hn: "?z_hn"
  by (rule zenon_notnot_0 [OF z_Hcb])
  have z_Hcy: "~?z_hcx((CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=?z_hbe)&((a_ihash_primea[x])=?z_ht)))))" (is "~(_&?z_hcz)")
  by (rule zenon_notex_0 [of "?z_hcx" "(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=?z_hbe)&((a_ihash_primea[x])=?z_ht))))", OF z_Hcd])
  show FALSE
  proof (rule zenon_notand [OF z_Hcy])
   assume z_Hda:"(~?z_hcq)"
   show FALSE
   by (rule notE [OF z_Hda z_Hcq])
  next
   assume z_Hdb:"(~?z_hcz)" (is "~(?z_hdc&?z_hdd)")
   show FALSE
   proof (rule zenon_notand [OF z_Hdb])
    assume z_Hde:"(~?z_hdc)"
    show FALSE
    proof (rule zenon_notand [OF z_Hde])
     assume z_Hdf:"(?z_hcu~=?z_hbe)"
     show FALSE
     by (rule notE [OF z_Hdf z_Hct])
    next
     assume z_Hdg:"(?z_hcw~=?z_ht)"
     show FALSE
     by (rule notE [OF z_Hdg z_Hcv])
    qed
   next
    assume z_Hdh:"(?z_hbi~=(v[(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=?z_hbe)&((a_ihash_primea[x])=?z_ht))))]))" (is "_~=?z_hdi")
    show FALSE
    proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vyc. (zenon_Vyc~=?z_hdi))" "DOMAIN(seq)" "(\<lambda>m_1. (CASE ((Q[(seq[m_1])])~=BOT) -> (Q[(seq[m_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=?z_hbe)&((a_ihash_primea[q])=(seq[m_1])))))])))" "m", OF z_Hdh])
     assume z_Hdm:"(~?z_hk)"
     show FALSE
     by (rule notE [OF z_Hdm z_Hk])
    next
     assume z_Hdn:"((CASE (?z_hr~=BOT) -> ?z_hr [] OTHER -> ?z_hbx)~=?z_hdi)" (is "?z_hdo~=_")
     show FALSE
     proof (rule zenon_caseother1 [of "(\<lambda>zenon_Vyc. (zenon_Vyc~=?z_hdi))", OF z_Hdn])
      assume z_Hbz:"(?z_hr~=BOT)"
      assume z_Hdp:"(?z_hr~=?z_hdi)"
      show FALSE
      by (rule notE [OF z_Hbz z_Hn])
     next
      assume z_Hca:"?z_hca"
      assume z_Hdq:"(?z_hbx~=?z_hdi)"
      have z_Hdr_z_Hdq: "(?z_hdi~=?z_hdi) == (?z_hbx~=?z_hdi)" (is "?z_hdr == ?z_hdq")
      by (unfold bChoose_def)
      have z_Hdr: "?z_hdr"
      by (unfold z_Hdr_z_Hdq, fact z_Hdq)
      show FALSE
      by (rule zenon_noteq [OF z_Hdr])
     qed
    qed
   qed
  qed
 qed
 assume z_Hq:"(~bEx(ProcSet, (\<lambda>q. ((((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))&(?z_hbi=(v[q]))))))" (is "~?z_hds")
 have z_Hdx_z_Hp: "(\\E x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(seq[m]))))) == ?z_hp" (is "?z_hdx == _")
 by (unfold bEx_def)
 have z_Hdx: "?z_hdx" (is "\\E x : ?z_hdy(x)")
 by (unfold z_Hdx_z_Hp, fact z_Hp)
 have z_Hdz: "?z_hdy((CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(seq[m]))))))" (is "?z_hcq&?z_hdc")
 by (rule zenon_ex_choose_0 [of "?z_hdy", OF z_Hdx])
 have z_Hcq: "?z_hcq"
 by (rule zenon_and_0 [OF z_Hdz])
 have z_Hdc: "?z_hdc" (is "?z_hct&?z_hcv")
 by (rule zenon_and_1 [OF z_Hdz])
 have z_Hct: "?z_hct" (is "?z_hcu=?z_hbe")
 by (rule zenon_and_0 [OF z_Hdc])
 have z_Hcv: "?z_hcv" (is "?z_hcw=?z_ht")
 by (rule zenon_and_1 [OF z_Hdc])
 have z_Hcd_z_Hq: "(~(\\E x:((x \\in ProcSet)&((((a_pchash_primea[x])=?z_hbe)&((a_ihash_primea[x])=?z_ht))&(?z_hbi=(v[x])))))) == (~?z_hds)" (is "?z_hcd == ?z_hq")
 by (unfold bEx_def)
 have z_Hcd: "?z_hcd" (is "~(\\E x : ?z_hcx(x))")
 by (unfold z_Hcd_z_Hq, fact z_Hq)
 show FALSE
 proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vh. (zenon_Vh=?z_hbx))" "DOMAIN(seq)" "(\<lambda>m_1. (CASE ((Q[(seq[m_1])])~=BOT) -> (Q[(seq[m_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=?z_hbe)&((a_ihash_primea[q])=(seq[m_1])))))])))" "m", OF z_Ho])
  assume z_Hdm:"(~?z_hk)"
  show FALSE
  by (rule notE [OF z_Hdm z_Hk])
 next
  assume z_Hed:"((CASE (?z_hr~=BOT) -> ?z_hr [] OTHER -> ?z_hbx)=?z_hbx)" (is "?z_hdo=_")
  show FALSE
  proof (rule zenon_caseother1 [of "(\<lambda>zenon_Vh. (zenon_Vh=?z_hbx))", OF z_Hed])
   assume z_Hbz:"(?z_hr~=BOT)"
   assume z_Hee:"(?z_hr=?z_hbx)"
   show FALSE
   by (rule notE [OF z_Hbz z_Hn])
  next
   assume z_Hca:"((~(?z_hr~=BOT))&TRUE)" (is "?z_hcb&?z_hcc")
   assume z_Hef:"(?z_hbx=?z_hbx)"
   show FALSE
   by (rule zenon_L2_ [OF z_Hca z_Hcd z_Hcq z_Hct z_Hcv z_Hk])
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2144"; *} qed
lemma ob'2139:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'235: "(\<forall> k \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))) : ((((((fapply (((a_Qhash_primea :: c)), (k))) \<noteq> (BOT))) \<Rightarrow> (((k) \<in> (A))))) & (((((((k) \<in> (A))) \<and> (((fapply (((a_Qhash_primea :: c)), (k))) = (BOT))))) \<Rightarrow> (\<exists> q \<in> (ProcSet) : (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (k))))))))))"
assumes v'236: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'244: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'309: "((less ((m), (k))))"
assumes v'310: "(((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((fapply ((a_ca), (''sigma''))), (m)))))"
assumes v'317: "(((fapply ((Q), (fapply ((seq), (m))))) = (BOT)))"
assumes v'325: "(((fapply ((seq), (m))) \<in> (setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z)))))))"
assumes v'326: "(\<forall> k_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0]))))))))))) : ((((((fapply ((Q), (k_1))) \<noteq> (BOT))) \<Rightarrow> (((k_1) \<in> (setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z))))))))) & (((((((k_1) \<in> (setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z))))))) \<and> (((fapply ((Q), (k_1))) = (BOT))))) \<Rightarrow> (\<exists> q \<in> (ProcSet) : (((((fapply ((pc), (q))) = (''E2''))) \<and> (((fapply ((i), (q))) = (k_1))))))))))"
assumes v'327: "(((setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z))))) \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add ((X), ((minus (((Succ[0])))))))))))))))"
shows "(\<exists> q \<in> (ProcSet) : (((((fapply ((pc), (q))) = (''E2''))) \<and> (((fapply ((i), (q))) = (fapply ((seq), (m))))))))"(is "PROP ?ob'2139")
proof -
ML_command {* writeln "*** TLAPS ENTER 2139"; *}
show "PROP ?ob'2139"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_92b8f5.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_92b8f5.znn.out
;; obligation #2139
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'235" (TLA.bAll (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0)))) ((k) (/\ (=> (-. (= (TLA.fapply a_Qhash_primea k)
BOT)) (TLA.in k A)) (=> (/\ (TLA.in k A) (= (TLA.fapply a_Qhash_primea k)
BOT)) (TLA.bEx ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q) "E2")
(= (TLA.fapply a_ihash_primea q)
k))))))))
$hyp "v'236" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'244" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$hyp "v'309" (arith.lt m
k)
$hyp "v'310" (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply (TLA.fapply a_ca "sigma") m))
$hyp "v'317" (= (TLA.fapply Q (TLA.fapply seq m))
BOT)
$hyp "v'325" (TLA.in (TLA.fapply seq m)
(TLA.setOfAll (arith.intrange (TLA.fapply TLA.Succ 0) (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z))))
$hyp "v'326" (TLA.bAll (arith.intrange (TLA.fapply TLA.Succ 0) (arith.add X
(arith.minus (TLA.fapply TLA.Succ 0)))) ((k_1) (/\ (=> (-. (= (TLA.fapply Q k_1)
BOT)) (TLA.in k_1 (TLA.setOfAll (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z)))))
(=> (/\ (TLA.in k_1 (TLA.setOfAll (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z))))
(= (TLA.fapply Q k_1) BOT)) (TLA.bEx ProcSet ((q) (/\ (= (TLA.fapply pc q)
"E2") (= (TLA.fapply i q)
k_1))))))))
$hyp "v'327" (TLA.in (TLA.setOfAll (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z)))
(TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0) (arith.add X
(arith.minus (TLA.fapply TLA.Succ 0))))))
$goal (TLA.bEx ProcSet ((q) (/\ (= (TLA.fapply pc q) "E2")
(= (TLA.fapply i q)
(TLA.fapply seq m)))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hn:"((Q[(seq[m])])=BOT)" (is "?z_hs=_")
 using v'317 by blast
 have z_Hp:"bAll(isa'dotdot(1, (X +  -.(1))), (\<lambda>k_1. ((((Q[k_1])~=BOT)=>(k_1 \\in setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z])))))&(((k_1 \\in setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))))&((Q[k_1])=BOT))=>bEx(ProcSet, (\<lambda>q. (((pc[q])=''E2'')&((i[q])=k_1))))))))" (is "?z_hp")
 using v'326 by blast
 have z_Ho:"((seq[m]) \\in setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))))" (is "?z_ho")
 using v'325 by blast
 have z_Hq:"(setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))) \\in SUBSET(isa'dotdot(1, (X +  -.(1)))))" (is "?z_hq")
 using v'327 by blast
 assume z_Hr:"(~bEx(ProcSet, (\<lambda>q. (((pc[q])=''E2'')&((i[q])=(seq[m]))))))" (is "~?z_hch")
 have z_Hcl_z_Hp: "(\\A x:((x \\in isa'dotdot(1, (X +  -.(1))))=>((((Q[x])~=BOT)=>(x \\in setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z])))))&(((x \\in setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))))&((Q[x])=BOT))=>bEx(ProcSet, (\<lambda>q. (((pc[q])=''E2'')&((i[q])=x)))))))) == ?z_hp" (is "?z_hcl == _")
 by (unfold bAll_def)
 have z_Hcl: "?z_hcl" (is "\\A x : ?z_hdb(x)")
 by (unfold z_Hcl_z_Hp, fact z_Hp)
 have z_Hdc: "(setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))) \\subseteq isa'dotdot(1, (X +  -.(1))))" (is "?z_hdc")
 by (rule zenon_in_SUBSET_0 [of "setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z])))" "isa'dotdot(1, (X +  -.(1)))", OF z_Hq])
 have z_Hdd_z_Hdc: "bAll(setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))), (\<lambda>x. (x \\in isa'dotdot(1, (X +  -.(1)))))) == ?z_hdc" (is "?z_hdd == _")
 by (unfold subset_def)
 have z_Hdd: "?z_hdd"
 by (unfold z_Hdd_z_Hdc, fact z_Hdc)
 have z_Hdf_z_Hdd: "(\\A x:((x \\in setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))))=>(x \\in isa'dotdot(1, (X +  -.(1)))))) == ?z_hdd" (is "?z_hdf == _")
 by (unfold bAll_def)
 have z_Hdf: "?z_hdf" (is "\\A x : ?z_hdh(x)")
 by (unfold z_Hdf_z_Hdd, fact z_Hdd)
 have z_Hdi: "?z_hdb((seq[m]))" (is "?z_hdj=>?z_hdk")
 by (rule zenon_all_0 [of "?z_hdb" "(seq[m])", OF z_Hcl])
 show FALSE
 proof (rule zenon_imply [OF z_Hdi])
  assume z_Hdl:"(~?z_hdj)"
  have z_Hdm: "?z_hdh((seq[m]))"
  by (rule zenon_all_0 [of "?z_hdh" "(seq[m])", OF z_Hdf])
  show FALSE
  proof (rule zenon_imply [OF z_Hdm])
   assume z_Hdn:"(~?z_ho)"
   show FALSE
   by (rule notE [OF z_Hdn z_Ho])
  next
   assume z_Hdj:"?z_hdj"
   show FALSE
   by (rule notE [OF z_Hdl z_Hdj])
  qed
 next
  assume z_Hdk:"?z_hdk" (is "?z_hdo&?z_hdp")
  have z_Hdp: "?z_hdp" (is "?z_hdq=>_")
  by (rule zenon_and_1 [OF z_Hdk])
  show FALSE
  proof (rule zenon_imply [OF z_Hdp])
   assume z_Hdr:"(~?z_hdq)" (is "~(_&?z_hn)")
   show FALSE
   proof (rule zenon_notand [OF z_Hdr])
    assume z_Hdn:"(~?z_ho)"
    show FALSE
    by (rule notE [OF z_Hdn z_Ho])
   next
    assume z_Hds:"(?z_hs~=BOT)"
    show FALSE
    by (rule notE [OF z_Hds z_Hn])
   qed
  next
   assume z_Hch:"?z_hch"
   show FALSE
   by (rule notE [OF z_Hr z_Hch])
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2139"; *} qed
lemma ob'2133:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "(((((((pc) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & (((X) \<in> (((Nat) \\ ({((0))}))))) & (((Q) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((i) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((j) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((l) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((x) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((v) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((M) \<in> ((SUBSET (subsetOf((CDomain), %a_ca. ((CFTypeOK ((a_ca))))))))))) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'235: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'236: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'244: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'309: "((less ((m), (k))))"
assumes v'310: "(((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((fapply ((a_ca), (''sigma''))), (m)))))"
assumes v'317: "(((fapply ((Q), (fapply ((seq), (m))))) = (BOT)))"
fixes q
assumes q_in : "(q \<in> (ProcSet))"
assumes v'328: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'329: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'330: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'331: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'332: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'333: "((((a_jhash_primea :: c)) = (j)))"
assumes v'334: "((((a_lhash_primea :: c)) = (l)))"
assumes v'335: "((((a_xhash_primea :: c)) = (x)))"
assumes v'336: "((((a_vhash_primea :: c)) = (v)))"
assumes v'337: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca_1. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca_1)) :: c)) & (\<exists> d_1 \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d_1)) :: c)))) : (\<exists> seq_1 \<in> ((Perm ((S)))) : ((((fapply ((a_ca_1), (''sigma''))) = ((Concat ((fapply ((d_1), (''sigma''))), ([ k_1 \<in> ((DOMAIN (seq_1)))  \<mapsto> (fapply ((v), (fapply ((seq_1), (k_1)))))])))))) & (\<forall> q_1 \<in> (ProcSet) : (cond((((q_1) \<in> (S))), (((fapply ((fapply ((a_ca_1), (''fres''))), (q_1))) = (ACK))), (((fapply ((fapply ((a_ca_1), (''fres''))), (q_1))) = (fapply ((fapply ((d_1), (''fres''))), (q_1)))))))))))))))))"
assumes v'338: "(((fapply ((pc), (q))) = (''E2'')))"
assumes v'339: "(((fapply ((i), (q))) = (fapply ((seq), (m)))))"
shows "(\<exists> q_1 \<in> (ProcSet) : (((((fapply (((a_pchash_primea :: c)), (q_1))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q_1))) = (fapply ((seq), (m))))))))"(is "PROP ?ob'2133")
proof -
ML_command {* writeln "*** TLAPS ENTER 2133"; *}
show "PROP ?ob'2133"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_293ef1.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_293ef1.znn.out
;; obligation #2133
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ (/\ (TLA.in pc
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in X (TLA.setminus arith.N (TLA.set 0))) (TLA.in Q
(TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in i (TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in j
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in l
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in x
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in v (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in M
(TLA.SUBSET (TLA.subsetOf CDomain ((a_ca) (CFTypeOK a_ca)))))) a_Invunde_E2a
a_Invunde_E3a a_Invunde_D2a a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina)
(\/ Next (= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'235" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'236" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'244" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$hyp "v'309" (arith.lt m
k)
$hyp "v'310" (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply (TLA.fapply a_ca "sigma") m))
$hyp "v'317" (= (TLA.fapply Q (TLA.fapply seq m))
BOT)
$hyp "q_in" (TLA.in q ProcSet)
$hyp "v'328" (= (TLA.fapply pc p) "E1")
$hyp "v'329" (= a_pchash_primea
(TLA.except pc p "E2"))
$hyp "v'330" (= a_ihash_primea
(TLA.except i p X))
$hyp "v'331" (= a_Xhash_primea (arith.add X
(TLA.fapply TLA.Succ 0)))
$hyp "v'332" (= a_Qhash_primea Q)
$hyp "v'333" (= a_jhash_primea j)
$hyp "v'334" (= a_lhash_primea l)
$hyp "v'335" (= a_xhash_primea x)
$hyp "v'336" (= a_vhash_primea v)
$hyp "v'337" (= a_Mhash_primea
(TLA.subsetOf CDomain ((a_ca_1) (/\ (a_h022c5783954683bdcbcacced356fd6a a_ca_1)
(TLA.bEx M ((d_1) (TLA.bEx (TLA.SUBSET (hc4e622ce2e33ef1c6a9f10c01956cd d_1)) ((S) (TLA.bEx (Perm S) ((seq_1) (/\ (= (TLA.fapply a_ca_1 "sigma")
(Concat (TLA.fapply d_1 "sigma")
(TLA.Fcn (TLA.DOMAIN seq_1) ((k_1) (TLA.fapply v (TLA.fapply seq_1 k_1))))))
(TLA.bAll ProcSet ((q_1) (TLA.cond (TLA.in q_1
S) (= (TLA.fapply (TLA.fapply a_ca_1 "fres") q_1)
ACK) (= (TLA.fapply (TLA.fapply a_ca_1 "fres") q_1)
(TLA.fapply (TLA.fapply d_1 "fres") q_1))))))))))))))))
$hyp "v'338" (= (TLA.fapply pc q) "E2")
$hyp "v'339" (= (TLA.fapply i q)
(TLA.fapply seq m))
$goal (TLA.bEx ProcSet ((q_1) (/\ (= (TLA.fapply a_pchash_primea q_1) "E2")
(= (TLA.fapply a_ihash_primea q_1)
(TLA.fapply seq m)))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hb:"((((pc \\in FuncSet(ProcSet, {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))&((X \\in (Nat \\ {0}))&((Q \\in FuncSet((Nat \\ {0}), ((Nat \\ {0}) \\cup {BOT})))&((i \\in FuncSet(ProcSet, (Nat \\ {0})))&((j \\in FuncSet(ProcSet, (Nat \\ {0})))&((l \\in FuncSet(ProcSet, (Nat \\ {0})))&((x \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {BOT})))&((v \\in FuncSet(ProcSet, (Nat \\ {0})))&(M \\in SUBSET(subsetOf(CDomain, (\<lambda>a_ca. CFTypeOK(a_ca)))))))))))))&(a_Invunde_E2a&(a_Invunde_E3a&(a_Invunde_D2a&(a_Invunde_D3a&(a_Invunde_Qa&a_Invunde_Maina))))))&(Next|(a_h4fd5f73954dc53af536c1c75068837a=vars)))" (is "?z_hbc&?z_hdp")
 using v'209 by blast
 have z_Hr:"(a_ihash_primea=except(i, p, X))" (is "_=?z_hdv")
 using v'330 by blast
 have z_Hq:"(a_pchash_primea=except(pc, p, ''E2''))" (is "_=?z_hdy")
 using v'329 by blast
 have z_Hp:"((pc[p])=''E1'')" (is "?z_hdz=?z_hbk")
 using v'328 by blast
 have z_Hba:"((i[q])=(seq[m]))" (is "?z_hea=?z_hec")
 using v'339 by blast
 have z_Hz:"((pc[q])=''E2'')" (is "?z_hef=?z_hbl")
 using v'338 by blast
 have z_Ho:"(q \\in ProcSet)" (is "?z_ho")
 using q_in by blast
 assume z_Hbb:"(~bEx(ProcSet, (\<lambda>q_1. (((a_pchash_primea[q_1])=?z_hbl)&((a_ihash_primea[q_1])=?z_hec)))))" (is "~?z_heg")
 have z_Hbc: "?z_hbc" (is "?z_hbd&?z_hde")
 by (rule zenon_and_0 [OF z_Hb])
 have z_Hbd: "?z_hbd" (is "?z_hbe&?z_hbr")
 by (rule zenon_and_0 [OF z_Hbc])
 have z_Hbe: "?z_hbe"
 by (rule zenon_and_0 [OF z_Hbd])
 have z_Hbr: "?z_hbr" (is "?z_hbs&?z_hby")
 by (rule zenon_and_1 [OF z_Hbd])
 have z_Hby: "?z_hby" (is "?z_hbz&?z_hcf")
 by (rule zenon_and_1 [OF z_Hbr])
 have z_Hcf: "?z_hcf" (is "?z_hcg&?z_hcj")
 by (rule zenon_and_1 [OF z_Hby])
 have z_Hcg: "?z_hcg"
 by (rule zenon_and_0 [OF z_Hcf])
 have z_Heo: "(?z_hbk~=?z_hbl)"
 by auto
 have z_Hep: "(?z_hdz~=?z_hef)"
 by (rule zenon_stringdiffll [OF z_Heo z_Hp z_Hz])
  have z_Heq_z_Hbb: "(~(\\E x:((x \\in ProcSet)&(((a_pchash_primea[x])=?z_hbl)&((a_ihash_primea[x])=?z_hec))))) == (~?z_heg)" (is "?z_heq == ?z_hbb")
  by (unfold bEx_def)
  have z_Heq: "?z_heq" (is "~(\\E x : ?z_hez(x))")
  by (unfold z_Heq_z_Hbb, fact z_Hbb)
  have z_Hfa: "(DOMAIN(pc)=ProcSet)" (is "?z_hfb=_")
  by (rule zenon_in_funcset_1 [of "pc" "ProcSet" "{''L0'', ?z_hbk, ?z_hbl, ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}", OF z_Hbe])
  have z_Hfc: "(DOMAIN(i)=ProcSet)" (is "?z_hfd=_")
  by (rule zenon_in_funcset_1 [of "i" "ProcSet" "(Nat \\ {0})", OF z_Hcg])
  show FALSE
  proof (rule zenon_noteq [of "?z_hef"])
   have z_Hfe: "(p=q)"
   proof (rule zenon_nnpp [of "(p=q)"])
    assume z_Hff:"(p~=q)"
    have z_Hfg: "~?z_hez(q)" (is "~(_&?z_hfh)")
    by (rule zenon_notex_0 [of "?z_hez" "q", OF z_Heq])
    show FALSE
    proof (rule zenon_notand [OF z_Hfg])
     assume z_Hfi:"(~?z_ho)"
     show FALSE
     by (rule notE [OF z_Hfi z_Ho])
    next
     assume z_Hfj:"(~?z_hfh)" (is "~(?z_hfk&?z_hfl)")
     show FALSE
     proof (rule zenon_notand [OF z_Hfj])
      assume z_Hfm:"((a_pchash_primea[q])~=?z_hbl)" (is "?z_hfn~=_")
      have z_Hfo: "((?z_hdy[q])~=?z_hbl)" (is "?z_hfp~=_")
      by (rule subst [where P="(\<lambda>zenon_Vukc. ((zenon_Vukc[q])~=?z_hbl))", OF z_Hq z_Hfm])
      show FALSE
      proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vyob. (zenon_Vyob~=?z_hbl))" "pc" "p" "?z_hbl" "q", OF z_Hfo])
       assume z_Hfx:"(q \\in ?z_hfb)" (is "?z_hfx")
       assume z_Hfe:"(p=q)"
       assume z_Hfy:"(?z_hbl~=?z_hbl)"
       show FALSE
       by (rule notE [OF z_Hff z_Hfe])
      next
       assume z_Hfx:"(q \\in ?z_hfb)" (is "?z_hfx")
       assume z_Hff:"(p~=q)"
       assume z_Hfz:"(?z_hef~=?z_hbl)"
       show FALSE
       by (rule notE [OF z_Hfz z_Hz])
      next
       assume z_Hga:"(~(q \\in ?z_hfb))" (is "~?z_hfx")
       have z_Hgb: "(\\A zenon_Ved:((zenon_Ved \\in ?z_hfb)<=>(zenon_Ved \\in ProcSet)))" (is "\\A x : ?z_hgg(x)")
       by (rule zenon_setequal_0 [of "?z_hfb" "ProcSet", OF z_Hfa])
       have z_Hgh: "?z_hgg(q)"
       by (rule zenon_all_0 [of "?z_hgg" "q", OF z_Hgb])
       show FALSE
       proof (rule zenon_equiv [OF z_Hgh])
        assume z_Hga:"(~?z_hfx)"
        assume z_Hfi:"(~?z_ho)"
        show FALSE
        by (rule notE [OF z_Hfi z_Ho])
       next
        assume z_Hfx:"?z_hfx"
        assume z_Ho:"?z_ho"
        show FALSE
        by (rule notE [OF z_Hga z_Hfx])
       qed
      qed
     next
      assume z_Hgi:"((a_ihash_primea[q])~=?z_hec)" (is "?z_hgj~=_")
      have z_Hgk: "((?z_hdv[q])~=?z_hec)" (is "?z_hgl~=_")
      by (rule subst [where P="(\<lambda>zenon_Vwkc. ((zenon_Vwkc[q])~=?z_hec))", OF z_Hr z_Hgi])
      show FALSE
      proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vfc. (zenon_Vfc~=?z_hec))" "i" "p" "X" "q", OF z_Hgk])
       assume z_Hgt:"(q \\in ?z_hfd)" (is "?z_hgt")
       assume z_Hfe:"(p=q)"
       assume z_Hgu:"(X~=?z_hec)"
       show FALSE
       by (rule notE [OF z_Hff z_Hfe])
      next
       assume z_Hgt:"(q \\in ?z_hfd)" (is "?z_hgt")
       assume z_Hff:"(p~=q)"
       assume z_Hgv:"(?z_hea~=?z_hec)"
       show FALSE
       by (rule notE [OF z_Hgv z_Hba])
      next
       assume z_Hgw:"(~(q \\in ?z_hfd))" (is "~?z_hgt")
       have z_Hgx: "(\\A zenon_Vrd:((zenon_Vrd \\in ?z_hfd)<=>(zenon_Vrd \\in ProcSet)))" (is "\\A x : ?z_hhc(x)")
       by (rule zenon_setequal_0 [of "?z_hfd" "ProcSet", OF z_Hfc])
       have z_Hhd: "?z_hhc(q)"
       by (rule zenon_all_0 [of "?z_hhc" "q", OF z_Hgx])
       show FALSE
       proof (rule zenon_equiv [OF z_Hhd])
        assume z_Hgw:"(~?z_hgt)"
        assume z_Hfi:"(~?z_ho)"
        show FALSE
        by (rule notE [OF z_Hfi z_Ho])
       next
        assume z_Hgt:"?z_hgt"
        assume z_Ho:"?z_ho"
        show FALSE
        by (rule notE [OF z_Hgw z_Hgt])
       qed
      qed
     qed
    qed
   qed
   have z_Hhe: "(?z_hef~=?z_hef)"
   by (rule subst [where P="(\<lambda>zenon_Vxkc. ((pc[zenon_Vxkc])~=?z_hef))", OF z_Hfe], fact z_Hep)
   thus "(?z_hef~=?z_hef)" .
  qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2133"; *} qed
lemma ob'2184:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "(((((((pc) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & (((X) \<in> (((Nat) \\ ({((0))}))))) & (((Q) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((i) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((j) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((l) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((x) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((v) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((M) \<in> ((SUBSET (subsetOf((CDomain), %a_ca. ((CFTypeOK ((a_ca))))))))))) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'235: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'236: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'244: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'309: "((less ((m), (k))))"
assumes v'310: "(((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((fapply ((a_ca), (''sigma''))), (m)))))"
assumes v'317: "(((fapply ((Q), (fapply ((seq), (m))))) = (BOT)))"
fixes q
assumes q_in : "(q \<in> (ProcSet))"
fixes r
assumes r_in : "(r \<in> (ProcSet))"
assumes v'341: "(((fapply (((a_ihash_primea :: c)), (p))) \<noteq> (fapply (((a_ihash_primea :: c)), (q)))))"
assumes v'342: "(((fapply ((pc), (r))) = (''E2'')))"
assumes v'343: "(((fapply ((i), (r))) = (fapply ((seq), (m)))))"
assumes v'344: "(((fapply ((fapply ((a_ca), (''sigma''))), (m))) = (fapply ((v), (r)))))"
assumes v'345: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'346: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'347: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'348: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'349: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'350: "((((a_jhash_primea :: c)) = (j)))"
assumes v'351: "((((a_lhash_primea :: c)) = (l)))"
assumes v'352: "((((a_xhash_primea :: c)) = (x)))"
assumes v'353: "((((a_vhash_primea :: c)) = (v)))"
assumes v'354: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca_1. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca_1)) :: c)) & (\<exists> d_1 \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d_1)) :: c)))) : (\<exists> seq_1 \<in> ((Perm ((S)))) : ((((fapply ((a_ca_1), (''sigma''))) = ((Concat ((fapply ((d_1), (''sigma''))), ([ k_1 \<in> ((DOMAIN (seq_1)))  \<mapsto> (fapply ((v), (fapply ((seq_1), (k_1)))))])))))) & (\<forall> q_1 \<in> (ProcSet) : (cond((((q_1) \<in> (S))), (((fapply ((fapply ((a_ca_1), (''fres''))), (q_1))) = (ACK))), (((fapply ((fapply ((a_ca_1), (''fres''))), (q_1))) = (fapply ((fapply ((d_1), (''fres''))), (q_1)))))))))))))))))"
shows "(((((p) \<noteq> (q))) \<and> (((p) \<noteq> (r)))))"(is "PROP ?ob'2184")
proof -
ML_command {* writeln "*** TLAPS ENTER 2184"; *}
show "PROP ?ob'2184"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_d31f87.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_d31f87.znn.out
;; obligation #2184
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ (/\ (TLA.in pc
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in X (TLA.setminus arith.N (TLA.set 0))) (TLA.in Q
(TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in i (TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in j
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in l
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in x
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in v (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in M
(TLA.SUBSET (TLA.subsetOf CDomain ((a_ca) (CFTypeOK a_ca)))))) a_Invunde_E2a
a_Invunde_E3a a_Invunde_D2a a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina)
(\/ Next (= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'235" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'236" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'244" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$hyp "v'309" (arith.lt m
k)
$hyp "v'310" (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply (TLA.fapply a_ca "sigma") m))
$hyp "v'317" (= (TLA.fapply Q (TLA.fapply seq m))
BOT)
$hyp "q_in" (TLA.in q ProcSet)
$hyp "r_in" (TLA.in r ProcSet)
$hyp "v'341" (-. (= (TLA.fapply a_ihash_primea p)
(TLA.fapply a_ihash_primea q)))
$hyp "v'342" (= (TLA.fapply pc r) "E2")
$hyp "v'343" (= (TLA.fapply i r)
(TLA.fapply seq m))
$hyp "v'344" (= (TLA.fapply (TLA.fapply a_ca "sigma") m)
(TLA.fapply v r))
$hyp "v'345" (= (TLA.fapply pc p) "E1")
$hyp "v'346" (= a_pchash_primea
(TLA.except pc p "E2"))
$hyp "v'347" (= a_ihash_primea
(TLA.except i p X))
$hyp "v'348" (= a_Xhash_primea (arith.add X
(TLA.fapply TLA.Succ 0)))
$hyp "v'349" (= a_Qhash_primea Q)
$hyp "v'350" (= a_jhash_primea j)
$hyp "v'351" (= a_lhash_primea l)
$hyp "v'352" (= a_xhash_primea x)
$hyp "v'353" (= a_vhash_primea v)
$hyp "v'354" (= a_Mhash_primea
(TLA.subsetOf CDomain ((a_ca_1) (/\ (a_h022c5783954683bdcbcacced356fd6a a_ca_1)
(TLA.bEx M ((d_1) (TLA.bEx (TLA.SUBSET (hc4e622ce2e33ef1c6a9f10c01956cd d_1)) ((S) (TLA.bEx (Perm S) ((seq_1) (/\ (= (TLA.fapply a_ca_1 "sigma")
(Concat (TLA.fapply d_1 "sigma")
(TLA.Fcn (TLA.DOMAIN seq_1) ((k_1) (TLA.fapply v (TLA.fapply seq_1 k_1))))))
(TLA.bAll ProcSet ((q_1) (TLA.cond (TLA.in q_1
S) (= (TLA.fapply (TLA.fapply a_ca_1 "fres") q_1)
ACK) (= (TLA.fapply (TLA.fapply a_ca_1 "fres") q_1)
(TLA.fapply (TLA.fapply d_1 "fres") q_1))))))))))))))))
$goal (/\ (-. (= p q)) (-. (= p
r)))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hw:"(a_ihash_primea=except(i, p, X))" (is "_=?z_hbg")
 using v'347 by blast
 have z_Hu:"((pc[p])=''E1'')" (is "?z_hbk=?z_hbm")
 using v'345 by blast
 have z_Hr:"((pc[r])=''E2'')" (is "?z_hbn=?z_hbp")
 using v'342 by blast
 have z_Hq:"((a_ihash_primea[p])~=(a_ihash_primea[q]))" (is "?z_hbq~=?z_hbr")
 using v'341 by blast
 assume z_Hbe:"(~((p~=q)&(p~=r)))" (is "~(?z_hbu&?z_hbv)")
 have z_Hbw: "(?z_hbp~=?z_hbm)"
 by auto
 have z_Hbx: "(?z_hbn~=?z_hbk)"
 by (rule zenon_stringdiffll [OF z_Hbw z_Hr z_Hu])
  show FALSE
  proof (rule zenon_notand [OF z_Hbe])
   assume z_Hby:"(~?z_hbu)" (is "~~?z_hbz")
   have z_Hbz: "?z_hbz"
   by (rule zenon_notnot_0 [OF z_Hby])
   have z_Hca: "((?z_hbg[p])~=?z_hbr)" (is "?z_hcb~=_")
   by (rule subst [where P="(\<lambda>zenon_Vk. ((zenon_Vk[p])~=?z_hbr))", OF z_Hw z_Hq])
   show FALSE
   proof (rule zenon_noteq [of "?z_hbr"])
    have z_Hcg: "(?z_hbg=a_ihash_primea)"
    by (rule sym [OF z_Hw])
    have z_Hq: "(?z_hbq~=?z_hbr)"
    by (rule subst [where P="(\<lambda>zenon_Vk. ((zenon_Vk[p])~=?z_hbr))", OF z_Hcg], fact z_Hca)
    have z_Hch: "(?z_hbr~=?z_hbr)"
    by (rule subst [where P="(\<lambda>zenon_Vbi. ((a_ihash_primea[zenon_Vbi])~=?z_hbr))", OF z_Hbz], fact z_Hq)
    thus "(?z_hbr~=?z_hbr)" .
   qed
  next
   assume z_Hcm:"(~?z_hbv)" (is "~~?z_hcn")
   have z_Hcn: "?z_hcn"
   by (rule zenon_notnot_0 [OF z_Hcm])
   show FALSE
   proof (rule zenon_noteq [of "?z_hbk"])
    have z_Hco: "(r=p)"
    by (rule sym [OF z_Hcn])
    have z_Hcp: "(?z_hbk~=?z_hbk)"
    by (rule subst [where P="(\<lambda>zenon_Vfc. ((pc[zenon_Vfc])~=?z_hbk))", OF z_Hco], fact z_Hbx)
    thus "(?z_hbk~=?z_hbk)" .
   qed
  qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2184"; *} qed
lemma ob'2169:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'310: "((less ((m), (k))))"
assumes v'311: "(((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((fapply ((a_ca), (''sigma''))), (m)))))"
assumes v'318: "(((fapply ((Q), (fapply ((seq), (m))))) = (BOT)))"
fixes q
assumes q_in : "(q \<in> (ProcSet))"
assumes v'333: "(((fapply ((fapply ((a_ca), (''sigma''))), (m))) = (fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (m)))))))))))))"
assumes v'334: "(\<exists> r \<in> (ProcSet) : (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (m))))))))"
shows "(\<exists> r \<in> (ProcSet) : (((((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (m))))))) \<and> (((fapply ((fapply ((a_ca), (''sigma''))), (m))) = (fapply ((v), (r))))))))"(is "PROP ?ob'2169")
proof -
ML_command {* writeln "*** TLAPS ENTER 2169"; *}
show "PROP ?ob'2169"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_5b56ab.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_5b56ab.znn.out
;; obligation #2169
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$hyp "v'310" (arith.lt m
k)
$hyp "v'311" (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply (TLA.fapply a_ca "sigma") m))
$hyp "v'318" (= (TLA.fapply Q (TLA.fapply seq m))
BOT)
$hyp "q_in" (TLA.in q ProcSet)
$hyp "v'333" (= (TLA.fapply (TLA.fapply a_ca "sigma") m)
(TLA.fapply v (TLA.bChoice ProcSet ((r) (/\ (= (TLA.fapply pc r) "E2")
(= (TLA.fapply i r)
(TLA.fapply seq m)))))))
$hyp "v'334" (TLA.bEx ProcSet ((r) (/\ (= (TLA.fapply pc r) "E2")
(= (TLA.fapply i r)
(TLA.fapply seq m)))))
$goal (TLA.bEx ProcSet ((r) (/\ (/\ (= (TLA.fapply pc r) "E2")
(= (TLA.fapply i r) (TLA.fapply seq m)))
(= (TLA.fapply (TLA.fapply a_ca "sigma") m)
(TLA.fapply v r)))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hq:"bEx(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[m])))))" (is "?z_hq")
 using v'334 by blast
 have z_Hp:"(((a_ca[''sigma''])[m])=(v[bChoice(ProcSet, (\<lambda>r. (((pc[r])=''E2'')&((i[r])=(seq[m])))))]))" (is "?z_hbg=?z_hbk")
 using v'333 by blast
 assume z_Hr:"(~bEx(ProcSet, (\<lambda>r. ((((pc[r])=''E2'')&((i[r])=(seq[m])))&(?z_hbg=(v[r]))))))" (is "~?z_hbn")
 have z_Hbs_z_Hq: "(\\E x:((x \\in ProcSet)&(((pc[x])=''E2'')&((i[x])=(seq[m]))))) == ?z_hq" (is "?z_hbs == _")
 by (unfold bEx_def)
 have z_Hbs: "?z_hbs" (is "\\E x : ?z_hcb(x)")
 by (unfold z_Hbs_z_Hq, fact z_Hq)
 have z_Hcc: "?z_hcb((CHOOSE x:((x \\in ProcSet)&(((pc[x])=''E2'')&((i[x])=(seq[m]))))))" (is "?z_hce&?z_hcf")
 by (rule zenon_ex_choose_0 [of "?z_hcb", OF z_Hbs])
 have z_Hce: "?z_hce"
 by (rule zenon_and_0 [OF z_Hcc])
 have z_Hcf: "?z_hcf" (is "?z_hcg&?z_hch")
 by (rule zenon_and_1 [OF z_Hcc])
 have z_Hcg: "?z_hcg" (is "?z_hci=?z_hz")
 by (rule zenon_and_0 [OF z_Hcf])
 have z_Hch: "?z_hch" (is "?z_hcj=?z_hbd")
 by (rule zenon_and_1 [OF z_Hcf])
 have z_Hck_z_Hr: "(~(\\E x:((x \\in ProcSet)&((((pc[x])=?z_hz)&((i[x])=?z_hbd))&(?z_hbg=(v[x])))))) == (~?z_hbn)" (is "?z_hck == ?z_hr")
 by (unfold bEx_def)
 have z_Hck: "?z_hck" (is "~(\\E x : ?z_hcq(x))")
 by (unfold z_Hck_z_Hr, fact z_Hr)
 have z_Hcr_z_Hp: "(?z_hbg=(v[(CHOOSE x:((x \\in ProcSet)&(((pc[x])=?z_hz)&((i[x])=?z_hbd))))])) == (?z_hbg=?z_hbk)" (is "?z_hcr == ?z_hp")
 by (unfold bChoose_def)
 have z_Hcr: "?z_hcr" (is "_=?z_hcs")
 by (unfold z_Hcr_z_Hp, fact z_Hp)
 have z_Hct: "~?z_hcq((CHOOSE x:((x \\in ProcSet)&(((pc[x])=?z_hz)&((i[x])=?z_hbd)))))" (is "~(_&?z_hcu)")
 by (rule zenon_notex_0 [of "?z_hcq" "(CHOOSE x:((x \\in ProcSet)&(((pc[x])=?z_hz)&((i[x])=?z_hbd))))", OF z_Hck])
 show FALSE
 proof (rule zenon_notand [OF z_Hct])
  assume z_Hcv:"(~?z_hce)"
  show FALSE
  by (rule notE [OF z_Hcv z_Hce])
 next
  assume z_Hcw:"(~?z_hcu)"
  show FALSE
  proof (rule zenon_notand [OF z_Hcw])
   assume z_Hcx:"(~?z_hcf)"
   show FALSE
   proof (rule zenon_notand [OF z_Hcx])
    assume z_Hcy:"(?z_hci~=?z_hz)"
    show FALSE
    by (rule notE [OF z_Hcy z_Hcg])
   next
    assume z_Hcz:"(?z_hcj~=?z_hbd)"
    show FALSE
    by (rule notE [OF z_Hcz z_Hch])
   qed
  next
   assume z_Hda:"(?z_hbg~=?z_hcs)"
   show FALSE
   by (rule notE [OF z_Hda z_Hcr])
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2169"; *} qed
lemma ob'2158:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'235: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'236: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'244: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'309: "((less ((m), (k))))"
assumes v'310: "(((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((fapply ((a_ca), (''sigma''))), (m)))))"
assumes v'317: "(((fapply ((Q), (fapply ((seq), (m))))) = (BOT)))"
fixes q
assumes q_in : "(q \<in> (ProcSet))"
assumes v'331: "((GoodRes ((setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z))))), (fapply ((a_ca), (''fres''))))))"
assumes v'332: "(((fapply ((a_ca), (''sigma''))) = ([ k_1 \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0])))))))))))  \<mapsto> (fapply ((seq), (z)))])))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0])))))))))))  \<mapsto> (fapply ((seq), (z)))]), (k_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0])))))))))))  \<mapsto> (fapply ((seq), (z)))]), (k_1)))))>>,(fapply ((v), (bChoice((ProcSet), %q_1. (((((fapply ((pc), (q_1))) = (''E2''))) \<and> (((fapply ((i), (q_1))) = (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0])))))))))))  \<mapsto> (fapply ((seq), (z)))]), (k_1)))))))))))))])))"
assumes v'333: "(((m) \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0])))))))))))  \<mapsto> (fapply ((seq), (z)))])))))"
assumes v'334: "((((DOMAIN (seq))) = ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A)))))))))"
shows "(((fapply ((fapply ((a_ca), (''sigma''))), (m))) = (fapply ((v), (bChoice((ProcSet), %r. (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply ((seq), (m)))))))))))))"(is "PROP ?ob'2158")
proof -
ML_command {* writeln "*** TLAPS ENTER 2158"; *}
show "PROP ?ob'2158"
using assms by auto
ML_command {* writeln "*** TLAPS EXIT 2158"; *} qed
lemma ob'2155:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'310: "((less ((m), (k))))"
assumes v'311: "(((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((fapply ((a_ca), (''sigma''))), (m)))))"
assumes v'318: "(((fapply ((Q), (fapply ((seq), (m))))) = (BOT)))"
fixes q
assumes q_in : "(q \<in> (ProcSet))"
assumes v'331: "(((m) \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0])))))))))))))"
shows "(((m) \<in> ((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0])))))))))))  \<mapsto> (fapply ((seq), (z)))])))))"(is "PROP ?ob'2155")
proof -
ML_command {* writeln "*** TLAPS ENTER 2155"; *}
show "PROP ?ob'2155"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_dbd29f.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_dbd29f.znn.out
;; obligation #2155
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$hyp "v'310" (arith.lt m
k)
$hyp "v'311" (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply (TLA.fapply a_ca "sigma") m))
$hyp "v'318" (= (TLA.fapply Q (TLA.fapply seq m))
BOT)
$hyp "q_in" (TLA.in q ProcSet)
$hyp "v'331" (TLA.in m (arith.intrange (TLA.fapply TLA.Succ 0) (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))
$goal (TLA.in m (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z)))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hp:"(m \\in isa'dotdot(1, (k +  -.(1))))" (is "?z_hp")
 using v'331 by blast
 assume z_Hq:"(~(m \\in DOMAIN(Fcn(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))))))" (is "~?z_hx")
 have z_Hbe: "(~?z_hp)"
 by (rule zenon_domain_fcn_0 [of "(\<lambda>zenon_Vg. (~(m \\in zenon_Vg)))" "isa'dotdot(1, (k +  -.(1)))" "(\<lambda>z. (seq[z]))", OF z_Hq])
 show FALSE
 by (rule notE [OF z_Hbe z_Hp])
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2155"; *} qed
lemma ob'2209:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'311: "((geq ((m), (k))))"
assumes v'312: "((((geq ((m), (k)))) \<Longrightarrow> ((((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((v), (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))))) \<Longrightarrow> (((fapply ((v), (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))) = (fapply (([ m_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (m_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (m_1)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m_1)))))))))))))]), (m))))))))"
assumes v'314: "((((geq ((m), (k)))) \<Rightarrow> (((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((v), (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))))))))"
assumes v'315: "((((less ((m), (k)))) \<Rightarrow> (((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((fapply ((a_ca), (''sigma''))), (m)))))))"
shows "(((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply (([ m_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (m_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (m_1)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m_1)))))))))))))]), (m)))))"(is "PROP ?ob'2209")
proof -
ML_command {* writeln "*** TLAPS ENTER 2209"; *}
show "PROP ?ob'2209"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_cff9ea.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_cff9ea.znn.out
;; obligation #2209
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$hyp "v'311" (arith.le k m)
$hyp "v'312" (=> (arith.le k m) (=> (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z)))))))) (arith.add m
(arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))))) (= (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z)))))))) (arith.add m
(arith.minus (arith.add k (arith.minus (TLA.fapply TLA.Succ 0)))))))
(TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((m_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq m_1))
BOT)) (TLA.fapply Q (TLA.fapply seq m_1)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq m_1))))))))) m))))
$hyp "v'314" (=> (arith.le k m) (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z)))))))) (arith.add m
(arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))))))
$hyp "v'315" (=> (arith.lt m k) (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply (TLA.fapply a_ca "sigma") m)))
$goal (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((m_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq m_1))
BOT)) (TLA.fapply Q (TLA.fapply seq m_1)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq m_1))))))))) m))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hm:"((k <= m)=>((((d[''sigma''])[m])=(v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[(m +  -.((k +  -.(1))))])]))=>((v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[(m +  -.((k +  -.(1))))])])=(Fcn(DOMAIN(seq), (\<lambda>m_1. (CASE ((Q[(seq[m_1])])~=BOT) -> (Q[(seq[m_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m_1])))))]))))[m]))))" (is "?z_hl=>?z_hs")
 using v'312 by blast
 have z_Hn:"(?z_hl=>(((d[''sigma''])[m])=(v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[(m +  -.((k +  -.(1))))])])))" (is "_=>?z_ht")
 using v'314 by blast
 have z_Hl:"?z_hl"
 using v'311 by blast
 assume z_Hp:"(((d[''sigma''])[m])~=(Fcn(DOMAIN(seq), (\<lambda>m_1. (CASE ((Q[(seq[m_1])])~=BOT) -> (Q[(seq[m_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m_1])))))]))))[m]))" (is "?z_hu~=?z_hcn")
 show FALSE
 proof (rule zenon_imply [OF z_Hm])
  assume z_Hdj:"(~?z_hl)"
  show FALSE
  by (rule notE [OF z_Hdj z_Hl])
 next
  assume z_Hs:"?z_hs" (is "_=>?z_hcm")
  show FALSE
  proof (rule zenon_imply [OF z_Hs])
   assume z_Hdk:"(?z_hu~=(v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[(m +  -.((k +  -.(1))))])]))" (is "_~=?z_hy")
   show FALSE
   proof (rule zenon_imply [OF z_Hn])
    assume z_Hdj:"(~?z_hl)"
    show FALSE
    by (rule notE [OF z_Hdj z_Hl])
   next
    assume z_Ht:"?z_ht"
    show FALSE
    by (rule notE [OF z_Hdk z_Ht])
   qed
  next
   assume z_Hcm:"?z_hcm" (is "?z_hy=_")
   show FALSE
   proof (rule zenon_imply [OF z_Hn])
    assume z_Hdj:"(~?z_hl)"
    show FALSE
    by (rule notE [OF z_Hdj z_Hl])
   next
    assume z_Ht:"?z_ht"
    show FALSE
    proof (rule notE [OF z_Hp])
     have z_Hdl: "(?z_hy=?z_hu)"
     by (rule sym [OF z_Ht])
     have z_Hdm: "(?z_hu=?z_hcn)"
     by (rule subst [where P="(\<lambda>zenon_Vsa. (zenon_Vsa=?z_hcn))", OF z_Hdl], fact z_Hcm)
     thus "(?z_hu=?z_hcn)" .
    qed
   qed
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2209"; *} qed
lemma ob'2193:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "(((((((pc) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & (((X) \<in> (((Nat) \\ ({((0))}))))) & (((Q) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((i) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((j) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((l) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((x) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((v) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((M) \<in> ((SUBSET (subsetOf((CDomain), %a_ca. ((CFTypeOK ((a_ca))))))))))) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'235: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'236: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'244: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'309: "((less ((m), (k))))"
assumes v'310: "(((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((fapply ((a_ca), (''sigma''))), (m)))))"
assumes v'317: "(((fapply ((Q), (fapply ((seq), (m))))) = (BOT)))"
fixes q
assumes q_in : "(q \<in> (ProcSet))"
fixes r
assumes r_in : "(r \<in> (ProcSet))"
assumes v'343: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'344: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'345: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'346: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'347: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'348: "((((a_jhash_primea :: c)) = (j)))"
assumes v'349: "((((a_lhash_primea :: c)) = (l)))"
assumes v'350: "((((a_xhash_primea :: c)) = (x)))"
assumes v'351: "((((a_vhash_primea :: c)) = (v)))"
assumes v'352: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca_1. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca_1)) :: c)) & (\<exists> d_1 \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d_1)) :: c)))) : (\<exists> seq_1 \<in> ((Perm ((S)))) : ((((fapply ((a_ca_1), (''sigma''))) = ((Concat ((fapply ((d_1), (''sigma''))), ([ k_1 \<in> ((DOMAIN (seq_1)))  \<mapsto> (fapply ((v), (fapply ((seq_1), (k_1)))))])))))) & (\<forall> q_1 \<in> (ProcSet) : (cond((((q_1) \<in> (S))), (((fapply ((fapply ((a_ca_1), (''fres''))), (q_1))) = (ACK))), (((fapply ((fapply ((a_ca_1), (''fres''))), (q_1))) = (fapply ((fapply ((d_1), (''fres''))), (q_1)))))))))))))))))"
assumes v'353: "(((fapply (((a_pchash_primea :: c)), (q))) = (''E2'')))"
assumes v'354: "(((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m)))))"
assumes v'355: "(((fapply (([ m_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (m_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (m_1)))))>>,(fapply ((v), (bChoice((ProcSet), %q_1. (((((fapply (((a_pchash_primea :: c)), (q_1))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q_1))) = (fapply ((seq), (m_1)))))))))))))]), (m))) = (fapply ((v), (q)))))"
assumes v'356: "(((((p) \<noteq> (q))) \<and> (((p) \<noteq> (r)))))"
shows "(((fapply ((pc), (q))) = (''E2'')))"(is "PROP ?ob'2193")
proof -
ML_command {* writeln "*** TLAPS ENTER 2193"; *}
show "PROP ?ob'2193"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_1c13f7.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_1c13f7.znn.out
;; obligation #2193
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ (/\ (TLA.in pc
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in X (TLA.setminus arith.N (TLA.set 0))) (TLA.in Q
(TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in i (TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in j
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in l
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in x
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in v (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in M
(TLA.SUBSET (TLA.subsetOf CDomain ((a_ca) (CFTypeOK a_ca)))))) a_Invunde_E2a
a_Invunde_E3a a_Invunde_D2a a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina)
(\/ Next (= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'235" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'236" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'244" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$hyp "v'309" (arith.lt m
k)
$hyp "v'310" (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply (TLA.fapply a_ca "sigma") m))
$hyp "v'317" (= (TLA.fapply Q (TLA.fapply seq m))
BOT)
$hyp "q_in" (TLA.in q ProcSet)
$hyp "r_in" (TLA.in r ProcSet)
$hyp "v'343" (= (TLA.fapply pc p) "E1")
$hyp "v'344" (= a_pchash_primea
(TLA.except pc p "E2"))
$hyp "v'345" (= a_ihash_primea
(TLA.except i p X))
$hyp "v'346" (= a_Xhash_primea (arith.add X
(TLA.fapply TLA.Succ 0)))
$hyp "v'347" (= a_Qhash_primea Q)
$hyp "v'348" (= a_jhash_primea j)
$hyp "v'349" (= a_lhash_primea l)
$hyp "v'350" (= a_xhash_primea x)
$hyp "v'351" (= a_vhash_primea v)
$hyp "v'352" (= a_Mhash_primea
(TLA.subsetOf CDomain ((a_ca_1) (/\ (a_h022c5783954683bdcbcacced356fd6a a_ca_1)
(TLA.bEx M ((d_1) (TLA.bEx (TLA.SUBSET (hc4e622ce2e33ef1c6a9f10c01956cd d_1)) ((S) (TLA.bEx (Perm S) ((seq_1) (/\ (= (TLA.fapply a_ca_1 "sigma")
(Concat (TLA.fapply d_1 "sigma")
(TLA.Fcn (TLA.DOMAIN seq_1) ((k_1) (TLA.fapply v (TLA.fapply seq_1 k_1))))))
(TLA.bAll ProcSet ((q_1) (TLA.cond (TLA.in q_1
S) (= (TLA.fapply (TLA.fapply a_ca_1 "fres") q_1)
ACK) (= (TLA.fapply (TLA.fapply a_ca_1 "fres") q_1)
(TLA.fapply (TLA.fapply d_1 "fres") q_1))))))))))))))))
$hyp "v'353" (= (TLA.fapply a_pchash_primea q)
"E2")
$hyp "v'354" (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq m))
$hyp "v'355" (= (TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((m_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq m_1))
BOT)) (TLA.fapply Q (TLA.fapply seq m_1)) (TLA.fapply v (TLA.bChoice ProcSet ((q_1) (/\ (= (TLA.fapply a_pchash_primea q_1)
"E2") (= (TLA.fapply a_ihash_primea q_1) (TLA.fapply seq m_1))))))))) m)
(TLA.fapply v q))
$hyp "v'356" (/\ (-. (= p q)) (-. (= p r)))
$goal (= (TLA.fapply pc q)
"E2")
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hb:"((((pc \\in FuncSet(ProcSet, {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))&((X \\in (Nat \\ {0}))&((Q \\in FuncSet((Nat \\ {0}), ((Nat \\ {0}) \\cup {BOT})))&((i \\in FuncSet(ProcSet, (Nat \\ {0})))&((j \\in FuncSet(ProcSet, (Nat \\ {0})))&((l \\in FuncSet(ProcSet, (Nat \\ {0})))&((x \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {BOT})))&((v \\in FuncSet(ProcSet, (Nat \\ {0})))&(M \\in SUBSET(subsetOf(CDomain, (\<lambda>a_ca. CFTypeOK(a_ca)))))))))))))&(a_Invunde_E2a&(a_Invunde_E3a&(a_Invunde_D2a&(a_Invunde_D3a&(a_Invunde_Qa&a_Invunde_Maina))))))&(Next|(a_h4fd5f73954dc53af536c1c75068837a=vars)))" (is "?z_hbf&?z_hds")
 using v'209 by blast
 have z_Hr:"(a_pchash_primea=except(pc, p, ''E2''))" (is "_=?z_hdy")
 using v'344 by blast
 have z_Hbd:"((p~=q)&(p~=r))" (is "?z_hea&?z_hec")
 using v'356 by blast
 have z_Hba:"((a_pchash_primea[q])=''E2'')" (is "?z_hee=?z_hbo")
 using v'353 by blast
 have z_Ho:"(q \\in ProcSet)" (is "?z_ho")
 using q_in by blast
 assume z_Hbe:"((pc[q])~=?z_hbo)" (is "?z_hef~=_")
 have z_Hbf: "?z_hbf" (is "?z_hbg&?z_hdh")
 by (rule zenon_and_0 [OF z_Hb])
 have z_Hbg: "?z_hbg" (is "?z_hbh&?z_hbu")
 by (rule zenon_and_0 [OF z_Hbf])
 have z_Hbh: "?z_hbh"
 by (rule zenon_and_0 [OF z_Hbg])
 have z_Hea: "?z_hea"
 by (rule zenon_and_0 [OF z_Hbd])
 have z_Heg: "(DOMAIN(pc)=ProcSet)" (is "?z_heh=_")
 by (rule zenon_in_funcset_1 [of "pc" "ProcSet" "{''L0'', ''E1'', ?z_hbo, ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}", OF z_Hbh])
 have z_Hei: "((?z_hdy[q])=?z_hbo)" (is "?z_hej=_")
 by (rule subst [where P="(\<lambda>zenon_Vhba. ((zenon_Vhba[q])=?z_hbo))", OF z_Hr z_Hba])
 show FALSE
 proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vj. (zenon_Vj=?z_hbo))" "pc" "p" "?z_hbo" "q", OF z_Hei])
  assume z_Her:"(q \\in ?z_heh)" (is "?z_her")
  assume z_Hes:"(p=q)"
  assume z_Het:"(?z_hbo=?z_hbo)"
  show FALSE
  by (rule notE [OF z_Hea z_Hes])
 next
  assume z_Her:"(q \\in ?z_heh)" (is "?z_her")
  assume z_Hea:"?z_hea"
  assume z_Heu:"(?z_hef=?z_hbo)"
  show FALSE
  by (rule notE [OF z_Hbe z_Heu])
 next
  assume z_Hev:"(~(q \\in ?z_heh))" (is "~?z_her")
  have z_Hew: "(\\A zenon_Vhd:((zenon_Vhd \\in ?z_heh)<=>(zenon_Vhd \\in ProcSet)))" (is "\\A x : ?z_hfb(x)")
  by (rule zenon_setequal_0 [of "?z_heh" "ProcSet", OF z_Heg])
  have z_Hfc: "?z_hfb(q)"
  by (rule zenon_all_0 [of "?z_hfb" "q", OF z_Hew])
  show FALSE
  proof (rule zenon_equiv [OF z_Hfc])
   assume z_Hev:"(~?z_her)"
   assume z_Hfd:"(~?z_ho)"
   show FALSE
   by (rule notE [OF z_Hfd z_Ho])
  next
   assume z_Her:"?z_her"
   assume z_Ho:"?z_ho"
   show FALSE
   by (rule notE [OF z_Hev z_Her])
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2193"; *} qed
lemma ob'2189:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "(((((((pc) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & (((X) \<in> (((Nat) \\ ({((0))}))))) & (((Q) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((i) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((j) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((l) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((x) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((v) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((M) \<in> ((SUBSET (subsetOf((CDomain), %a_ca. ((CFTypeOK ((a_ca))))))))))) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'235: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'236: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'244: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'309: "((less ((m), (k))))"
assumes v'310: "(((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((fapply ((a_ca), (''sigma''))), (m)))))"
assumes v'317: "(((fapply ((Q), (fapply ((seq), (m))))) = (BOT)))"
fixes q
assumes q_in : "(q \<in> (ProcSet))"
fixes r
assumes r_in : "(r \<in> (ProcSet))"
assumes v'342: "(((((p) \<noteq> (q))) \<and> (((p) \<noteq> (r)))))"
assumes v'343: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'344: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'345: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'346: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'347: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'348: "((((a_jhash_primea :: c)) = (j)))"
assumes v'349: "((((a_lhash_primea :: c)) = (l)))"
assumes v'350: "((((a_xhash_primea :: c)) = (x)))"
assumes v'351: "((((a_vhash_primea :: c)) = (v)))"
assumes v'352: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca_1. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca_1)) :: c)) & (\<exists> d_1 \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d_1)) :: c)))) : (\<exists> seq_1 \<in> ((Perm ((S)))) : ((((fapply ((a_ca_1), (''sigma''))) = ((Concat ((fapply ((d_1), (''sigma''))), ([ k_1 \<in> ((DOMAIN (seq_1)))  \<mapsto> (fapply ((v), (fapply ((seq_1), (k_1)))))])))))) & (\<forall> q_1 \<in> (ProcSet) : (cond((((q_1) \<in> (S))), (((fapply ((fapply ((a_ca_1), (''fres''))), (q_1))) = (ACK))), (((fapply ((fapply ((a_ca_1), (''fres''))), (q_1))) = (fapply ((fapply ((d_1), (''fres''))), (q_1)))))))))))))))))"
shows "(((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((i), (q)))))"(is "PROP ?ob'2189")
proof -
ML_command {* writeln "*** TLAPS ENTER 2189"; *}
show "PROP ?ob'2189"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_8a30db.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_8a30db.znn.out
;; obligation #2189
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ (/\ (TLA.in pc
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in X (TLA.setminus arith.N (TLA.set 0))) (TLA.in Q
(TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in i (TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in j
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in l
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in x
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in v (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in M
(TLA.SUBSET (TLA.subsetOf CDomain ((a_ca) (CFTypeOK a_ca)))))) a_Invunde_E2a
a_Invunde_E3a a_Invunde_D2a a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina)
(\/ Next (= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'235" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'236" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'244" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$hyp "v'309" (arith.lt m
k)
$hyp "v'310" (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply (TLA.fapply a_ca "sigma") m))
$hyp "v'317" (= (TLA.fapply Q (TLA.fapply seq m))
BOT)
$hyp "q_in" (TLA.in q ProcSet)
$hyp "r_in" (TLA.in r ProcSet)
$hyp "v'342" (/\ (-. (= p q)) (-. (= p r)))
$hyp "v'343" (= (TLA.fapply pc p) "E1")
$hyp "v'344" (= a_pchash_primea
(TLA.except pc p "E2"))
$hyp "v'345" (= a_ihash_primea
(TLA.except i p X))
$hyp "v'346" (= a_Xhash_primea (arith.add X
(TLA.fapply TLA.Succ 0)))
$hyp "v'347" (= a_Qhash_primea Q)
$hyp "v'348" (= a_jhash_primea j)
$hyp "v'349" (= a_lhash_primea l)
$hyp "v'350" (= a_xhash_primea x)
$hyp "v'351" (= a_vhash_primea v)
$hyp "v'352" (= a_Mhash_primea
(TLA.subsetOf CDomain ((a_ca_1) (/\ (a_h022c5783954683bdcbcacced356fd6a a_ca_1)
(TLA.bEx M ((d_1) (TLA.bEx (TLA.SUBSET (hc4e622ce2e33ef1c6a9f10c01956cd d_1)) ((S) (TLA.bEx (Perm S) ((seq_1) (/\ (= (TLA.fapply a_ca_1 "sigma")
(Concat (TLA.fapply d_1 "sigma")
(TLA.Fcn (TLA.DOMAIN seq_1) ((k_1) (TLA.fapply v (TLA.fapply seq_1 k_1))))))
(TLA.bAll ProcSet ((q_1) (TLA.cond (TLA.in q_1
S) (= (TLA.fapply (TLA.fapply a_ca_1 "fres") q_1)
ACK) (= (TLA.fapply (TLA.fapply a_ca_1 "fres") q_1)
(TLA.fapply (TLA.fapply d_1 "fres") q_1))))))))))))))))
$goal (= (TLA.fapply a_ihash_primea q)
(TLA.fapply i q))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hb:"((((pc \\in FuncSet(ProcSet, {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))&((X \\in (Nat \\ {0}))&((Q \\in FuncSet((Nat \\ {0}), ((Nat \\ {0}) \\cup {BOT})))&((i \\in FuncSet(ProcSet, (Nat \\ {0})))&((j \\in FuncSet(ProcSet, (Nat \\ {0})))&((l \\in FuncSet(ProcSet, (Nat \\ {0})))&((x \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {BOT})))&((v \\in FuncSet(ProcSet, (Nat \\ {0})))&(M \\in SUBSET(subsetOf(CDomain, (\<lambda>a_ca. CFTypeOK(a_ca)))))))))))))&(a_Invunde_E2a&(a_Invunde_E3a&(a_Invunde_D2a&(a_Invunde_D3a&(a_Invunde_Qa&a_Invunde_Maina))))))&(Next|(a_h4fd5f73954dc53af536c1c75068837a=vars)))" (is "?z_hbc&?z_hdp")
 using v'209 by blast
 have z_Ht:"(a_ihash_primea=except(i, p, X))" (is "_=?z_hdv")
 using v'345 by blast
 have z_Hq:"((p~=q)&(p~=r))" (is "?z_hdx&?z_hdz")
 using v'342 by blast
 have z_Ho:"(q \\in ProcSet)" (is "?z_ho")
 using q_in by blast
 assume z_Hbb:"((a_ihash_primea[q])~=(i[q]))" (is "?z_heb~=?z_hec")
 have z_Hbc: "?z_hbc" (is "?z_hbd&?z_hde")
 by (rule zenon_and_0 [OF z_Hb])
 have z_Hbd: "?z_hbd" (is "?z_hbe&?z_hbr")
 by (rule zenon_and_0 [OF z_Hbc])
 have z_Hbr: "?z_hbr" (is "?z_hbs&?z_hby")
 by (rule zenon_and_1 [OF z_Hbd])
 have z_Hby: "?z_hby" (is "?z_hbz&?z_hcf")
 by (rule zenon_and_1 [OF z_Hbr])
 have z_Hcf: "?z_hcf" (is "?z_hcg&?z_hcj")
 by (rule zenon_and_1 [OF z_Hby])
 have z_Hcg: "?z_hcg"
 by (rule zenon_and_0 [OF z_Hcf])
 have z_Hdx: "?z_hdx"
 by (rule zenon_and_0 [OF z_Hq])
 have z_Hed: "(DOMAIN(i)=ProcSet)" (is "?z_hee=_")
 by (rule zenon_in_funcset_1 [of "i" "ProcSet" "(Nat \\ {0})", OF z_Hcg])
 have z_Hef: "((?z_hdv[q])~=?z_hec)" (is "?z_heg~=_")
 by (rule subst [where P="(\<lambda>zenon_Vwga. ((zenon_Vwga[q])~=?z_hec))", OF z_Ht z_Hbb])
 show FALSE
 proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vf. (zenon_Vf~=?z_hec))" "i" "p" "X" "q", OF z_Hef])
  assume z_Heo:"(q \\in ?z_hee)" (is "?z_heo")
  assume z_Hep:"(p=q)"
  assume z_Heq:"(X~=?z_hec)"
  show FALSE
  by (rule notE [OF z_Hdx z_Hep])
 next
  assume z_Heo:"(q \\in ?z_hee)" (is "?z_heo")
  assume z_Hdx:"?z_hdx"
  assume z_Her:"(?z_hec~=?z_hec)"
  show FALSE
  by (rule zenon_noteq [OF z_Her])
 next
  assume z_Hes:"(~(q \\in ?z_hee))" (is "~?z_heo")
  have z_Het: "(\\A zenon_Vpd:((zenon_Vpd \\in ?z_hee)<=>(zenon_Vpd \\in ProcSet)))" (is "\\A x : ?z_hey(x)")
  by (rule zenon_setequal_0 [of "?z_hee" "ProcSet", OF z_Hed])
  have z_Hez: "?z_hey(q)"
  by (rule zenon_all_0 [of "?z_hey" "q", OF z_Het])
  show FALSE
  proof (rule zenon_equiv [OF z_Hez])
   assume z_Hes:"(~?z_heo)"
   assume z_Hfa:"(~?z_ho)"
   show FALSE
   by (rule notE [OF z_Hfa z_Ho])
  next
   assume z_Heo:"?z_heo"
   assume z_Ho:"?z_ho"
   show FALSE
   by (rule notE [OF z_Hes z_Heo])
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2189"; *} qed
lemma ob'2250:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "(((((((pc) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & (((X) \<in> (((Nat) \\ ({((0))}))))) & (((Q) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((i) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((j) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((l) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((x) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((v) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((M) \<in> ((SUBSET (subsetOf((CDomain), %a_ca. ((CFTypeOK ((a_ca))))))))))) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'235: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'236: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'244: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'310: "((geq ((m), (k))))"
assumes v'311: "((geq ((m), (k))))"
assumes v'312: "(((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((v), (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))))))"
fixes q
assumes q_in : "(q \<in> (ProcSet))"
assumes v'331: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'332: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'333: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'334: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'335: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'336: "((((a_jhash_primea :: c)) = (j)))"
assumes v'337: "((((a_lhash_primea :: c)) = (l)))"
assumes v'338: "((((a_xhash_primea :: c)) = (x)))"
assumes v'339: "((((a_vhash_primea :: c)) = (v)))"
assumes v'340: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca_1. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca_1)) :: c)) & (\<exists> d_1 \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d_1)) :: c)))) : (\<exists> seq_1 \<in> ((Perm ((S)))) : ((((fapply ((a_ca_1), (''sigma''))) = ((Concat ((fapply ((d_1), (''sigma''))), ([ k_1 \<in> ((DOMAIN (seq_1)))  \<mapsto> (fapply ((v), (fapply ((seq_1), (k_1)))))])))))) & (\<forall> q_1 \<in> (ProcSet) : (cond((((q_1) \<in> (S))), (((fapply ((fapply ((a_ca_1), (''fres''))), (q_1))) = (ACK))), (((fapply ((fapply ((a_ca_1), (''fres''))), (q_1))) = (fapply ((fapply ((d_1), (''fres''))), (q_1)))))))))))))))))"
shows "(\<forall> r \<in> (ProcSet) : (((((fapply ((pc), (r))) = (''E2''))) \<Rightarrow> (((fapply ((i), (r))) = (fapply (((a_ihash_primea :: c)), (r))))))))"(is "PROP ?ob'2250")
proof -
ML_command {* writeln "*** TLAPS ENTER 2250"; *}
show "PROP ?ob'2250"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_e7d769.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_e7d769.znn.out
;; obligation #2250
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ (/\ (TLA.in pc
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in X (TLA.setminus arith.N (TLA.set 0))) (TLA.in Q
(TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in i (TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in j
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in l
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in x
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in v (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in M
(TLA.SUBSET (TLA.subsetOf CDomain ((a_ca) (CFTypeOK a_ca)))))) a_Invunde_E2a
a_Invunde_E3a a_Invunde_D2a a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina)
(\/ Next (= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'235" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'236" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'244" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$hyp "v'310" (arith.le k m)
$hyp "v'311" (arith.le k
m)
$hyp "v'312" (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z)))))))) (arith.add m
(arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))))
$hyp "q_in" (TLA.in q ProcSet)
$hyp "v'331" (= (TLA.fapply pc p) "E1")
$hyp "v'332" (= a_pchash_primea
(TLA.except pc p "E2"))
$hyp "v'333" (= a_ihash_primea
(TLA.except i p X))
$hyp "v'334" (= a_Xhash_primea (arith.add X
(TLA.fapply TLA.Succ 0)))
$hyp "v'335" (= a_Qhash_primea Q)
$hyp "v'336" (= a_jhash_primea j)
$hyp "v'337" (= a_lhash_primea l)
$hyp "v'338" (= a_xhash_primea x)
$hyp "v'339" (= a_vhash_primea v)
$hyp "v'340" (= a_Mhash_primea
(TLA.subsetOf CDomain ((a_ca_1) (/\ (a_h022c5783954683bdcbcacced356fd6a a_ca_1)
(TLA.bEx M ((d_1) (TLA.bEx (TLA.SUBSET (hc4e622ce2e33ef1c6a9f10c01956cd d_1)) ((S) (TLA.bEx (Perm S) ((seq_1) (/\ (= (TLA.fapply a_ca_1 "sigma")
(Concat (TLA.fapply d_1 "sigma")
(TLA.Fcn (TLA.DOMAIN seq_1) ((k_1) (TLA.fapply v (TLA.fapply seq_1 k_1))))))
(TLA.bAll ProcSet ((q_1) (TLA.cond (TLA.in q_1
S) (= (TLA.fapply (TLA.fapply a_ca_1 "fres") q_1)
ACK) (= (TLA.fapply (TLA.fapply a_ca_1 "fres") q_1)
(TLA.fapply (TLA.fapply d_1 "fres") q_1))))))))))))))))
$goal (TLA.bAll ProcSet ((r) (=> (= (TLA.fapply pc r) "E2")
(= (TLA.fapply i r)
(TLA.fapply a_ihash_primea r)))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hb:"((((pc \\in FuncSet(ProcSet, {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))&((X \\in (Nat \\ {0}))&((Q \\in FuncSet((Nat \\ {0}), ((Nat \\ {0}) \\cup {BOT})))&((i \\in FuncSet(ProcSet, (Nat \\ {0})))&((j \\in FuncSet(ProcSet, (Nat \\ {0})))&((l \\in FuncSet(ProcSet, (Nat \\ {0})))&((x \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {BOT})))&((v \\in FuncSet(ProcSet, (Nat \\ {0})))&(M \\in SUBSET(subsetOf(CDomain, (\<lambda>a_ca. CFTypeOK(a_ca)))))))))))))&(a_Invunde_E2a&(a_Invunde_E3a&(a_Invunde_D2a&(a_Invunde_D3a&(a_Invunde_Qa&a_Invunde_Maina))))))&(Next|(a_h4fd5f73954dc53af536c1c75068837a=vars)))" (is "?z_hz&?z_hdm")
 using v'209 by blast
 have z_Hq:"(a_ihash_primea=except(i, p, X))" (is "_=?z_hds")
 using v'333 by blast
 have z_Ho:"((pc[p])=''E1'')" (is "?z_hdu=?z_hbh")
 using v'331 by blast
 assume z_Hy:"(~bAll(ProcSet, (\<lambda>r. (((pc[r])=''E2'')=>((i[r])=(a_ihash_primea[r]))))))" (is "~?z_hdv")
 have z_Hz: "?z_hz" (is "?z_hba&?z_hdb")
 by (rule zenon_and_0 [OF z_Hb])
 have z_Hba: "?z_hba" (is "?z_hbb&?z_hbo")
 by (rule zenon_and_0 [OF z_Hz])
 have z_Hbo: "?z_hbo" (is "?z_hbp&?z_hbv")
 by (rule zenon_and_1 [OF z_Hba])
 have z_Hbv: "?z_hbv" (is "?z_hbw&?z_hcc")
 by (rule zenon_and_1 [OF z_Hbo])
 have z_Hcc: "?z_hcc" (is "?z_hcd&?z_hcg")
 by (rule zenon_and_1 [OF z_Hbv])
 have z_Hcd: "?z_hcd"
 by (rule zenon_and_0 [OF z_Hcc])
 have z_Hee_z_Hy: "(~(\\A x:((x \\in ProcSet)=>(((pc[x])=''E2'')=>((i[x])=(a_ihash_primea[x])))))) == (~?z_hdv)" (is "?z_hee == ?z_hy")
 by (unfold bAll_def)
 have z_Hee: "?z_hee" (is "~(\\A x : ?z_heo(x))")
 by (unfold z_Hee_z_Hy, fact z_Hy)
 have z_Hep: "(\\E x:(~((x \\in ProcSet)=>(((pc[x])=''E2'')=>((i[x])=(a_ihash_primea[x]))))))" (is "\\E x : ?z_her(x)")
 by (rule zenon_notallex_0 [of "?z_heo", OF z_Hee])
 have z_Hes: "?z_her((CHOOSE x:(~((x \\in ProcSet)=>(((pc[x])=''E2'')=>((i[x])=(a_ihash_primea[x])))))))" (is "~(?z_heu=>?z_hev)")
 by (rule zenon_ex_choose_0 [of "?z_her", OF z_Hep])
 have z_Heu: "?z_heu"
 by (rule zenon_notimply_0 [OF z_Hes])
 have z_Hew: "(~?z_hev)" (is "~(?z_hex=>?z_hey)")
 by (rule zenon_notimply_1 [OF z_Hes])
 have z_Hex: "?z_hex" (is "?z_hez=?z_hbi")
 by (rule zenon_notimply_0 [OF z_Hew])
 have z_Hfa: "((i[(CHOOSE x:(~((x \\in ProcSet)=>(((pc[x])=?z_hbi)=>((i[x])=(a_ihash_primea[x]))))))])~=(a_ihash_primea[(CHOOSE x:(~((x \\in ProcSet)=>(((pc[x])=?z_hbi)=>((i[x])=(a_ihash_primea[x]))))))]))" (is "?z_hfb~=?z_hfc")
 by (rule zenon_notimply_1 [OF z_Hew])
 have z_Hfd: "(?z_hbi~=?z_hbh)"
 by auto
 have z_Hfe: "(?z_hez~=?z_hdu)"
 by (rule zenon_stringdiffll [OF z_Hfd z_Hex z_Ho])
  have z_Hff: "(?z_hfb~=(?z_hds[(CHOOSE x:(~((x \\in ProcSet)=>(((pc[x])=?z_hbi)=>((i[x])=(a_ihash_primea[x]))))))]))" (is "_~=?z_hfg")
  by (rule subst [where P="(\<lambda>zenon_Vfz. (?z_hfb~=(zenon_Vfz[(CHOOSE x:(~((x \\in ProcSet)=>(((pc[x])=?z_hbi)=>((i[x])=(a_ihash_primea[x]))))))])))", OF z_Hq z_Hfa])
  have z_Hfl: "(DOMAIN(i)=ProcSet)" (is "?z_hfm=_")
  by (rule zenon_in_funcset_1 [of "i" "ProcSet" "(Nat \\ {0})", OF z_Hcd])
  show FALSE
  proof (rule zenon_noteq [of "?z_hdu"])
   have z_Hfn: "((CHOOSE x:(~((x \\in ProcSet)=>(((pc[x])=?z_hbi)=>((i[x])=(a_ihash_primea[x]))))))=p)" (is "?z_het=_")
   proof (rule zenon_nnpp [of "(?z_het=p)"])
    assume z_Hfo:"(?z_het~=p)"
    show FALSE
    proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vbc. (?z_hfb~=zenon_Vbc))" "i" "p" "X" "?z_het", OF z_Hff])
     assume z_Hfs:"(?z_het \\in ?z_hfm)" (is "?z_hfs")
     assume z_Hft:"(p=?z_het)"
     assume z_Hfu:"(?z_hfb~=X)"
     show FALSE
     by (rule zenon_eqsym [OF z_Hft z_Hfo])
    next
     assume z_Hfs:"(?z_het \\in ?z_hfm)" (is "?z_hfs")
     assume z_Hfv:"(p~=?z_het)"
     assume z_Hfw:"(?z_hfb~=?z_hfb)"
     show FALSE
     by (rule zenon_noteq [OF z_Hfw])
    next
     assume z_Hfx:"(~(?z_het \\in ?z_hfm))" (is "~?z_hfs")
     have z_Hfy: "(\\A zenon_Vpd:((zenon_Vpd \\in ?z_hfm)<=>(zenon_Vpd \\in ProcSet)))" (is "\\A x : ?z_hgd(x)")
     by (rule zenon_setequal_0 [of "?z_hfm" "ProcSet", OF z_Hfl])
     have z_Hge: "?z_hgd(?z_het)"
     by (rule zenon_all_0 [of "?z_hgd" "?z_het", OF z_Hfy])
     show FALSE
     proof (rule zenon_equiv [OF z_Hge])
      assume z_Hfx:"(~?z_hfs)"
      assume z_Hgf:"(~?z_heu)"
      show FALSE
      by (rule notE [OF z_Hgf z_Heu])
     next
      assume z_Hfs:"?z_hfs"
      assume z_Heu:"?z_heu"
      show FALSE
      by (rule notE [OF z_Hfx z_Hfs])
     qed
    qed
   qed
   have z_Hgg: "(?z_hdu~=?z_hdu)"
   by (rule subst [where P="(\<lambda>zenon_Vgz. ((pc[zenon_Vgz])~=?z_hdu))", OF z_Hfn], fact z_Hfe)
   thus "(?z_hdu~=?z_hdu)" .
  qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2250"; *} qed
lemma ob'2246:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'311: "((geq ((m), (k))))"
assumes v'312: "((geq ((m), (k))))"
assumes v'313: "(((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((v), (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))))))"
fixes q
assumes q_in : "(q \<in> (ProcSet))"
assumes v'330: "(\<exists> r \<in> (ProcSet) : (((((fapply (((a_pchash_primea :: c)), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))))))"
assumes v'331: "(\<forall> q_1 \<in> (ProcSet) : (((((fapply (((a_pchash_primea :: c)), (q_1))) = (''E2''))) \<Leftrightarrow> (((((((q_1) = (p))) \<and> (((fapply (((a_ihash_primea :: c)), (q_1))) = (X))))) \<or> (((((fapply ((pc), (q_1))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q_1))) = (fapply ((i), (q_1))))))))))))"
shows "(\<exists> r \<in> (ProcSet) : (((((((r) = (p))) \<and> (((fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))) = (X))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))))))))"(is "PROP ?ob'2246")
proof -
ML_command {* writeln "*** TLAPS ENTER 2246"; *}
show "PROP ?ob'2246"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_be0b7d.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_be0b7d.znn.out
;; obligation #2246
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$hyp "v'311" (arith.le k m)
$hyp "v'312" (arith.le k
m)
$hyp "v'313" (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z)))))))) (arith.add m
(arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))))
$hyp "q_in" (TLA.in q ProcSet)
$hyp "v'330" (TLA.bEx ProcSet ((r) (/\ (= (TLA.fapply a_pchash_primea r)
"E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.fapply seq (arith.add z
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) (arith.add m
(arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))))))
$hyp "v'331" (TLA.bAll ProcSet ((q_1) (<=> (= (TLA.fapply a_pchash_primea q_1)
"E2") (\/ (/\ (= q_1 p) (= (TLA.fapply a_ihash_primea q_1) X))
(/\ (= (TLA.fapply pc q_1) "E2") (= (TLA.fapply a_ihash_primea q_1)
(TLA.fapply i q_1)))))))
$goal (TLA.bEx ProcSet ((r) (\/ (/\ (= r p)
(= (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.fapply seq (arith.add z
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) (arith.add m
(arith.minus (arith.add k (arith.minus (TLA.fapply TLA.Succ 0)))))) X))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.fapply seq (arith.add z
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) (arith.add m
(arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Ho:"bEx(ProcSet, (\<lambda>r. (((a_pchash_primea[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))))" (is "?z_ho")
 using v'330 by blast
 have z_Hc:"(p \\in ProcSet)" (is "?z_hc")
 using p_in by blast
 have z_Hp:"bAll(ProcSet, (\<lambda>q_1. (((a_pchash_primea[q_1])=''E2'')<=>(((q_1=p)&((a_ihash_primea[q_1])=X))|(((pc[q_1])=''E2'')&((a_ihash_primea[q_1])=(i[q_1])))))))" (is "?z_hp")
 using v'331 by blast
 have zenon_L1_: "(~(((pc[(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))))])=''E2'')&((a_ihash_primea[(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))))])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))) ==> ((a_ihash_primea[(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))))])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])) ==> ((a_pchash_primea[(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))))])=''E2'') ==> (X~=(a_ihash_primea[(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))))])) ==> ((CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))) \\in ProcSet) ==> (\\A x:((x \\in ProcSet)=>(((a_pchash_primea[x])=''E2'')<=>(((x=p)&((a_ihash_primea[x])=X))|(((pc[x])=''E2'')&((a_ihash_primea[x])=(i[x]))))))) ==> FALSE" (is "?z_hcn ==> ?z_hda ==> ?z_hdc ==> ?z_hde ==> ?z_hdf ==> ?z_hdg ==> FALSE")
 proof -
  assume z_Hcn:"?z_hcn" (is "~(?z_hcp&_)")
  assume z_Hda:"?z_hda" (is "?z_hdb=?z_hbc")
  assume z_Hdc:"?z_hdc" (is "?z_hdd=?z_hy")
  assume z_Hde:"?z_hde"
  assume z_Hdf:"?z_hdf"
  assume z_Hdg:"?z_hdg" (is "\\A x : ?z_hds(x)")
  show FALSE
  proof (rule zenon_notand [OF z_Hcn])
   assume z_Hdt:"((pc[(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=?z_hy)&((a_ihash_primea[x])=?z_hbc))))])~=?z_hy)" (is "?z_hcq~=_")
   have z_Hdu: "?z_hds((CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=?z_hy)&((a_ihash_primea[x])=?z_hbc)))))" (is "_=>?z_hdv")
   by (rule zenon_all_0 [of "?z_hds" "(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=?z_hy)&((a_ihash_primea[x])=?z_hbc))))", OF z_Hdg])
   show FALSE
   proof (rule zenon_imply [OF z_Hdu])
    assume z_Hdw:"(~?z_hdf)"
    show FALSE
    by (rule notE [OF z_Hdw z_Hdf])
   next
    assume z_Hdv:"?z_hdv" (is "_<=>?z_hdx")
    show FALSE
    proof (rule zenon_equiv [OF z_Hdv])
     assume z_Hdy:"(?z_hdd~=?z_hy)"
     assume z_Hdz:"(~?z_hdx)" (is "~(?z_hea|?z_heb)")
     show FALSE
     by (rule notE [OF z_Hdy z_Hdc])
    next
     assume z_Hdc:"?z_hdc"
     assume z_Hdx:"?z_hdx" (is "?z_hea|?z_heb")
     show FALSE
     proof (rule zenon_or [OF z_Hdx])
      assume z_Hea:"?z_hea" (is "?z_hec&?z_hed")
      have z_Hed: "?z_hed"
      by (rule zenon_and_1 [OF z_Hea])
      show FALSE
      by (rule zenon_eqsym [OF z_Hed z_Hde])
     next
      assume z_Heb:"?z_heb" (is "_&?z_hee")
      have z_Hcp: "?z_hcp"
      by (rule zenon_and_0 [OF z_Heb])
      show FALSE
      by (rule notE [OF z_Hdt z_Hcp])
     qed
    qed
   qed
  next
   assume z_Hef:"(?z_hdb~=?z_hbc)"
   show FALSE
   by (rule notE [OF z_Hef z_Hda])
  qed
 qed
 have zenon_L2_: "((a_ihash_primea[(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))))])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])) ==> ((a_pchash_primea[(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))))])=''E2'') ==> (\\A x:((x \\in ProcSet)=>(((a_pchash_primea[x])=''E2'')<=>(((x=p)&((a_ihash_primea[x])=X))|(((pc[x])=''E2'')&((a_ihash_primea[x])=(i[x]))))))) ==> ((CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))) \\in ProcSet) ==> (~(\\E x:((x \\in ProcSet)&(((x=p)&((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])=X))|(((pc[x])=''E2'')&((a_ihash_primea[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))))) ==> ((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])~=X) ==> FALSE" (is "?z_hda ==> ?z_hdc ==> ?z_hdg ==> ?z_hdf ==> ?z_heg ==> ?z_hen ==> FALSE")
 proof -
  assume z_Hda:"?z_hda" (is "?z_hdb=?z_hbc")
  assume z_Hdc:"?z_hdc" (is "?z_hdd=?z_hy")
  assume z_Hdg:"?z_hdg" (is "\\A x : ?z_hds(x)")
  assume z_Hdf:"?z_hdf"
  assume z_Heg:"?z_heg" (is "~(\\E x : ?z_heo(x))")
  assume z_Hen:"?z_hen"
  show FALSE
  proof (rule zenon_em [of "(X=X)"])
   assume z_Hep:"(X=X)"
   show FALSE
   proof (rule notE [OF z_Hen])
    have z_Heq: "(X=?z_hbc)"
    proof (rule zenon_nnpp [of "(X=?z_hbc)"])
     assume z_Her:"(X~=?z_hbc)"
     show FALSE
     proof (rule notE [OF z_Her])
      have z_Hed: "(?z_hdb=X)"
      proof (rule zenon_nnpp [of "(?z_hdb=X)"])
       assume z_Hes:"(?z_hdb~=X)"
       show FALSE
       proof (rule zenon_em [of "(X=X)"])
        assume z_Hep:"(X=X)"
        show FALSE
        proof (rule notE [OF z_Hes])
         have z_Het: "(X=?z_hdb)"
         proof (rule zenon_nnpp [of "(X=?z_hdb)"])
          assume z_Hde:"(X~=?z_hdb)"
          have z_Heu: "~?z_heo((CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=?z_hy)&((a_ihash_primea[x])=?z_hbc)))))" (is "~(_&?z_hev)")
          by (rule zenon_notex_0 [of "?z_heo" "(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=?z_hy)&((a_ihash_primea[x])=?z_hbc))))", OF z_Heg])
          show FALSE
          proof (rule zenon_notand [OF z_Heu])
           assume z_Hdw:"(~?z_hdf)"
           show FALSE
           by (rule notE [OF z_Hdw z_Hdf])
          next
           assume z_Hew:"(~?z_hev)" (is "~(?z_hex|?z_hco)")
           have z_Hcn: "(~?z_hco)" (is "~(?z_hcp&_)")
           by (rule zenon_notor_1 [OF z_Hew])
           show FALSE
           by (rule zenon_L1_ [OF z_Hcn z_Hda z_Hdc z_Hde z_Hdf z_Hdg])
          qed
         qed
         have z_Hed: "(?z_hdb=X)"
         by (rule subst [where P="(\<lambda>zenon_Vwp. (zenon_Vwp=X))", OF z_Het], fact z_Hep)
         thus "(?z_hdb=X)" .
        qed
       next
        assume z_Hfb:"(X~=X)"
        show FALSE
        by (rule zenon_noteq [OF z_Hfb])
       qed
      qed
      have z_Heq: "(X=?z_hbc)"
      by (rule subst [where P="(\<lambda>zenon_Vxp. (zenon_Vxp=?z_hbc))", OF z_Hed], fact z_Hda)
      thus "(X=?z_hbc)" .
     qed
    qed
    have z_Hel: "(?z_hbc=X)"
    by (rule subst [where P="(\<lambda>zenon_Vwp. (zenon_Vwp=X))", OF z_Heq], fact z_Hep)
    thus "(?z_hbc=X)" .
   qed
  next
   assume z_Hfb:"(X~=X)"
   show FALSE
   by (rule zenon_noteq [OF z_Hfb])
  qed
 qed
 assume z_Hq:"(~bEx(ProcSet, (\<lambda>r. (((r=p)&((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])=X))|(((pc[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))))))" (is "~?z_hff")
 have z_Hfn_z_Ho: "(\\E x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))) == ?z_ho" (is "?z_hfn == _")
 by (unfold bEx_def)
 have z_Hfn: "?z_hfn" (is "\\E x : ?z_hfo(x)")
 by (unfold z_Hfn_z_Ho, fact z_Ho)
 have z_Hfp: "?z_hfo((CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))))" (is "?z_hdf&?z_hfq")
 by (rule zenon_ex_choose_0 [of "?z_hfo", OF z_Hfn])
 have z_Hdf: "?z_hdf"
 by (rule zenon_and_0 [OF z_Hfp])
 have z_Hfq: "?z_hfq" (is "?z_hdc&?z_hda")
 by (rule zenon_and_1 [OF z_Hfp])
 have z_Hdc: "?z_hdc" (is "?z_hdd=?z_hy")
 by (rule zenon_and_0 [OF z_Hfq])
 have z_Hda: "?z_hda" (is "?z_hdb=?z_hbc")
 by (rule zenon_and_1 [OF z_Hfq])
 have z_Hdg_z_Hp: "(\\A x:((x \\in ProcSet)=>(((a_pchash_primea[x])=?z_hy)<=>(((x=p)&((a_ihash_primea[x])=X))|(((pc[x])=?z_hy)&((a_ihash_primea[x])=(i[x]))))))) == ?z_hp" (is "?z_hdg == _")
 by (unfold bAll_def)
 have z_Hdg: "?z_hdg" (is "\\A x : ?z_hds(x)")
 by (unfold z_Hdg_z_Hp, fact z_Hp)
 have z_Heg_z_Hq: "(~(\\E x:((x \\in ProcSet)&(((x=p)&(?z_hbc=X))|(((pc[x])=?z_hy)&((a_ihash_primea[x])=?z_hbc)))))) == (~?z_hff)" (is "?z_heg == ?z_hq")
 by (unfold bEx_def)
 have z_Heg: "?z_heg" (is "~(\\E x : ?z_heo(x))")
 by (unfold z_Heg_z_Hq, fact z_Hq)
 have z_Hfr: "~?z_heo(p)" (is "~(_&?z_hfs)")
 by (rule zenon_notex_0 [of "?z_heo" "p", OF z_Heg])
 show FALSE
 proof (rule zenon_notand [OF z_Hfr])
  assume z_Hft:"(~?z_hc)"
  show FALSE
  by (rule notE [OF z_Hft z_Hc])
 next
  assume z_Hfu:"(~?z_hfs)" (is "~(?z_hfv|?z_hfw)")
  have z_Hfx: "(~?z_hfv)" (is "~(?z_hfy&?z_hel)")
  by (rule zenon_notor_0 [OF z_Hfu])
  show FALSE
  proof (rule zenon_notand [OF z_Hfx])
   assume z_Hfz:"(p~=p)"
   show FALSE
   by (rule zenon_noteq [OF z_Hfz])
  next
   assume z_Hen:"(?z_hbc~=X)"
   show FALSE
   by (rule zenon_L2_ [OF z_Hda z_Hdc z_Hdg z_Hdf z_Heg z_Hen])
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2246"; *} qed
lemma ob'2239:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'311: "((geq ((m), (k))))"
assumes v'312: "((geq ((m), (k))))"
assumes v'313: "(((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((v), (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))))))"
fixes q
assumes q_in : "(q \<in> (ProcSet))"
assumes v'328: "((((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))) \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))))"
assumes v'329: "(((fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))) = (fapply ((seq), (m)))))"
shows "(((fapply ((v), (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))) = (fapply ((v), (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))))))))))))))"(is "PROP ?ob'2239")
proof -
ML_command {* writeln "*** TLAPS ENTER 2239"; *}
show "PROP ?ob'2239"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_26a950.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_26a950.znn.out
;; obligation #2239
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$hyp "v'311" (arith.le k m)
$hyp "v'312" (arith.le k
m)
$hyp "v'313" (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z)))))))) (arith.add m
(arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))))
$hyp "q_in" (TLA.in q ProcSet)
$hyp "v'328" (TLA.in (arith.add m (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))
(arith.intrange (TLA.fapply TLA.Succ 0) (arith.add (Cardinality A)
(arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))))
$hyp "v'329" (= (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.fapply seq (arith.add z
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) (arith.add m
(arith.minus (arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))
(TLA.fapply seq m))
$goal (= (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z)))))))) (arith.add m
(arith.minus (arith.add k (arith.minus (TLA.fapply TLA.Succ 0)))))))
(TLA.fapply v (TLA.bChoice ProcSet ((r) (\/ (/\ (= r p) (= X
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.fapply seq (arith.add z
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) (arith.add m
(arith.minus (arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.fapply seq (arith.add z
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) (arith.add m
(arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))))))))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Ho:"((m +  -.((k +  -.(1)))) \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))" (is "?z_ho")
 using v'328 by blast
 assume z_Hq:"((v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[(m +  -.((k +  -.(1))))])])~=(v[bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))))]))" (is "?z_hbc~=?z_hch")
 show FALSE
 proof (rule zenon_noteq [of "?z_hch"])
  have z_Hcq: "((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[(m +  -.((k +  -.(1))))])=bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))))))" (is "?z_hbe=?z_hci")
  proof (rule zenon_nnpp [of "(?z_hbe=?z_hci)"])
   assume z_Hcr:"(?z_hbe~=?z_hci)"
   have z_Hcs_z_Hcr: "(?z_hbe~=(CHOOSE x:((x \\in ProcSet)&(((x=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))|(((pc[x])=''E2'')&((i[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))))) == (?z_hbe~=?z_hci)" (is "?z_hcs == ?z_hcr")
   by (unfold bChoose_def)
   have z_Hcs: "?z_hcs" (is "_~=?z_hct")
   by (unfold z_Hcs_z_Hcr, fact z_Hcr)
   show FALSE
   proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vob. (zenon_Vob~=?z_hct))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))))))" "(m +  -.((k +  -.(1))))", OF z_Hcs])
    assume z_Hdi:"(~?z_ho)"
    show FALSE
    by (rule notE [OF z_Hdi z_Ho])
   next
    assume z_Hdj:"(?z_hci~=?z_hct)"
    have z_Hdk_z_Hdj: "(?z_hct~=?z_hct) == (?z_hci~=?z_hct)" (is "?z_hdk == ?z_hdj")
    by (unfold bChoose_def)
    have z_Hdk: "?z_hdk"
    by (unfold z_Hdk_z_Hdj, fact z_Hdj)
    show FALSE
    by (rule zenon_noteq [OF z_Hdk])
   qed
  qed
  have z_Hdl: "(?z_hch~=?z_hch)"
  by (rule subst [where P="(\<lambda>zenon_Vf. ((v[zenon_Vf])~=?z_hch))", OF z_Hcq], fact z_Hq)
  thus "(?z_hch~=?z_hch)" .
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2239"; *} qed
lemma ob'2224:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'311: "((geq ((m), (k))))"
assumes v'312: "((geq ((m), (k))))"
assumes v'313: "(((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((v), (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))))))"
assumes v'321: "(((fapply (([ m_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (m_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (m_1)))))>>,(fapply ((v), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m_1)))))))))))))]), (m))) = (fapply ((v), (bChoice((ProcSet), %q. (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m)))))))))))))"
assumes v'322: "(\<exists> q \<in> (ProcSet) : (((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m))))))))"
shows "(\<exists> q \<in> (ProcSet) : (((((((fapply (((a_pchash_primea :: c)), (q))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q))) = (fapply ((seq), (m))))))) \<and> (((fapply (([ m_1 \<in> ((DOMAIN (seq)))  \<mapsto> (CaseOther(<<(((fapply ((Q), (fapply ((seq), (m_1))))) \<noteq> (BOT)))>>,<<(fapply ((Q), (fapply ((seq), (m_1)))))>>,(fapply ((v), (bChoice((ProcSet), %q_1. (((((fapply (((a_pchash_primea :: c)), (q_1))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (q_1))) = (fapply ((seq), (m_1)))))))))))))]), (m))) = (fapply ((v), (q))))))))"(is "PROP ?ob'2224")
proof -
ML_command {* writeln "*** TLAPS ENTER 2224"; *}
show "PROP ?ob'2224"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_139d96.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_139d96.znn.out
;; obligation #2224
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$hyp "v'311" (arith.le k m)
$hyp "v'312" (arith.le k
m)
$hyp "v'313" (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z)))))))) (arith.add m
(arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))))
$hyp "v'321" (= (TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((m_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq m_1))
BOT)) (TLA.fapply Q (TLA.fapply seq m_1)) (TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q) (TLA.fapply seq m_1))))))))) m)
(TLA.fapply v (TLA.bChoice ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq m)))))))
$hyp "v'322" (TLA.bEx ProcSet ((q) (/\ (= (TLA.fapply a_pchash_primea q)
"E2") (= (TLA.fapply a_ihash_primea q)
(TLA.fapply seq m)))))
$goal (TLA.bEx ProcSet ((q) (/\ (/\ (= (TLA.fapply a_pchash_primea q) "E2")
(= (TLA.fapply a_ihash_primea q) (TLA.fapply seq m)))
(= (TLA.fapply (TLA.Fcn (TLA.DOMAIN seq) ((m_1) (TLA.CASE (-. (= (TLA.fapply Q (TLA.fapply seq m_1))
BOT)) (TLA.fapply Q (TLA.fapply seq m_1)) (TLA.fapply v (TLA.bChoice ProcSet ((q_1) (/\ (= (TLA.fapply a_pchash_primea q_1)
"E2") (= (TLA.fapply a_ihash_primea q_1) (TLA.fapply seq m_1))))))))) m)
(TLA.fapply v q)))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Ho:"bEx(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))))" (is "?z_ho")
 using v'322 by blast
 have z_Hn:"((Fcn(DOMAIN(seq), (\<lambda>m_1. (CASE ((Q[(seq[m_1])])~=BOT) -> (Q[(seq[m_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m_1])))))]))))[m])=(v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))))]))" (is "?z_hbe=?z_hbv")
 using v'321 by blast
 have z_Hk:"(m \\in DOMAIN(seq))" (is "?z_hk")
 using m_in by blast
 have zenon_L1_: "(?z_hbv~=(v[(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(seq[m])))))])) ==> FALSE" (is "?z_hbx ==> FALSE")
 proof -
  assume z_Hbx:"?z_hbx" (is "_~=?z_hby")
  have z_Hci_z_Hbx: "(?z_hby~=?z_hby) == ?z_hbx" (is "?z_hci == _")
  by (unfold bChoose_def)
  have z_Hci: "?z_hci"
  by (unfold z_Hci_z_Hbx, fact z_Hbx)
  show FALSE
  by (rule zenon_noteq [OF z_Hci])
 qed
 have zenon_L2_: "((~((Q[(seq[m])])~=BOT))&TRUE) ==> (~(\\E x:((x \\in ProcSet)&((((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(seq[m])))&(?z_hbe=(v[x])))))) ==> ((CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(seq[m]))))) \\in ProcSet) ==> ((a_pchash_primea[(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(seq[m])))))])=''E2'') ==> ((a_ihash_primea[(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(seq[m])))))])=(seq[m])) ==> ?z_hk ==> FALSE" (is "?z_hcj ==> ?z_hco ==> ?z_hcu ==> ?z_hcv ==> ?z_hcx ==> _ ==> FALSE")
 proof -
  assume z_Hcj:"?z_hcj" (is "?z_hck&?z_hcn")
  assume z_Hco:"?z_hco" (is "~(\\E x : ?z_hcz(x))")
  assume z_Hcu:"?z_hcu"
  assume z_Hcv:"?z_hcv" (is "?z_hcw=?z_hx")
  assume z_Hcx:"?z_hcx" (is "?z_hcy=?z_hbb")
  assume z_Hk:"?z_hk"
  have z_Hck: "?z_hck" (is "~~?z_hda")
  by (rule zenon_and_0 [OF z_Hcj])
  have z_Hda: "?z_hda" (is "?z_hcm=_")
  by (rule zenon_notnot_0 [OF z_Hck])
  have z_Hdb: "~?z_hcz((CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=?z_hx)&((a_ihash_primea[x])=?z_hbb)))))" (is "~(_&?z_hdc)")
  by (rule zenon_notex_0 [of "?z_hcz" "(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=?z_hx)&((a_ihash_primea[x])=?z_hbb))))", OF z_Hco])
  show FALSE
  proof (rule zenon_notand [OF z_Hdb])
   assume z_Hdd:"(~?z_hcu)"
   show FALSE
   by (rule notE [OF z_Hdd z_Hcu])
  next
   assume z_Hde:"(~?z_hdc)" (is "~(?z_hdf&?z_hdg)")
   show FALSE
   proof (rule zenon_notand [OF z_Hde])
    assume z_Hdh:"(~?z_hdf)"
    show FALSE
    proof (rule zenon_notand [OF z_Hdh])
     assume z_Hdi:"(?z_hcw~=?z_hx)"
     show FALSE
     by (rule notE [OF z_Hdi z_Hcv])
    next
     assume z_Hdj:"(?z_hcy~=?z_hbb)"
     show FALSE
     by (rule notE [OF z_Hdj z_Hcx])
    qed
   next
    assume z_Hdk:"(?z_hbe~=(v[(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=?z_hx)&((a_ihash_primea[x])=?z_hbb))))]))" (is "_~=?z_hby")
    show FALSE
    proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vqc. (zenon_Vqc~=?z_hby))" "DOMAIN(seq)" "(\<lambda>m_1. (CASE ((Q[(seq[m_1])])~=BOT) -> (Q[(seq[m_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=?z_hx)&((a_ihash_primea[q])=(seq[m_1])))))])))" "m", OF z_Hdk])
     assume z_Hdo:"(~?z_hk)"
     show FALSE
     by (rule notE [OF z_Hdo z_Hk])
    next
     assume z_Hdp:"((CASE (?z_hcm~=BOT) -> ?z_hcm [] OTHER -> ?z_hbv)~=?z_hby)" (is "?z_hdq~=_")
     show FALSE
     proof (rule zenon_caseother1 [of "(\<lambda>zenon_Vqc. (zenon_Vqc~=?z_hby))", OF z_Hdp])
      assume z_Hcl:"(?z_hcm~=BOT)"
      assume z_Hdr:"(?z_hcm~=?z_hby)"
      show FALSE
      by (rule notE [OF z_Hcl z_Hda])
     next
      assume z_Hcj:"?z_hcj"
      assume z_Hbx:"(?z_hbv~=?z_hby)"
      show FALSE
      by (rule zenon_L1_ [OF z_Hbx])
     qed
    qed
   qed
  qed
 qed
 assume z_Hp:"(~bEx(ProcSet, (\<lambda>q. ((((a_pchash_primea[q])=''E2'')&((a_ihash_primea[q])=(seq[m])))&(?z_hbe=(v[q]))))))" (is "~?z_hds")
 have z_Hdx_z_Ho: "(\\E x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(seq[m]))))) == ?z_ho" (is "?z_hdx == _")
 by (unfold bEx_def)
 have z_Hdx: "?z_hdx" (is "\\E x : ?z_hdy(x)")
 by (unfold z_Hdx_z_Ho, fact z_Ho)
 have z_Hdz: "?z_hdy((CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=''E2'')&((a_ihash_primea[x])=(seq[m]))))))" (is "?z_hcu&?z_hdf")
 by (rule zenon_ex_choose_0 [of "?z_hdy", OF z_Hdx])
 have z_Hcu: "?z_hcu"
 by (rule zenon_and_0 [OF z_Hdz])
 have z_Hdf: "?z_hdf" (is "?z_hcv&?z_hcx")
 by (rule zenon_and_1 [OF z_Hdz])
 have z_Hcv: "?z_hcv" (is "?z_hcw=?z_hx")
 by (rule zenon_and_0 [OF z_Hdf])
 have z_Hcx: "?z_hcx" (is "?z_hcy=?z_hbb")
 by (rule zenon_and_1 [OF z_Hdf])
 have z_Hco_z_Hp: "(~(\\E x:((x \\in ProcSet)&((((a_pchash_primea[x])=?z_hx)&((a_ihash_primea[x])=?z_hbb))&(?z_hbe=(v[x])))))) == (~?z_hds)" (is "?z_hco == ?z_hp")
 by (unfold bEx_def)
 have z_Hco: "?z_hco" (is "~(\\E x : ?z_hcz(x))")
 by (unfold z_Hco_z_Hp, fact z_Hp)
 show FALSE
 proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vh. (zenon_Vh=?z_hbv))" "DOMAIN(seq)" "(\<lambda>m_1. (CASE ((Q[(seq[m_1])])~=BOT) -> (Q[(seq[m_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=?z_hx)&((a_ihash_primea[q])=(seq[m_1])))))])))" "m", OF z_Hn])
  assume z_Hdo:"(~?z_hk)"
  show FALSE
  by (rule notE [OF z_Hdo z_Hk])
 next
  assume z_Hed:"((CASE ((Q[?z_hbb])~=BOT) -> (Q[?z_hbb]) [] OTHER -> ?z_hbv)=?z_hbv)" (is "?z_hdq=_")
  show FALSE
  proof (rule zenon_caseother1 [of "(\<lambda>zenon_Vh. (zenon_Vh=?z_hbv))", OF z_Hed])
   assume z_Hcl:"((Q[?z_hbb])~=BOT)" (is "?z_hcm~=_")
   assume z_Hee:"(?z_hcm=?z_hbv)"
   have z_Hef_z_Hee: "(?z_hcm=(v[(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=?z_hx)&((a_ihash_primea[x])=?z_hbb))))])) == (?z_hcm=?z_hbv)" (is "?z_hef == ?z_hee")
   by (unfold bChoose_def)
   have z_Hef: "?z_hef" (is "_=?z_hby")
   by (unfold z_Hef_z_Hee, fact z_Hee)
   have z_Hdb: "~?z_hcz((CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=?z_hx)&((a_ihash_primea[x])=?z_hbb)))))" (is "~(_&?z_hdc)")
   by (rule zenon_notex_0 [of "?z_hcz" "(CHOOSE x:((x \\in ProcSet)&(((a_pchash_primea[x])=?z_hx)&((a_ihash_primea[x])=?z_hbb))))", OF z_Hco])
   show FALSE
   proof (rule zenon_notand [OF z_Hdb])
    assume z_Hdd:"(~?z_hcu)"
    show FALSE
    by (rule notE [OF z_Hdd z_Hcu])
   next
    assume z_Hde:"(~?z_hdc)" (is "~(_&?z_hdg)")
    show FALSE
    proof (rule zenon_notand [OF z_Hde])
     assume z_Hdh:"(~?z_hdf)"
     show FALSE
     proof (rule zenon_notand [OF z_Hdh])
      assume z_Hdi:"(?z_hcw~=?z_hx)"
      show FALSE
      by (rule notE [OF z_Hdi z_Hcv])
     next
      assume z_Hdj:"(?z_hcy~=?z_hbb)"
      show FALSE
      by (rule notE [OF z_Hdj z_Hcx])
     qed
    next
     assume z_Hdk:"(?z_hbe~=?z_hby)"
     show FALSE
     proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vqc. (zenon_Vqc~=?z_hby))" "DOMAIN(seq)" "(\<lambda>m_1. (CASE ((Q[(seq[m_1])])~=BOT) -> (Q[(seq[m_1])]) [] OTHER -> (v[bChoice(ProcSet, (\<lambda>q. (((a_pchash_primea[q])=?z_hx)&((a_ihash_primea[q])=(seq[m_1])))))])))" "m", OF z_Hdk])
      assume z_Hdo:"(~?z_hk)"
      show FALSE
      by (rule notE [OF z_Hdo z_Hk])
     next
      assume z_Hdp:"(?z_hdq~=?z_hby)"
      show FALSE
      proof (rule zenon_caseother1 [of "(\<lambda>zenon_Vqc. (zenon_Vqc~=?z_hby))", OF z_Hdp])
       assume z_Hcl:"(?z_hcm~=BOT)"
       assume z_Hdr:"(?z_hcm~=?z_hby)"
       show FALSE
       by (rule notE [OF z_Hdr z_Hef])
      next
       assume z_Hcj:"((~(?z_hcm~=BOT))&TRUE)" (is "?z_hck&?z_hcn")
       assume z_Hbx:"(?z_hbv~=?z_hby)"
       show FALSE
       by (rule zenon_L1_ [OF z_Hbx])
      qed
     qed
    qed
   qed
  next
   assume z_Hcj:"((~((Q[?z_hbb])~=BOT))&TRUE)" (is "?z_hck&?z_hcn")
   assume z_Heg:"(?z_hbv=?z_hbv)"
   show FALSE
   by (rule zenon_L2_ [OF z_Hcj z_Hco z_Hcu z_Hcv z_Hcx z_Hk])
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2224"; *} qed
lemma ob'2282:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes q
assumes q_in : "(q \<in> (ProcSet))"
assumes v'296: "(\<forall> a \<in> (A) : (((a) \<in> (((setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z))))) \<union> (setOfAll((setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))), %r. (fapply (((a_ihash_primea :: c)), (r))))))))))"
assumes v'297: "(\<forall> b \<in> (((setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z))))) \<union> (setOfAll((setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))), %r. (fapply (((a_ihash_primea :: c)), (r))))))) : (((b) \<in> (A))))"
shows "(((A) = (((setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z))))) \<union> (setOfAll((setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))), %r. (fapply (((a_ihash_primea :: c)), (r)))))))))"(is "PROP ?ob'2282")
proof -
ML_command {* writeln "*** TLAPS ENTER 2282"; *}
show "PROP ?ob'2282"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_7532df.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_7532df.znn.out
;; obligation #2282
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "q_in" (TLA.in q ProcSet)
$hyp "v'296" (TLA.bAll A ((a) (TLA.in a
(TLA.cup (TLA.setOfAll (arith.intrange (TLA.fapply TLA.Succ 0) (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z)))
(TLA.setOfAll (TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))) ((r) (TLA.fapply a_ihash_primea r)))))))
$hyp "v'297" (TLA.bAll (TLA.cup (TLA.setOfAll (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z)))
(TLA.setOfAll (TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))) ((r) (TLA.fapply a_ihash_primea r)))) ((b) (TLA.in b
A)))
$goal (= A (TLA.cup (TLA.setOfAll (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z)))
(TLA.setOfAll (TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))) ((r) (TLA.fapply a_ihash_primea r)))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hl:"bAll(A, (\<lambda>a. (a \\in (setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))) \\cup setOfAll(setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))), (\<lambda>r. (a_ihash_primea[r])))))))" (is "?z_hl")
 using v'296 by blast
 have z_Hm:"bAll((setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))) \\cup setOfAll(setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))), (\<lambda>r. (a_ihash_primea[r])))), (\<lambda>b. (b \\in A)))" (is "?z_hm")
 using v'297 by blast
 assume z_Hn:"(A~=(setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))) \\cup setOfAll(setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))), (\<lambda>r. (a_ihash_primea[r])))))" (is "_~=?z_hs")
 have z_Hcs_z_Hl: "(\\A x:((x \\in A)=>(x \\in ?z_hs))) == ?z_hl" (is "?z_hcs == _")
 by (unfold bAll_def)
 have z_Hcs: "?z_hcs" (is "\\A x : ?z_hcx(x)")
 by (unfold z_Hcs_z_Hl, fact z_Hl)
 have z_Hcy_z_Hm: "(\\A x:((x \\in ?z_hs)=>(x \\in A))) == ?z_hm" (is "?z_hcy == _")
 by (unfold bAll_def)
 have z_Hcy: "?z_hcy" (is "\\A x : ?z_hda(x)")
 by (unfold z_Hcy_z_Hm, fact z_Hm)
 have z_Hdb: "(~(\\A zenon_Vg:((zenon_Vg \\in A)<=>(zenon_Vg \\in ?z_hs))))" (is "~(\\A x : ?z_hdh(x))")
 by (rule zenon_notsetequal_0 [of "A" "?z_hs", OF z_Hn])
 have z_Hdi: "(\\E zenon_Vg:(~((zenon_Vg \\in A)<=>(zenon_Vg \\in ?z_hs))))" (is "\\E x : ?z_hdk(x)")
 by (rule zenon_notallex_0 [of "?z_hdh", OF z_Hdb])
 have z_Hdl: "?z_hdk((CHOOSE zenon_Vg:(~((zenon_Vg \\in A)<=>(zenon_Vg \\in ?z_hs)))))" (is "~(?z_hdn<=>?z_hdo)")
 by (rule zenon_ex_choose_0 [of "?z_hdk", OF z_Hdi])
 show FALSE
 proof (rule zenon_notequiv [OF z_Hdl])
  assume z_Hdp:"(~?z_hdn)"
  assume z_Hdo:"?z_hdo"
  have z_Hdq: "?z_hda((CHOOSE zenon_Vg:(~((zenon_Vg \\in A)<=>(zenon_Vg \\in ?z_hs)))))"
  by (rule zenon_all_0 [of "?z_hda" "(CHOOSE zenon_Vg:(~((zenon_Vg \\in A)<=>(zenon_Vg \\in ?z_hs))))", OF z_Hcy])
  show FALSE
  proof (rule zenon_imply [OF z_Hdq])
   assume z_Hdr:"(~?z_hdo)"
   show FALSE
   by (rule notE [OF z_Hdr z_Hdo])
  next
   assume z_Hdn:"?z_hdn"
   show FALSE
   by (rule notE [OF z_Hdp z_Hdn])
  qed
 next
  assume z_Hdn:"?z_hdn"
  assume z_Hdr:"(~?z_hdo)"
  have z_Hds: "?z_hcx((CHOOSE zenon_Vg:(~((zenon_Vg \\in A)<=>(zenon_Vg \\in ?z_hs)))))"
  by (rule zenon_all_0 [of "?z_hcx" "(CHOOSE zenon_Vg:(~((zenon_Vg \\in A)<=>(zenon_Vg \\in ?z_hs))))", OF z_Hcs])
  show FALSE
  proof (rule zenon_imply [OF z_Hds])
   assume z_Hdp:"(~?z_hdn)"
   show FALSE
   by (rule notE [OF z_Hdp z_Hdn])
  next
   assume z_Hdo:"?z_hdo"
   show FALSE
   by (rule notE [OF z_Hdr z_Hdo])
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2282"; *} qed
lemma ob'2258:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'203: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'209: "(((((((pc) \<in> ([(ProcSet) \<rightarrow> ({(''L0''), (''E1''), (''E2''), (''E3''), (''D1''), (''D2''), (''D3''), (''D4'')})]))) & (((X) \<in> (((Nat) \\ ({((0))}))))) & (((Q) \<in> ([(((Nat) \\ ({((0))}))) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((i) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((j) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((l) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((x) \<in> ([(ProcSet) \<rightarrow> (((((Nat) \\ ({((0))}))) \<union> ({(BOT)})))]))) & (((v) \<in> ([(ProcSet) \<rightarrow> (((Nat) \\ ({((0))})))]))) & (((M) \<in> ((SUBSET (subsetOf((CDomain), %a_ca. ((CFTypeOK ((a_ca))))))))))) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'235: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'236: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'244: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'310: "((geq ((m), (k))))"
assumes v'311: "((geq ((m), (k))))"
assumes v'312: "(((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((v), (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))))))"
fixes q
assumes q_in : "(q \<in> (ProcSet))"
fixes r
assumes r_in : "(r \<in> (ProcSet))"
assumes v'337: "(((fapply ((pc), (p))) = (''E1'')))"
assumes v'338: "((((a_pchash_primea :: c)) = ([(pc) EXCEPT ![(p)] = (''E2'')])))"
assumes v'339: "((((a_ihash_primea :: c)) = ([(i) EXCEPT ![(p)] = (X)])))"
assumes v'340: "((((a_Xhash_primea :: c)) = ((arith_add ((X), ((Succ[0])))))))"
assumes v'341: "((((a_Qhash_primea :: c)) = (Q)))"
assumes v'342: "((((a_jhash_primea :: c)) = (j)))"
assumes v'343: "((((a_lhash_primea :: c)) = (l)))"
assumes v'344: "((((a_xhash_primea :: c)) = (x)))"
assumes v'345: "((((a_vhash_primea :: c)) = (v)))"
assumes v'346: "((((a_Mhash_primea :: c)) = (subsetOf((CDomain), %a_ca_1. (((a_h022c5783954683bdcbcacced356fd6a ((a_ca_1)) :: c)) & (\<exists> d_1 \<in> (M) : (\<exists> S \<in> ((SUBSET ((hc4e622ce2e33ef1c6a9f10c01956cd ((d_1)) :: c)))) : (\<exists> seq_1 \<in> ((Perm ((S)))) : ((((fapply ((a_ca_1), (''sigma''))) = ((Concat ((fapply ((d_1), (''sigma''))), ([ k_1 \<in> ((DOMAIN (seq_1)))  \<mapsto> (fapply ((v), (fapply ((seq_1), (k_1)))))])))))) & (\<forall> q_1 \<in> (ProcSet) : (cond((((q_1) \<in> (S))), (((fapply ((fapply ((a_ca_1), (''fres''))), (q_1))) = (ACK))), (((fapply ((fapply ((a_ca_1), (''fres''))), (q_1))) = (fapply ((fapply ((d_1), (''fres''))), (q_1)))))))))))))))))"
assumes v'347: "(((((((r) = (p))) \<and> (((fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))) = (X))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))))))))"
assumes v'348: "(((fapply ((v), (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r_1. (((((((r_1) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r_1))) = (''E2''))) \<and> (((fapply ((i), (r_1))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))) = (fapply ((v), (r)))))"
assumes v'349: "(((fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))) = (fapply ((seq), (m)))))"
shows "(((fapply (((a_ihash_primea :: c)), (r))) = (fapply ((seq), (m)))))"(is "PROP ?ob'2258")
proof -
ML_command {* writeln "*** TLAPS ENTER 2258"; *}
show "PROP ?ob'2258"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_8de12a.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_8de12a.znn.out
;; obligation #2258
$hyp "v'203" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'209" (/\ (/\ (/\ (TLA.in pc
(TLA.FuncSet ProcSet (TLA.set "L0" "E1" "E2" "E3" "D1" "D2" "D3" "D4")))
(TLA.in X (TLA.setminus arith.N (TLA.set 0))) (TLA.in Q
(TLA.FuncSet (TLA.setminus arith.N
(TLA.set 0)) (TLA.cup (TLA.setminus arith.N (TLA.set 0)) (TLA.set BOT))))
(TLA.in i (TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in j
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in l
(TLA.FuncSet ProcSet (TLA.setminus arith.N (TLA.set 0)))) (TLA.in x
(TLA.FuncSet ProcSet (TLA.cup (TLA.setminus arith.N (TLA.set 0))
(TLA.set BOT)))) (TLA.in v (TLA.FuncSet ProcSet (TLA.setminus arith.N
(TLA.set 0)))) (TLA.in M
(TLA.SUBSET (TLA.subsetOf CDomain ((a_ca) (CFTypeOK a_ca)))))) a_Invunde_E2a
a_Invunde_E3a a_Invunde_D2a a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina)
(\/ Next (= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'235" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'236" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'244" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$hyp "v'310" (arith.le k m)
$hyp "v'311" (arith.le k
m)
$hyp "v'312" (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z)))))))) (arith.add m
(arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))))
$hyp "q_in" (TLA.in q ProcSet)
$hyp "r_in" (TLA.in r ProcSet)
$hyp "v'337" (= (TLA.fapply pc p) "E1")
$hyp "v'338" (= a_pchash_primea
(TLA.except pc p "E2"))
$hyp "v'339" (= a_ihash_primea
(TLA.except i p X))
$hyp "v'340" (= a_Xhash_primea (arith.add X
(TLA.fapply TLA.Succ 0)))
$hyp "v'341" (= a_Qhash_primea Q)
$hyp "v'342" (= a_jhash_primea j)
$hyp "v'343" (= a_lhash_primea l)
$hyp "v'344" (= a_xhash_primea x)
$hyp "v'345" (= a_vhash_primea v)
$hyp "v'346" (= a_Mhash_primea
(TLA.subsetOf CDomain ((a_ca_1) (/\ (a_h022c5783954683bdcbcacced356fd6a a_ca_1)
(TLA.bEx M ((d_1) (TLA.bEx (TLA.SUBSET (hc4e622ce2e33ef1c6a9f10c01956cd d_1)) ((S) (TLA.bEx (Perm S) ((seq_1) (/\ (= (TLA.fapply a_ca_1 "sigma")
(Concat (TLA.fapply d_1 "sigma")
(TLA.Fcn (TLA.DOMAIN seq_1) ((k_1) (TLA.fapply v (TLA.fapply seq_1 k_1))))))
(TLA.bAll ProcSet ((q_1) (TLA.cond (TLA.in q_1
S) (= (TLA.fapply (TLA.fapply a_ca_1 "fres") q_1)
ACK) (= (TLA.fapply (TLA.fapply a_ca_1 "fres") q_1)
(TLA.fapply (TLA.fapply d_1 "fres") q_1))))))))))))))))
$hyp "v'347" (\/ (/\ (= r p)
(= (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.fapply seq (arith.add z
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) (arith.add m
(arith.minus (arith.add k (arith.minus (TLA.fapply TLA.Succ 0)))))) X))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.fapply seq (arith.add z
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) (arith.add m
(arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))))))
$hyp "v'348" (= (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r_1) (\/ (/\ (= r_1
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r_1) "E2") (= (TLA.fapply i r_1)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z)))))))) (arith.add m
(arith.minus (arith.add k (arith.minus (TLA.fapply TLA.Succ 0)))))))
(TLA.fapply v r))
$hyp "v'349" (= (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.fapply seq (arith.add z
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) (arith.add m
(arith.minus (arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))
(TLA.fapply seq m))
$goal (= (TLA.fapply a_ihash_primea r)
(TLA.fapply seq m))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hb:"((((pc \\in FuncSet(ProcSet, {''L0'', ''E1'', ''E2'', ''E3'', ''D1'', ''D2'', ''D3'', ''D4''}))&((X \\in (Nat \\ {0}))&((Q \\in FuncSet((Nat \\ {0}), ((Nat \\ {0}) \\cup {BOT})))&((i \\in FuncSet(ProcSet, (Nat \\ {0})))&((j \\in FuncSet(ProcSet, (Nat \\ {0})))&((l \\in FuncSet(ProcSet, (Nat \\ {0})))&((x \\in FuncSet(ProcSet, ((Nat \\ {0}) \\cup {BOT})))&((v \\in FuncSet(ProcSet, (Nat \\ {0})))&(M \\in SUBSET(subsetOf(CDomain, (\<lambda>a_ca. CFTypeOK(a_ca)))))))))))))&(a_Invunde_E2a&(a_Invunde_E3a&(a_Invunde_D2a&(a_Invunde_D3a&(a_Invunde_Qa&a_Invunde_Maina))))))&(Next|(a_h4fd5f73954dc53af536c1c75068837a=vars)))" (is "?z_hbd&?z_hdq")
 using v'209 by blast
 have z_Hr:"(a_ihash_primea=except(i, p, X))" (is "_=?z_hdw")
 using v'339 by blast
 have z_Hz:"(((r=p)&((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])=X))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))" (is "?z_hdy|?z_heu")
 using v'347 by blast
 have z_Hp:"((pc[p])=''E1'')" (is "?z_hez=?z_hbl")
 using v'337 by blast
 have z_Ho:"(r \\in ProcSet)" (is "?z_ho")
 using r_in by blast
 have z_Hbb:"((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])=(seq[m]))" (is "?z_hec=?z_hfa")
 using v'349 by blast
 have zenon_L1_: "(DOMAIN(i)=ProcSet) ==> (~(r \\in DOMAIN(i))) ==> ?z_ho ==> FALSE" (is "?z_hfb ==> ?z_hfd ==> _ ==> FALSE")
 proof -
  assume z_Hfb:"?z_hfb" (is "?z_hfc=_")
  assume z_Hfd:"?z_hfd" (is "~?z_hfe")
  assume z_Ho:"?z_ho"
  have z_Hff: "(\\A zenon_Vpd:((zenon_Vpd \\in ?z_hfc)<=>(zenon_Vpd \\in ProcSet)))" (is "\\A x : ?z_hfk(x)")
  by (rule zenon_setequal_0 [of "?z_hfc" "ProcSet", OF z_Hfb])
  have z_Hfl: "?z_hfk(r)"
  by (rule zenon_all_0 [of "?z_hfk" "r", OF z_Hff])
  show FALSE
  proof (rule zenon_equiv [OF z_Hfl])
   assume z_Hfd:"?z_hfd"
   assume z_Hfm:"(~?z_ho)"
   show FALSE
   by (rule notE [OF z_Hfm z_Ho])
  next
   assume z_Hfe:"?z_hfe"
   assume z_Ho:"?z_ho"
   show FALSE
   by (rule notE [OF z_Hfd z_Hfe])
  qed
 qed
 assume z_Hbc:"((a_ihash_primea[r])~=?z_hfa)" (is "?z_hfn~=_")
 have z_Hbd: "?z_hbd" (is "?z_hbe&?z_hdf")
 by (rule zenon_and_0 [OF z_Hb])
 have z_Hbe: "?z_hbe" (is "?z_hbf&?z_hbs")
 by (rule zenon_and_0 [OF z_Hbd])
 have z_Hbs: "?z_hbs" (is "?z_hbt&?z_hbz")
 by (rule zenon_and_1 [OF z_Hbe])
 have z_Hbz: "?z_hbz" (is "?z_hca&?z_hcg")
 by (rule zenon_and_1 [OF z_Hbs])
 have z_Hcg: "?z_hcg" (is "?z_hch&?z_hck")
 by (rule zenon_and_1 [OF z_Hbz])
 have z_Hch: "?z_hch"
 by (rule zenon_and_0 [OF z_Hcg])
 show FALSE
 proof (rule zenon_or [OF z_Hz])
  assume z_Hdy:"?z_hdy" (is "?z_hdz&?z_heb")
  have z_Hdz: "?z_hdz"
  by (rule zenon_and_0 [OF z_Hdy])
  have z_Heb: "?z_heb"
  by (rule zenon_and_1 [OF z_Hdy])
  have z_Hfb: "(DOMAIN(i)=ProcSet)" (is "?z_hfc=_")
  by (rule zenon_in_funcset_1 [of "i" "ProcSet" "(Nat \\ {0})", OF z_Hch])
  have z_Hfo: "((?z_hdw[r])~=?z_hfa)" (is "?z_hfp~=_")
  by (rule subst [where P="(\<lambda>zenon_Vxia. ((zenon_Vxia[r])~=?z_hfa))", OF z_Hr z_Hbc])
  show FALSE
  proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vf. (zenon_Vf~=?z_hfa))" "i" "p" "X" "r", OF z_Hfo])
   assume z_Hfe:"(r \\in ?z_hfc)" (is "?z_hfe")
   assume z_Hfx:"(p=r)"
   assume z_Hfy:"(X~=?z_hfa)"
   show FALSE
   proof (rule notE [OF z_Hbc])
    have z_Hfz: "(?z_hec=?z_hfn)"
    proof (rule zenon_nnpp [of "(?z_hec=?z_hfn)"])
     assume z_Hga:"(?z_hec~=?z_hfn)"
     show FALSE
     proof (rule zenon_em [of "(?z_hfn=?z_hfn)"])
      assume z_Hgb:"(?z_hfn=?z_hfn)"
      show FALSE
      proof (rule notE [OF z_Hga])
       have z_Hgc: "(?z_hfn=?z_hec)"
       proof (rule zenon_nnpp [of "(?z_hfn=?z_hec)"])
        assume z_Hgd:"(?z_hfn~=?z_hec)"
        have z_Hge: "(?z_hfp~=?z_hec)"
        by (rule subst [where P="(\<lambda>zenon_Vafa. ((zenon_Vafa[r])~=?z_hec))", OF z_Hr z_Hgd])
        show FALSE
        proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vbf. (zenon_Vbf~=?z_hec))" "i" "p" "X" "r", OF z_Hge])
         assume z_Hfe:"?z_hfe"
         assume z_Hfx:"(p=r)"
         assume z_Hgm:"(X~=?z_hec)"
         show FALSE
         by (rule zenon_eqsym [OF z_Heb z_Hgm])
        next
         assume z_Hfe:"?z_hfe"
         assume z_Hgn:"(p~=r)"
         assume z_Hgo:"((i[r])~=?z_hec)" (is "?z_hey~=_")
         show FALSE
         by (rule zenon_eqsym [OF z_Hdz z_Hgn])
        next
         assume z_Hfd:"(~?z_hfe)"
         show FALSE
         by (rule notE [OF z_Hfd z_Hfe])
        qed
       qed
       have z_Hfz: "(?z_hec=?z_hfn)"
       by (rule subst [where P="(\<lambda>zenon_Vjja. (zenon_Vjja=?z_hfn))", OF z_Hgc], fact z_Hgb)
       thus "(?z_hec=?z_hfn)" .
      qed
     next
      assume z_Hgs:"(?z_hfn~=?z_hfn)"
      show FALSE
      by (rule zenon_noteq [OF z_Hgs])
     qed
    qed
    have z_Hgt: "(?z_hfn=?z_hfa)"
    by (rule subst [where P="(\<lambda>zenon_Vg. (zenon_Vg=?z_hfa))", OF z_Hfz], fact z_Hbb)
    thus "(?z_hfn=?z_hfa)" .
   qed
  next
   assume z_Hfe:"(r \\in ?z_hfc)" (is "?z_hfe")
   assume z_Hgn:"(p~=r)"
   assume z_Hgx:"((i[r])~=?z_hfa)" (is "?z_hey~=_")
   show FALSE
   by (rule zenon_eqsym [OF z_Hdz z_Hgn])
  next
   assume z_Hfd:"(~(r \\in ?z_hfc))" (is "~?z_hfe")
   show FALSE
   by (rule zenon_L1_ [OF z_Hfb z_Hfd z_Ho])
  qed
 next
  assume z_Heu:"?z_heu" (is "?z_hev&?z_hex")
  have z_Hev: "?z_hev" (is "?z_hew=?z_hbm")
  by (rule zenon_and_0 [OF z_Heu])
  have z_Hex: "?z_hex" (is "?z_hey=_")
  by (rule zenon_and_1 [OF z_Heu])
  have z_Hgy: "(?z_hbm~=?z_hbl)"
  by auto
  have z_Hgz: "(?z_hew~=?z_hez)"
  by (rule zenon_stringdiffll [OF z_Hgy z_Hev z_Hp])
   have z_Hfb: "(DOMAIN(i)=ProcSet)" (is "?z_hfc=_")
   by (rule zenon_in_funcset_1 [of "i" "ProcSet" "(Nat \\ {0})", OF z_Hch])
   have z_Hfo: "((?z_hdw[r])~=?z_hfa)" (is "?z_hfp~=_")
   by (rule subst [where P="(\<lambda>zenon_Vxia. ((zenon_Vxia[r])~=?z_hfa))", OF z_Hr z_Hbc])
   show FALSE
   proof (rule zenon_noteq [of "?z_hez"])
    have z_Hdz: "(r=p)"
    proof (rule zenon_nnpp [of "(r=p)"])
     assume z_Hha:"(r~=p)"
     show FALSE
     proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vf. (zenon_Vf~=?z_hfa))" "i" "p" "X" "r", OF z_Hfo])
      assume z_Hfe:"(r \\in ?z_hfc)" (is "?z_hfe")
      assume z_Hfx:"(p=r)"
      assume z_Hfy:"(X~=?z_hfa)"
      show FALSE
      by (rule zenon_eqsym [OF z_Hfx z_Hha])
     next
      assume z_Hfe:"(r \\in ?z_hfc)" (is "?z_hfe")
      assume z_Hgn:"(p~=r)"
      assume z_Hgx:"(?z_hey~=?z_hfa)"
      show FALSE
      proof (rule notE [OF z_Hbc])
       have z_Hfz: "(?z_hec=?z_hfn)"
       proof (rule zenon_nnpp [of "(?z_hec=?z_hfn)"])
        assume z_Hga:"(?z_hec~=?z_hfn)"
        show FALSE
        proof (rule zenon_em [of "(?z_hfn=?z_hfn)"])
         assume z_Hgb:"(?z_hfn=?z_hfn)"
         show FALSE
         proof (rule notE [OF z_Hga])
          have z_Hgc: "(?z_hfn=?z_hec)"
          proof (rule zenon_nnpp [of "(?z_hfn=?z_hec)"])
           assume z_Hgd:"(?z_hfn~=?z_hec)"
           have z_Hge: "(?z_hfp~=?z_hec)"
           by (rule subst [where P="(\<lambda>zenon_Vafa. ((zenon_Vafa[r])~=?z_hec))", OF z_Hr z_Hgd])
           show FALSE
           proof (rule zenon_fapplyexcept [of "(\<lambda>zenon_Vbf. (zenon_Vbf~=?z_hec))" "i" "p" "X" "r", OF z_Hge])
            assume z_Hfe:"?z_hfe"
            assume z_Hfx:"(p=r)"
            assume z_Hgm:"(X~=?z_hec)"
            show FALSE
            by (rule zenon_eqsym [OF z_Hfx z_Hha])
           next
            assume z_Hfe:"?z_hfe"
            assume z_Hgn:"(p~=r)"
            assume z_Hgo:"(?z_hey~=?z_hec)"
            show FALSE
            by (rule notE [OF z_Hgo z_Hex])
           next
            assume z_Hfd:"(~?z_hfe)"
            show FALSE
            by (rule notE [OF z_Hfd z_Hfe])
           qed
          qed
          have z_Hfz: "(?z_hec=?z_hfn)"
          by (rule subst [where P="(\<lambda>zenon_Vjja. (zenon_Vjja=?z_hfn))", OF z_Hgc], fact z_Hgb)
          thus "(?z_hec=?z_hfn)" .
         qed
        next
         assume z_Hgs:"(?z_hfn~=?z_hfn)"
         show FALSE
         by (rule zenon_noteq [OF z_Hgs])
        qed
       qed
       have z_Hgt: "(?z_hfn=?z_hfa)"
       by (rule subst [where P="(\<lambda>zenon_Vg. (zenon_Vg=?z_hfa))", OF z_Hfz], fact z_Hbb)
       thus "(?z_hfn=?z_hfa)" .
      qed
     next
      assume z_Hfd:"(~(r \\in ?z_hfc))" (is "~?z_hfe")
      show FALSE
      by (rule zenon_L1_ [OF z_Hfb z_Hfd z_Ho])
     qed
    qed
    have z_Hhb: "(?z_hez~=?z_hez)"
    by (rule subst [where P="(\<lambda>zenon_Vnja. ((pc[zenon_Vnja])~=?z_hez))", OF z_Hdz], fact z_Hgz)
    thus "(?z_hez~=?z_hez)" .
   qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2258"; *} qed
lemma ob'2253:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes m
assumes m_in : "(m \<in> ((DOMAIN (seq))))"
assumes v'311: "((geq ((m), (k))))"
assumes v'312: "((geq ((m), (k))))"
assumes v'313: "(((fapply ((fapply ((d), (''sigma''))), (m))) = (fapply ((v), (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))))))"
fixes q
assumes q_in : "(q \<in> (ProcSet))"
assumes v'332: "(((fapply ((v), (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))) = (fapply ((v), (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))))))))))))))"
assumes v'333: "(\<exists> r \<in> (ProcSet) : (((((((r) = (p))) \<and> (((fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))) = (X))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))))))))"
assumes v'334: "(\<forall> r \<in> (ProcSet) : (((((fapply ((pc), (r))) = (''E2''))) \<Rightarrow> (((fapply ((i), (r))) = (fapply (((a_ihash_primea :: c)), (r))))))))"
shows "(\<exists> r \<in> (ProcSet) : (((((((((r) = (p))) \<and> (((fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))) = (X))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))))))) \<and> (((fapply ((v), (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r_1. (((((((r_1) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r_1))) = (''E2''))) \<and> (((fapply ((i), (r_1))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]), ((arith_add ((m), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))) = (fapply ((v), (r))))))))"(is "PROP ?ob'2253")
proof -
ML_command {* writeln "*** TLAPS ENTER 2253"; *}
show "PROP ?ob'2253"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_53b50f.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_53b50f.znn.out
;; obligation #2253
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "m_in" (TLA.in m (TLA.DOMAIN seq))
$hyp "v'311" (arith.le k m)
$hyp "v'312" (arith.le k
m)
$hyp "v'313" (= (TLA.fapply (TLA.fapply d "sigma") m)
(TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z)))))))) (arith.add m
(arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))))
$hyp "q_in" (TLA.in q ProcSet)
$hyp "v'332" (= (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z)))))))) (arith.add m
(arith.minus (arith.add k (arith.minus (TLA.fapply TLA.Succ 0)))))))
(TLA.fapply v (TLA.bChoice ProcSet ((r) (\/ (/\ (= r p) (= X
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.fapply seq (arith.add z
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) (arith.add m
(arith.minus (arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.fapply seq (arith.add z
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) (arith.add m
(arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))))))))))
$hyp "v'333" (TLA.bEx ProcSet ((r) (\/ (/\ (= r p)
(= (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.fapply seq (arith.add z
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) (arith.add m
(arith.minus (arith.add k (arith.minus (TLA.fapply TLA.Succ 0)))))) X))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.fapply seq (arith.add z
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) (arith.add m
(arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))))))))
$hyp "v'334" (TLA.bAll ProcSet ((r) (=> (= (TLA.fapply pc r) "E2")
(= (TLA.fapply i r)
(TLA.fapply a_ihash_primea r)))))
$goal (TLA.bEx ProcSet ((r) (/\ (\/ (/\ (= r p)
(= (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.fapply seq (arith.add z
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) (arith.add m
(arith.minus (arith.add k (arith.minus (TLA.fapply TLA.Succ 0)))))) X))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.fapply seq (arith.add z
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) (arith.add m
(arith.minus (arith.add k (arith.minus (TLA.fapply TLA.Succ 0)))))))))
(= (TLA.fapply v (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r_1) (\/ (/\ (= r_1
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r_1) "E2") (= (TLA.fapply i r_1)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z)))))))) (arith.add m
(arith.minus (arith.add k (arith.minus (TLA.fapply TLA.Succ 0)))))))
(TLA.fapply v r)))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hp:"bEx(ProcSet, (\<lambda>r. (((r=p)&((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])=X))|(((pc[r])=''E2'')&((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))))" (is "?z_hp")
 using v'333 by blast
 have z_Hq:"bAll(ProcSet, (\<lambda>r. (((pc[r])=''E2'')=>((i[r])=(a_ihash_primea[r])))))" (is "?z_hq")
 using v'334 by blast
 have z_Hc:"(p \\in ProcSet)" (is "?z_hc")
 using p_in by blast
 have z_Ho:"((v[(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[(m +  -.((k +  -.(1))))])])=(v[bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))))]))" (is "?z_hcg=?z_hcu")
 using v'332 by blast
 have zenon_L1_: "(~((((CHOOSE x:((x \\in ProcSet)&(((x=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))|(((pc[x])=''E2'')&((i[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))))=p)&((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])=X))|(((pc[(CHOOSE x:((x \\in ProcSet)&(((x=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))|(((pc[x])=''E2'')&((i[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))))])=''E2'')&((i[(CHOOSE x:((x \\in ProcSet)&(((x=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))|(((pc[x])=''E2'')&((i[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))))])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))) ==> ((CHOOSE x:((x \\in ProcSet)&(((x=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))|(((pc[x])=''E2'')&((i[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))))=p) ==> (X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])) ==> FALSE" (is "?z_hdc ==> ?z_hdf ==> ?z_hcz ==> FALSE")
 proof -
  assume z_Hdc:"?z_hdc" (is "~(?z_hde|?z_hds)")
  assume z_Hdf:"?z_hdf" (is "?z_hdg=_")
  assume z_Hcz:"?z_hcz" (is "_=?z_hba")
  have z_Hdx: "(~?z_hde)" (is "~(_&?z_hz)")
  by (rule zenon_notor_0 [OF z_Hdc])
  show FALSE
  proof (rule zenon_notand [OF z_Hdx])
   assume z_Hdy:"(?z_hdg~=p)"
   show FALSE
   by (rule notE [OF z_Hdy z_Hdf])
  next
   assume z_Hdz:"(?z_hba~=X)"
   show FALSE
   by (rule zenon_eqsym [OF z_Hcz z_Hdz])
  qed
 qed
 have zenon_L2_: "(?z_hcg~=(v[(CHOOSE x:((x \\in ProcSet)&(((x=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))|(((pc[x])=''E2'')&((i[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))))])) ==> (?z_hcg=?z_hcu) ==> FALSE" (is "?z_hea ==> ?z_ho ==> FALSE")
 proof -
  assume z_Hea:"?z_hea" (is "_~=?z_heb")
  assume z_Ho:"?z_ho"
  show FALSE
  proof (rule notE [OF z_Hea])
   have z_Hec: "(?z_hcu=?z_heb)"
   proof (rule zenon_nnpp [of "(?z_hcu=?z_heb)"])
    assume z_Hed:"(?z_hcu~=?z_heb)"
    have z_Hee_z_Hed: "(?z_heb~=?z_heb) == (?z_hcu~=?z_heb)" (is "?z_hee == ?z_hed")
    by (unfold bChoose_def)
    have z_Hee: "?z_hee"
    by (unfold z_Hee_z_Hed, fact z_Hed)
    show FALSE
    by (rule zenon_noteq [OF z_Hee])
   qed
   have z_Hef: "(?z_hcg=?z_heb)"
   by (rule subst [where P="(\<lambda>zenon_Vuoa. (?z_hcg=zenon_Vuoa))", OF z_Hec], fact z_Ho)
   thus "(?z_hcg=?z_heb)" .
  qed
 qed
 have zenon_L3_: "(~((((CHOOSE x:((x \\in ProcSet)&(((x=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))|(((pc[x])=''E2'')&((i[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))))=p)&((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])=X))|(((pc[(CHOOSE x:((x \\in ProcSet)&(((x=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))|(((pc[x])=''E2'')&((i[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))))])=''E2'')&((i[(CHOOSE x:((x \\in ProcSet)&(((x=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))|(((pc[x])=''E2'')&((i[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))))])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))) ==> (((pc[(CHOOSE x:((x \\in ProcSet)&(((x=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))|(((pc[x])=''E2'')&((i[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))))])=''E2'')&((i[(CHOOSE x:((x \\in ProcSet)&(((x=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))|(((pc[x])=''E2'')&((i[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))))])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))) ==> FALSE" (is "?z_hdc ==> ?z_hds ==> FALSE")
 proof -
  assume z_Hdc:"?z_hdc" (is "~(?z_hde|_)")
  assume z_Hds:"?z_hds" (is "?z_hdt&?z_hdv")
  have z_Hej: "(~?z_hds)"
  by (rule zenon_notor_1 [OF z_Hdc])
  show FALSE
  by (rule notE [OF z_Hej z_Hds])
 qed
 have zenon_L4_: "(\\E x:((x \\in ProcSet)&(((x=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))|(((pc[x])=''E2'')&((i[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))))) ==> (~(\\E x:((x \\in ProcSet)&((((x=p)&((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])=X))|(((pc[x])=''E2'')&((i[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))&(?z_hcg=(v[x])))))) ==> (?z_hcg=?z_hcu) ==> FALSE" (is "?z_hek ==> ?z_hel ==> ?z_ho ==> FALSE")
 proof -
  assume z_Hek:"?z_hek" (is "\\E x : ?z_het(x)")
  assume z_Hel:"?z_hel" (is "~(\\E x : ?z_heu(x))")
  assume z_Ho:"?z_ho"
  have z_Hev: "?z_het((CHOOSE x:((x \\in ProcSet)&(((x=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))|(((pc[x])=''E2'')&((i[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))))))" (is "?z_hew&?z_hex")
  by (rule zenon_ex_choose_0 [of "?z_het", OF z_Hek])
  have z_Hew: "?z_hew"
  by (rule zenon_and_0 [OF z_Hev])
  have z_Hex: "?z_hex" (is "?z_hey|?z_hds")
  by (rule zenon_and_1 [OF z_Hev])
  show FALSE
  proof (rule zenon_or [OF z_Hex])
   assume z_Hey:"?z_hey" (is "?z_hdf&?z_hcz")
   have z_Hdf: "?z_hdf" (is "?z_hdg=_")
   by (rule zenon_and_0 [OF z_Hey])
   have z_Hcz: "?z_hcz" (is "_=?z_hba")
   by (rule zenon_and_1 [OF z_Hey])
   have z_Hez: "~?z_heu(?z_hdg)" (is "~(_&?z_hfa)")
   by (rule zenon_notex_0 [of "?z_heu" "?z_hdg", OF z_Hel])
   show FALSE
   proof (rule zenon_notand [OF z_Hez])
    assume z_Hfb:"(~?z_hew)"
    show FALSE
    by (rule notE [OF z_Hfb z_Hew])
   next
    assume z_Hfc:"(~?z_hfa)" (is "~(?z_hdd&?z_hef)")
    show FALSE
    proof (rule zenon_notand [OF z_Hfc])
     assume z_Hdc:"(~?z_hdd)" (is "~(?z_hde|_)")
     show FALSE
     by (rule zenon_L1_ [OF z_Hdc z_Hdf z_Hcz])
    next
     assume z_Hea:"(?z_hcg~=(v[?z_hdg]))" (is "_~=?z_heb")
     show FALSE
     by (rule zenon_L2_ [OF z_Hea z_Ho])
    qed
   qed
  next
   assume z_Hds:"?z_hds" (is "?z_hdt&?z_hdv")
   have z_Hez: "~?z_heu((CHOOSE x:((x \\in ProcSet)&(((x=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))|(((pc[x])=''E2'')&((i[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))))))" (is "~(_&?z_hfa)")
   by (rule zenon_notex_0 [of "?z_heu" "(CHOOSE x:((x \\in ProcSet)&(((x=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))|(((pc[x])=''E2'')&((i[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))))", OF z_Hel])
   show FALSE
   proof (rule zenon_notand [OF z_Hez])
    assume z_Hfb:"(~?z_hew)"
    show FALSE
    by (rule notE [OF z_Hfb z_Hew])
   next
    assume z_Hfc:"(~?z_hfa)" (is "~(?z_hdd&?z_hef)")
    show FALSE
    proof (rule zenon_notand [OF z_Hfc])
     assume z_Hdc:"(~?z_hdd)" (is "~(?z_hde|_)")
     show FALSE
     by (rule zenon_L3_ [OF z_Hdc z_Hds])
    next
     assume z_Hea:"(?z_hcg~=(v[(CHOOSE x:((x \\in ProcSet)&(((x=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))|(((pc[x])=''E2'')&((i[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))))]))" (is "_~=?z_heb")
     show FALSE
     by (rule zenon_L2_ [OF z_Hea z_Ho])
    qed
   qed
  qed
 qed
 assume z_Hr:"(~bEx(ProcSet, (\<lambda>r. ((((r=p)&((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])=X))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))&(?z_hcg=(v[r]))))))" (is "~?z_hfd")
 have z_Hfj_z_Hp: "(\\E x:((x \\in ProcSet)&(((x=p)&((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])=X))|(((pc[x])=''E2'')&((a_ihash_primea[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))))) == ?z_hp" (is "?z_hfj == _")
 by (unfold bEx_def)
 have z_Hfj: "?z_hfj" (is "\\E x : ?z_hfp(x)")
 by (unfold z_Hfj_z_Hp, fact z_Hp)
 have z_Hfq: "?z_hfp((CHOOSE x:((x \\in ProcSet)&(((x=p)&((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])=X))|(((pc[x])=''E2'')&((a_ihash_primea[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])))))))" (is "?z_hfs&?z_hft")
 by (rule zenon_ex_choose_0 [of "?z_hfp", OF z_Hfj])
 have z_Hfs: "?z_hfs"
 by (rule zenon_and_0 [OF z_Hfq])
 have z_Hft: "?z_hft" (is "?z_hfu|?z_hfv")
 by (rule zenon_and_1 [OF z_Hfq])
 have z_Hel_z_Hr: "(~(\\E x:((x \\in ProcSet)&((((x=p)&((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))])=X))|(((pc[x])=''E2'')&((i[x])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(m +  -.((k +  -.(1))))]))))&(?z_hcg=(v[x])))))) == (~?z_hfd)" (is "?z_hel == ?z_hr")
 by (unfold bEx_def)
 have z_Hel: "?z_hel" (is "~(\\E x : ?z_heu(x))")
 by (unfold z_Hel_z_Hr, fact z_Hr)
 show FALSE
 proof (rule zenon_or [OF z_Hft])
  assume z_Hfu:"?z_hfu" (is "?z_hfw&?z_hz")
  have z_Hz: "?z_hz" (is "?z_hba=_")
  by (rule zenon_and_1 [OF z_Hfu])
  show FALSE
  proof (rule zenon_em [of "(\\E x:((x \\in ProcSet)&(((x=p)&(X=?z_hba))|(((pc[x])=''E2'')&((i[x])=?z_hba)))))"])
   assume z_Hek:"(\\E x:((x \\in ProcSet)&(((x=p)&(X=?z_hba))|(((pc[x])=''E2'')&((i[x])=?z_hba)))))" (is "\\E x : ?z_het(x)")
   show FALSE
   by (rule zenon_L4_ [OF z_Hek z_Hel z_Ho])
  next
   assume z_Hfx:"(~(\\E x:((x \\in ProcSet)&(((x=p)&(X=?z_hba))|(((pc[x])=''E2'')&((i[x])=?z_hba))))))" (is "~(\\E x : ?z_het(x))")
   have z_Hfy: "~?z_het(p)" (is "~(_&?z_hfz)")
   by (rule zenon_notex_0 [of "?z_het" "p", OF z_Hfx])
   show FALSE
   proof (rule zenon_notand [OF z_Hfy])
    assume z_Hga:"(~?z_hc)"
    show FALSE
    by (rule notE [OF z_Hga z_Hc])
   next
    assume z_Hgb:"(~?z_hfz)" (is "~(?z_hgc|?z_hgd)")
    have z_Hge: "(~?z_hgc)" (is "~(?z_hgf&?z_hcz)")
    by (rule zenon_notor_0 [OF z_Hgb])
    show FALSE
    proof (rule zenon_notand [OF z_Hge])
     assume z_Hgg:"(p~=p)"
     show FALSE
     by (rule zenon_noteq [OF z_Hgg])
    next
     assume z_Hgh:"(X~=?z_hba)"
     show FALSE
     by (rule zenon_eqsym [OF z_Hz z_Hgh])
    qed
   qed
  qed
 next
  assume z_Hfv:"?z_hfv" (is "?z_hgi&?z_hgj")
  have z_Hgi: "?z_hgi" (is "?z_hgk=?z_hbx")
  by (rule zenon_and_0 [OF z_Hfv])
  have z_Hgj: "?z_hgj" (is "?z_hgl=?z_hba")
  by (rule zenon_and_1 [OF z_Hfv])
  show FALSE
  proof (rule zenon_em [of "(\\E x:((x \\in ProcSet)&(((x=p)&(X=?z_hba))|(((pc[x])=?z_hbx)&((i[x])=?z_hba)))))"])
   assume z_Hek:"(\\E x:((x \\in ProcSet)&(((x=p)&(X=?z_hba))|(((pc[x])=?z_hbx)&((i[x])=?z_hba)))))" (is "\\E x : ?z_het(x)")
   show FALSE
   by (rule zenon_L4_ [OF z_Hek z_Hel z_Ho])
  next
   assume z_Hfx:"(~(\\E x:((x \\in ProcSet)&(((x=p)&(X=?z_hba))|(((pc[x])=?z_hbx)&((i[x])=?z_hba))))))" (is "~(\\E x : ?z_het(x))")
   have z_Hgm: "~?z_het((CHOOSE x:((x \\in ProcSet)&(((x=p)&(?z_hba=X))|(((pc[x])=?z_hbx)&((a_ihash_primea[x])=?z_hba))))))" (is "~(_&?z_hgn)")
   by (rule zenon_notex_0 [of "?z_het" "(CHOOSE x:((x \\in ProcSet)&(((x=p)&(?z_hba=X))|(((pc[x])=?z_hbx)&((a_ihash_primea[x])=?z_hba)))))", OF z_Hfx])
   show FALSE
   proof (rule zenon_notand [OF z_Hgm])
    assume z_Hgo:"(~?z_hfs)"
    show FALSE
    by (rule notE [OF z_Hgo z_Hfs])
   next
    assume z_Hgp:"(~?z_hgn)" (is "~(?z_hgq|?z_hgr)")
    have z_Hgs: "(~?z_hgr)" (is "~(_&?z_hgt)")
    by (rule zenon_notor_1 [OF z_Hgp])
    show FALSE
    proof (rule zenon_notand [OF z_Hgs])
     assume z_Hgu:"(?z_hgk~=?z_hbx)"
     show FALSE
     by (rule notE [OF z_Hgu z_Hgi])
    next
     assume z_Hgv:"((i[(CHOOSE x:((x \\in ProcSet)&(((x=p)&(?z_hba=X))|(((pc[x])=?z_hbx)&((a_ihash_primea[x])=?z_hba)))))])~=?z_hba)" (is "?z_hgw~=_")
     have z_Hgx: "(?z_hgi=>(?z_hgw=?z_hgl))" (is "_=>?z_hgy")
     by (rule zenon_all_in_0 [of "ProcSet" "(\<lambda>r. (((pc[r])=?z_hbx)=>((i[r])=(a_ihash_primea[r]))))", OF z_Hq z_Hfs])
     show FALSE
     proof (rule zenon_imply [OF z_Hgx])
      assume z_Hgu:"(?z_hgk~=?z_hbx)"
      show FALSE
      by (rule notE [OF z_Hgu z_Hgi])
     next
      assume z_Hgy:"?z_hgy"
      show FALSE
      proof (rule notE [OF z_Hgv])
       have z_Hgz: "(?z_hgl=?z_hgw)"
       by (rule sym [OF z_Hgy])
       have z_Hgt: "?z_hgt"
       by (rule subst [where P="(\<lambda>zenon_Vvoa. (zenon_Vvoa=?z_hba))", OF z_Hgz], fact z_Hgj)
       thus "?z_hgt" .
      qed
     qed
    qed
   qed
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2253"; *} qed
lemma ob'2341:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes q
assumes q_in : "(q \<in> (ProcSet))"
fixes a
assumes a_in : "(a \<in> (A))"
fixes idx
assumes idx_in : "(idx \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
assumes v'307: "((geq ((idx), (k))))"
fixes r
assumes r_in : "(r \<in> (ProcSet))"
assumes v'320: "(((r) \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r_1. (((((((r_1) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r_1))) = (''E2''))) \<and> (((fapply ((i), (r_1))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r_1. (((((((r_1) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r_1))) = (''E2''))) \<and> (((fapply ((i), (r_1))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))))"
assumes v'321: "(\<forall> a_runde_a \<in> (ProcSet) : (((((((fapply (((a_pchash_primea :: c)), (a_runde_a))) = (fapply (((a_pchash_primea :: c)), (r))))) \<and> (((fapply (((a_ihash_primea :: c)), (a_runde_a))) = (fapply (((a_ihash_primea :: c)), (r))))))) \<Rightarrow> (((r) = (a_runde_a))))))"
assumes v'322: "(((fapply (((a_pchash_primea :: c)), (r))) = (''E2'')))"
assumes v'323: "(((fapply (((a_ihash_primea :: c)), (r))) = (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), ((arith_add ((idx), ((minus (((arith_add ((k), ((minus (((Succ[0]))))))))))))))))))"
shows "(((fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), ((arith_add ((idx), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))) \<in> (setOfAll((setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r_1. (((((((r_1) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r_1))) = (''E2''))) \<and> (((fapply ((i), (r_1))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r_1. (((((((r_1) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r_1))) = (''E2''))) \<and> (((fapply ((i), (r_1))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))), %a_runde_a. (fapply (((a_ihash_primea :: c)), (a_runde_a)))))))"(is "PROP ?ob'2341")
proof -
ML_command {* writeln "*** TLAPS ENTER 2341"; *}
show "PROP ?ob'2341"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_c0c70d.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_c0c70d.znn.out
;; obligation #2341
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "q_in" (TLA.in q ProcSet)
$hyp "a_in" (TLA.in a A)
$hyp "idx_in" (TLA.in idx (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "v'307" (arith.le k
idx)
$hyp "r_in" (TLA.in r ProcSet)
$hyp "v'320" (TLA.in r
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r_1) (\/ (/\ (= r_1
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r_1) "E2") (= (TLA.fapply i r_1)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r_1) (\/ (/\ (= r_1
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r_1) "E2") (= (TLA.fapply i r_1)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))))
$hyp "v'321" (TLA.bAll ProcSet ((a_runde_a) (=> (/\ (= (TLA.fapply a_pchash_primea a_runde_a)
(TLA.fapply a_pchash_primea r)) (= (TLA.fapply a_ihash_primea a_runde_a)
(TLA.fapply a_ihash_primea r))) (= r
a_runde_a))))
$hyp "v'322" (= (TLA.fapply a_pchash_primea r)
"E2")
$hyp "v'323" (= (TLA.fapply a_ihash_primea r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.fapply seq (arith.add z
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) (arith.add idx
(arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))))
$goal (TLA.in (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.fapply seq (arith.add z
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) (arith.add idx
(arith.minus (arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))
(TLA.setOfAll (TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r_1) (\/ (/\ (= r_1
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r_1) "E2") (= (TLA.fapply i r_1)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r_1) (\/ (/\ (= r_1
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r_1) "E2") (= (TLA.fapply i r_1)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))) ((a_runde_a) (TLA.fapply a_ihash_primea a_runde_a))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hs:"((a_ihash_primea[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[(idx +  -.((k +  -.(1))))]))" (is "?z_hu=?z_hx")
 using v'323 by blast
 have z_Hp:"(r \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r_1. (((r_1=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r_1])=''E2'')&((i[r_1])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r_1. (((r_1=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r_1])=''E2'')&((i[r_1])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))" (is "?z_hp")
 using v'320 by blast
 assume z_Ht:"(~(?z_hx \\in setOfAll(setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r_1. (((r_1=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r_1])=''E2'')&((i[r_1])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r_1. (((r_1=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r_1])=''E2'')&((i[r_1])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))), (\<lambda>a_runde_a. (a_ihash_primea[a_runde_a])))))" (is "~?z_hcp")
 have z_Hcu: "(~(\\E zenon_Vh:((zenon_Vh \\in setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r_1. (((r_1=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r_1])=''E2'')&((i[r_1])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r_1. (((r_1=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r_1])=''E2'')&((i[r_1])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))))&(?z_hx=(a_ihash_primea[zenon_Vh])))))" (is "~(\\E x : ?z_hdb(x))")
 by (rule zenon_notin_setofall_0 [of "?z_hx" "setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r_1. (((r_1=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r_1])=''E2'')&((i[r_1])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r_1. (((r_1=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r_1])=''E2'')&((i[r_1])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z])))" "(\<lambda>a_runde_a. (a_ihash_primea[a_runde_a]))", OF z_Ht])
 have z_Hdc: "~?z_hdb(r)" (is "~(_&?z_hdd)")
 by (rule zenon_notex_0 [of "?z_hdb" "r", OF z_Hcu])
 show FALSE
 proof (rule zenon_notand [OF z_Hdc])
  assume z_Hde:"(~?z_hp)"
  show FALSE
  by (rule notE [OF z_Hde z_Hp])
 next
  assume z_Hdf:"(?z_hx~=?z_hu)"
  show FALSE
  by (rule zenon_eqsym [OF z_Hs z_Hdf])
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2341"; *} qed
lemma ob'2315:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes q
assumes q_in : "(q \<in> (ProcSet))"
fixes a
assumes a_in : "(a \<in> (A))"
fixes idx
assumes idx_in : "(idx \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
assumes v'307: "((geq ((idx), (k))))"
fixes r
assumes r_in : "(r \<in> (ProcSet))"
assumes v'321: "(((r) = (p)))"
assumes v'325: "((((arith_add ((idx), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))) \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))))"
assumes v'326: "(\<forall> a_runde_a \<in> (ProcSet) : (((((((fapply ((pc), (a_runde_a))) = (''E2''))) \<and> (((fapply ((i), (a_runde_a))) = (fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), ((arith_add ((idx), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))))) \<Rightarrow> (FALSE))))"
assumes v'327: "(((fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), ((arith_add ((idx), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))) = (X)))"
shows "(((fapply (([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r_1. (((((((r_1) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r_1))) = (''E2''))) \<and> (((fapply ((i), (r_1))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]), ((arith_add ((idx), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))) = (r)))"(is "PROP ?ob'2315")
proof -
ML_command {* writeln "*** TLAPS ENTER 2315"; *}
show "PROP ?ob'2315"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_00d0f7.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_00d0f7.znn.out
;; obligation #2315
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "q_in" (TLA.in q ProcSet)
$hyp "a_in" (TLA.in a A)
$hyp "idx_in" (TLA.in idx (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "v'307" (arith.le k idx)
$hyp "r_in" (TLA.in r ProcSet)
$hyp "v'321" (= r p)
$hyp "v'325" (TLA.in (arith.add idx (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))
(arith.intrange (TLA.fapply TLA.Succ 0) (arith.add (Cardinality A)
(arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))))
$hyp "v'326" (TLA.bAll ProcSet ((a_runde_a) (=> (/\ (= (TLA.fapply pc a_runde_a)
"E2") (= (TLA.fapply i a_runde_a)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.fapply seq (arith.add z
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) (arith.add idx
(arith.minus (arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))))
F.)))
$hyp "v'327" (= (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.fapply seq (arith.add z
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) (arith.add idx
(arith.minus (arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))
X)
$goal (= (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r_1) (\/ (/\ (= r_1
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r_1) "E2") (= (TLA.fapply i r_1)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z)))))))) (arith.add idx
(arith.minus (arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))
r)
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hp:"(r=p)"
 using v'321 by blast
 have z_Hs:"((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (seq[(z + (k +  -.(1)))])))[(idx +  -.((k +  -.(1))))])=X)" (is "?z_hw=_")
 using v'327 by blast
 have z_Hr:"bAll(ProcSet, (\<lambda>a_runde_a. ((((pc[a_runde_a])=''E2'')&((i[a_runde_a])=?z_hw))=>FALSE)))" (is "?z_hr")
 using v'326 by blast
 have z_Hc:"(p \\in ProcSet)" (is "?z_hc")
 using p_in by blast
 have z_Hq:"((idx +  -.((k +  -.(1)))) \\in isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))))" (is "?z_hq")
 using v'325 by blast
 have zenon_L1_: "(?z_hw=X) ==> (X~=?z_hw) ==> FALSE" (is "?z_hs ==> ?z_hcc ==> FALSE")
 proof -
  assume z_Hs:"?z_hs"
  assume z_Hcc:"?z_hcc"
  have z_Hcd: "(?z_hw~=?z_hw)"
  by (rule ssubst [where P="(\<lambda>zenon_Vmb. (zenon_Vmb~=?z_hw))", OF z_Hs z_Hcc])
  show FALSE
  by (rule zenon_noteq [OF z_Hcd])
 qed
 assume z_Ht:"((Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r_1. (((r_1=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (seq[(z + (k +  -.(1)))])))[z])))|(((pc[r_1])=''E2'')&((i[r_1])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (seq[(z + (k +  -.(1)))])))[z]))))))))[(idx +  -.((k +  -.(1))))])~=r)" (is "?z_hch~=_")
 have z_Hcx_z_Hr: "(\\A x:((x \\in ProcSet)=>((((pc[x])=''E2'')&((i[x])=?z_hw))=>FALSE))) == ?z_hr" (is "?z_hcx == _")
 by (unfold bAll_def)
 have z_Hcx: "?z_hcx" (is "\\A x : ?z_hdh(x)")
 by (unfold z_Hcx_z_Hr, fact z_Hr)
 have z_Hdi: "(?z_hch~=p)"
 by (rule subst [where P="(\<lambda>zenon_Vid. (?z_hch~=zenon_Vid))", OF z_Hp z_Ht])
 show FALSE
 proof (rule zenon_fapplyfcn [of "(\<lambda>zenon_Vxa. (zenon_Vxa~=p))" "isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1)))))" "(\<lambda>z. bChoice(ProcSet, (\<lambda>r_1. (((r_1=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (seq[(z + (k +  -.(1)))])))[z])))|(((pc[r_1])=''E2'')&((i[r_1])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. (seq[(z + (k +  -.(1)))])))[z])))))))" "(idx +  -.((k +  -.(1))))", OF z_Hdi])
  assume z_Hdp:"(~?z_hq)"
  show FALSE
  by (rule notE [OF z_Hdp z_Hq])
 next
  assume z_Hdq:"(bChoice(ProcSet, (\<lambda>r_1. (((r_1=p)&(X=?z_hw))|(((pc[r_1])=''E2'')&((i[r_1])=?z_hw)))))~=p)" (is "?z_hdr~=_")
  have z_Hdy_z_Hdq: "((CHOOSE x:((x \\in ProcSet)&(((x=p)&(X=?z_hw))|(((pc[x])=''E2'')&((i[x])=?z_hw)))))~=p) == (?z_hdr~=p)" (is "?z_hdy == ?z_hdq")
  by (unfold bChoose_def)
  have z_Hdy: "?z_hdy" (is "?z_hdz~=_")
  by (unfold z_Hdy_z_Hdq, fact z_Hdq)
  show FALSE
  proof (rule zenon_em [of "(\\E x:((x \\in ProcSet)&(((x=p)&(X=?z_hw))|(((pc[x])=''E2'')&((i[x])=?z_hw)))))"])
   assume z_Hee:"(\\E x:((x \\in ProcSet)&(((x=p)&(X=?z_hw))|(((pc[x])=''E2'')&((i[x])=?z_hw)))))" (is "\\E x : ?z_hef(x)")
   have z_Heg: "?z_hef(?z_hdz)" (is "?z_heh&?z_hei")
   by (rule zenon_ex_choose_0 [of "?z_hef", OF z_Hee])
   have z_Heh: "?z_heh"
   by (rule zenon_and_0 [OF z_Heg])
   have z_Hei: "?z_hei" (is "?z_hej|?z_hek")
   by (rule zenon_and_1 [OF z_Heg])
   show FALSE
   proof (rule zenon_or [OF z_Hei])
    assume z_Hej:"?z_hej" (is "?z_hel&?z_hdv")
    have z_Hel: "?z_hel"
    by (rule zenon_and_0 [OF z_Hej])
    show FALSE
    by (rule notE [OF z_Hdy z_Hel])
   next
    assume z_Hek:"?z_hek" (is "?z_hem&?z_hen")
    have z_Hem: "?z_hem" (is "?z_heo=?z_hbx")
    by (rule zenon_and_0 [OF z_Hek])
    have z_Hen: "?z_hen" (is "?z_hep=_")
    by (rule zenon_and_1 [OF z_Hek])
    have z_Heq: "?z_hdh(?z_hdz)" (is "_=>?z_her")
    by (rule zenon_all_0 [of "?z_hdh" "?z_hdz", OF z_Hcx])
    show FALSE
    proof (rule zenon_imply [OF z_Heq])
     assume z_Hes:"(~?z_heh)"
     show FALSE
     by (rule notE [OF z_Hes z_Heh])
    next
     assume z_Her:"?z_her" (is "_=>?z_hcb")
     show FALSE
     proof (rule zenon_imply [OF z_Her])
      assume z_Het:"(~?z_hek)"
      show FALSE
      proof (rule zenon_notand [OF z_Het])
       assume z_Heu:"(?z_heo~=?z_hbx)"
       show FALSE
       by (rule notE [OF z_Heu z_Hem])
      next
       assume z_Hev:"(?z_hep~=?z_hw)"
       show FALSE
       by (rule notE [OF z_Hev z_Hen])
      qed
     next
      assume z_Hcb:"?z_hcb"
      show FALSE
      by (rule z_Hcb)
     qed
    qed
   qed
  next
   assume z_Hew:"(~(\\E x:((x \\in ProcSet)&(((x=p)&(X=?z_hw))|(((pc[x])=''E2'')&((i[x])=?z_hw))))))" (is "~(\\E x : ?z_hef(x))")
   have z_Hex: "~?z_hef(p)" (is "~(_&?z_hey)")
   by (rule zenon_notex_0 [of "?z_hef" "p", OF z_Hew])
   show FALSE
   proof (rule zenon_notand [OF z_Hex])
    assume z_Hez:"(~?z_hc)"
    show FALSE
    by (rule notE [OF z_Hez z_Hc])
   next
    assume z_Hfa:"(~?z_hey)" (is "~(?z_hfb|?z_hfc)")
    have z_Hfd: "(~?z_hfb)" (is "~(?z_hfe&?z_hdv)")
    by (rule zenon_notor_0 [OF z_Hfa])
    show FALSE
    proof (rule zenon_notand [OF z_Hfd])
     assume z_Hff:"(p~=p)"
     show FALSE
     by (rule zenon_noteq [OF z_Hff])
    next
     assume z_Hcc:"(X~=?z_hw)"
     show FALSE
     by (rule zenon_L1_ [OF z_Hs z_Hcc])
    qed
   qed
  qed
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2315"; *} qed
lemma ob'2455:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes q
assumes q_in : "(q \<in> (ProcSet))"
assumes v'296: "(((q) \<notin> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))))"
assumes v'307: "(((fapply ((i), (q))) \<in> (setOfAll((setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))), %r. (fapply (((a_ihash_primea :: c)), (r)))))))"
assumes v'308: "(((fapply ((pc), (q))) = (''E2'')))"
fixes r
assumes r_in : "(r \<in> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))))"
assumes v'322: "(((r) = (p)))"
assumes v'325: "((less ((fapply ((i), (q))), (X))))"
assumes v'326: "(((fapply (((a_ihash_primea :: c)), (p))) = (X)))"
assumes v'327: "(((fapply ((i), (q))) = (fapply (((a_ihash_primea :: c)), (r)))))"
shows "(((r) = (q)))"(is "PROP ?ob'2455")
proof -
ML_command {* writeln "*** TLAPS ENTER 2455"; *}
show "PROP ?ob'2455"
using assms by auto
ML_command {* writeln "*** TLAPS EXIT 2455"; *} qed
lemma ob'2445:
(* usable definition IsFiniteSet suppressed *)
(* usable definition Cardinality suppressed *)
(* usable definition Restrict suppressed *)
(* usable definition Range suppressed *)
(* usable definition Inverse suppressed *)
(* usable definition Injection suppressed *)
(* usable definition Surjection suppressed *)
(* usable definition Bijection suppressed *)
(* usable definition ExistsInjection suppressed *)
(* usable definition ExistsSurjection suppressed *)
(* usable definition ExistsBijection suppressed *)
(* usable definition NatInductiveDefHypothesis suppressed *)
(* usable definition NatInductiveDefConclusion suppressed *)
(* usable definition FiniteNatInductiveDefHypothesis suppressed *)
(* usable definition FiniteNatInductiveDefConclusion suppressed *)
(* usable definition IsTransitivelyClosedOn suppressed *)
(* usable definition IsWellFoundedOn suppressed *)
(* usable definition SetLessThan suppressed *)
(* usable definition WFDefOn suppressed *)
(* usable definition OpDefinesFcn suppressed *)
(* usable definition WFInductiveDefines suppressed *)
(* usable definition WFInductiveUnique suppressed *)
(* usable definition TransitiveClosureOn suppressed *)
(* usable definition OpToRel suppressed *)
(* usable definition PreImage suppressed *)
(* usable definition LexPairOrdering suppressed *)
(* usable definition LexProductOrdering suppressed *)
(* usable definition FiniteSubsetsOf suppressed *)
(* usable definition StrictSubsetOrdering suppressed *)
(* usable definition Perm suppressed *)
(* usable definition Len suppressed *)
fixes ACK
fixes BOT
fixes ProcSet
fixes pc pc'
fixes X X'
fixes Q Q'
fixes i i'
fixes j j'
fixes l l'
fixes x x'
fixes v v'
fixes M M'
(* usable definition vars suppressed *)
(* usable definition Seqs suppressed *)
(* usable definition Concat suppressed *)
(* usable definition Head suppressed *)
(* usable definition Tail suppressed *)
(* usable definition Init suppressed *)
(* usable definition CDomain suppressed *)
(* usable definition CFTypeOK suppressed *)
(* usable definition UnlinearizedEnqs suppressed *)
(* usable definition Filter suppressed *)
(* usable definition L0 suppressed *)
(* usable definition E2 suppressed *)
(* usable definition E3 suppressed *)
(* usable definition D1 suppressed *)
(* usable definition D2 suppressed *)
(* usable definition D3 suppressed *)
(* usable definition D4 suppressed *)
(* usable definition Next suppressed *)
(* usable definition Spec suppressed *)
(* usable definition TypeOK suppressed *)
(* usable definition Inv_E2 suppressed *)
(* usable definition Inv_E3 suppressed *)
(* usable definition Inv_D2 suppressed *)
(* usable definition Inv_D3 suppressed *)
(* usable definition Inv_Q suppressed *)
(* usable definition GoodEnqSet suppressed *)
(* usable definition ValuesMatchInds suppressed *)
(* usable definition GoodRes suppressed *)
(* usable definition JInvSeq suppressed *)
(* usable definition Inv_Main suppressed *)
(* usable definition Linearizable suppressed *)
(* usable definition Inv suppressed *)
assumes v'204: "((((ACK) \<noteq> (BOT))) & (((BOT) \<notin> (Nat))))"
assumes v'210: "((((TypeOK) & (a_Invunde_E2a) & (a_Invunde_E3a) & (a_Invunde_D2a) & (a_Invunde_D3a) & (a_Invunde_Qa) & (a_Invunde_Maina)) \<and> (((Next) \<or> ((((a_h4fd5f73954dc53af536c1c75068837a :: c)) = (vars)))))))"
fixes p
assumes p_in : "(p \<in> (ProcSet))"
fixes A
assumes A_in : "(A \<in> ((SUBSET ((isa_peri_peri_a (((Succ[0])), ((arith_add (((a_Xhash_primea :: c)), ((minus (((Succ[0]))))))))))))))"
fixes seq
assumes seq_in : "(seq \<in> ((Perm ((A)))))"
assumes v'236: "((a_h809dcbde4a0ebaffb04edba90d34c1a ((A)) :: c))"
assumes v'237: "((a_h76227835d3f4b8a2f4a94c89f14166a ((seq)) :: c))"
assumes v'245: "(((fapply (((a_ihash_primea :: c)), (p))) \<in> (A)))"
fixes k
assumes k_in : "(k \<in> ((isa_peri_peri_a (((Succ[0])), ((Cardinality ((A))))))))"
fixes a_ca
assumes a_ca_in : "(a_ca \<in> (M))"
(* usable definition d suppressed *)
(* usable definition P suppressed *)
fixes q
assumes q_in : "(q \<in> (ProcSet))"
assumes v'296: "(((q) \<notin> (setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z)))))))"
assumes v'307: "(((((((fapply ((pc), (q))) = (''E2''))) \<and> (((fapply ((i), (q))) \<in> (setOfAll((setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))), %r. (fapply (((a_ihash_primea :: c)), (r))))))))) \<Longrightarrow> (FALSE)))"
assumes v'308: "(((A) = (((setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z))))) \<union> (setOfAll((setOfAll(((DOMAIN ([ z \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_1), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z)))))))))))]))), %z. (fapply (([ z_1 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (bChoice((ProcSet), %r. (((((((r) = (p))) \<and> (((X) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1))))))) \<or> (((((fapply ((pc), (r))) = (''E2''))) \<and> (((fapply ((i), (r))) = (fapply (([ z_2 \<in> ((isa_peri_peri_a (((Succ[0])), ((arith_add (((Cardinality ((A)))), ((minus (((arith_add ((k), ((minus (((Succ[0])))))))))))))))))  \<mapsto> (fapply ((seq), ((arith_add ((z_2), ((arith_add ((k), ((minus (((Succ[0])))))))))))))]), (z_1)))))))))))]), (z))))), %r. (fapply (((a_ihash_primea :: c)), (r)))))))))"
shows "(((((((fapply ((pc), (q))) = (''E2''))) \<and> (((fapply ((i), (q))) \<in> (A))))) \<Rightarrow> (((fapply ((i), (q))) \<in> (setOfAll(((isa_peri_peri_a (((Succ[0])), ((arith_add ((k), ((minus (((Succ[0]))))))))))), %z. (fapply ((seq), (z)))))))))"(is "PROP ?ob'2445")
proof -
ML_command {* writeln "*** TLAPS ENTER 2445"; *}
show "PROP ?ob'2445"

(* BEGIN ZENON INPUT
;; file=POPL24_HerlihyWingQueue.tlaps/tlapm_07dbdf.znn; PATH='/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/bin:/opt/tools/tlaps/lib/tlaps/bin'; zenon -p0 -x tla -oisar -max-time 1d "$file" >POPL24_HerlihyWingQueue.tlaps/tlapm_07dbdf.znn.out
;; obligation #2445
$hyp "v'204" (/\ (-. (= ACK BOT)) (-. (TLA.in BOT
arith.N)))
$hyp "v'210" (/\ (/\ TypeOK a_Invunde_E2a a_Invunde_E3a a_Invunde_D2a
a_Invunde_D3a a_Invunde_Qa a_Invunde_Maina) (\/ Next
(= a_h4fd5f73954dc53af536c1c75068837a
vars)))
$hyp "p_in" (TLA.in p ProcSet)
$hyp "A_in" (TLA.in A (TLA.SUBSET (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add a_Xhash_primea
(arith.minus (TLA.fapply TLA.Succ 0))))))
$hyp "seq_in" (TLA.in seq (Perm A))
$hyp "v'236" (a_h809dcbde4a0ebaffb04edba90d34c1a A)
$hyp "v'237" (a_h76227835d3f4b8a2f4a94c89f14166a seq)
$hyp "v'245" (TLA.in (TLA.fapply a_ihash_primea p)
A)
$hyp "k_in" (TLA.in k (arith.intrange (TLA.fapply TLA.Succ 0)
(Cardinality A)))
$hyp "a_ca_in" (TLA.in a_ca M)
$hyp "q_in" (TLA.in q ProcSet)
$hyp "v'296" (-. (TLA.in q
(TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z)))))
$hyp "v'307" (=> (/\ (= (TLA.fapply pc q) "E2") (TLA.in (TLA.fapply i q)
(TLA.setOfAll (TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))) ((r) (TLA.fapply a_ihash_primea r))))) F.)
$hyp "v'308" (= A
(TLA.cup (TLA.setOfAll (arith.intrange (TLA.fapply TLA.Succ 0) (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z)))
(TLA.setOfAll (TLA.setOfAll (TLA.DOMAIN (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.fapply seq (arith.add z_1
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z))))))))) ((z) (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_1) (TLA.bChoice ProcSet ((r) (\/ (/\ (= r
p) (= X (TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k (arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))
(/\ (= (TLA.fapply pc r) "E2") (= (TLA.fapply i r)
(TLA.fapply (TLA.Fcn (arith.intrange (TLA.fapply TLA.Succ 0)
(arith.add (Cardinality A) (arith.minus (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))))) ((z_2) (TLA.fapply seq (arith.add z_2
(arith.add k
(arith.minus (TLA.fapply TLA.Succ 0))))))) z_1)))))))) z))) ((r) (TLA.fapply a_ihash_primea r)))))
$goal (=> (/\ (= (TLA.fapply pc q) "E2") (TLA.in (TLA.fapply i q) A))
(TLA.in (TLA.fapply i q)
(TLA.setOfAll (arith.intrange (TLA.fapply TLA.Succ 0) (arith.add k
(arith.minus (TLA.fapply TLA.Succ 0)))) ((z) (TLA.fapply seq z)))))
END ZENON  INPUT *)
(* PROOF-FOUND *)
(* BEGIN-PROOF *)
proof (rule zenon_nnpp)
 have z_Hm:"((((pc[q])=''E2'')&((i[q]) \\in setOfAll(setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))), (\<lambda>r. (a_ihash_primea[r])))))=>FALSE)" (is "?z_hp=>?z_hco")
 using v'307 by blast
 have z_Hn:"(A=(setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))) \\cup setOfAll(setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=''E2'')&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))), (\<lambda>r. (a_ihash_primea[r])))))" (is "_=?z_hcp")
 using v'308 by blast
 assume z_Ho:"(~((((pc[q])=''E2'')&((i[q]) \\in A))=>((i[q]) \\in setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z]))))))" (is "~(?z_hcv=>?z_hcx)")
 have z_Hcv: "?z_hcv" (is "?z_hq&?z_hcw")
 by (rule zenon_notimply_0 [OF z_Ho])
 have z_Hcy: "(~?z_hcx)"
 by (rule zenon_notimply_1 [OF z_Ho])
 have z_Hq: "?z_hq" (is "?z_hr=?z_hu")
 by (rule zenon_and_0 [OF z_Hcv])
 have z_Hcw: "?z_hcw"
 by (rule zenon_and_1 [OF z_Hcv])
 show FALSE
 proof (rule zenon_imply [OF z_Hm])
  assume z_Hcz:"(~?z_hp)" (is "~(_&?z_hv)")
  show FALSE
  proof (rule zenon_notand [OF z_Hcz])
   assume z_Hda:"(?z_hr~=?z_hu)"
   show FALSE
   by (rule notE [OF z_Hda z_Hq])
  next
   assume z_Hdb:"(~?z_hv)"
   have z_Hdc: "((i[q]) \\in ?z_hcp)" (is "?z_hdc")
   by (rule subst [where P="(\<lambda>zenon_Vwa. ((i[q]) \\in zenon_Vwa))", OF z_Hn z_Hcw])
   show FALSE
   proof (rule zenon_in_cup [of "(i[q])" "setOfAll(isa'dotdot(1, (k +  -.(1))), (\<lambda>z. (seq[z])))" "setOfAll(setOfAll(DOMAIN(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=?z_hu)&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))), (\<lambda>z. (Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z. bChoice(ProcSet, (\<lambda>r. (((r=p)&(X=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z])))|(((pc[r])=?z_hu)&((i[r])=(Fcn(isa'dotdot(1, (Cardinality(A) +  -.((k +  -.(1))))), (\<lambda>z_1. (seq[(z_1 + (k +  -.(1)))])))[z]))))))))[z]))), (\<lambda>r. (a_ihash_primea[r])))", OF z_Hdc])
    assume z_Hcx:"?z_hcx"
    show FALSE
    by (rule notE [OF z_Hcy z_Hcx])
   next
    assume z_Hv:"?z_hv"
    show FALSE
    by (rule notE [OF z_Hdb z_Hv])
   qed
  qed
 next
  assume z_Hco:"?z_hco"
  show FALSE
  by (rule z_Hco)
 qed
qed
(* END-PROOF *)
ML_command {* writeln "*** TLAPS EXIT 2445"; *} qed
end
